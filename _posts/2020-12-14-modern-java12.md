---
title: 모던 자바 인 액션 - 16장 CompletableFuture - 안정적 비동기 프로그래밍
description: 모던 자바 인 액션 - 16장 CompletableFuture - 안정적 비동기 프로그래밍
categories:
 - dev
tags:
 - java
comments: true
---
> Modern Java In Action 정리 - CompletableFuture - 안정적 비동기 프로그래밍

  * 비동기 작업을 만들고 결과 얻기
  * 비블록 동작으로 생산성 높이기
  * 비동기 API 설계와 구현
  * 동기 API를 비동기적으로 소비하기
  * 두 개 이상의 비동기 연산을 파이프라인으로 만들고 합치기
  * 비동기 작업 완료에 대응하기

`모던 자바 인 액션 책을 보고 정리한 글입니다.` 

작성중인 글입니다.

## Future의 단순활용
* Java 5 부터 미래의 어느 시점에 결과를 얻는 모델에 활용할수 있도록 Future 인터페이스를 제공하고 있다. 
* 시간이 걸리는 작업들을 Future 내부에 설정하여 호출자 스레드가 결과를 기다리는 동안 다른 유용한 작업들을 할 수 있다. 

```java
ExecutorService es =ex.newCachedThreadPool();
Future<Double> future = ex.submit(new Callable<Double>() {
  public Double call() {
    return doSomeLongComputation();
  }
})
doSomeThingElse();
future.get(1, TimeUnit.SECONDS); // 비동기 결과가 준비되어 있지 않으면 1초간 기다린다. 
```

* 위 예재와 같이 시간이 오래 걸리는 작업을 다른 스레드에서 처리하고 메인 스레드에서는 다른 작업들을 미리 수행할 수 있다. 
* 만약 결과가 준비되지 않았다면 작업이 완료될때까지 스레드를 블록할 수 있다. 이때 영원히 스레드가 종료되지 않는 경우를 대비하여 최대 타임아웃을 설정가능하다. 

### Future 제한
* 첫번째 예제에서는 Future 인터페이스가 비동기 계산이 끝났는지 확인할수 있는 isDone, 게산이 끝나길 기다리는 메서드, 결과 회수 메서드등을 제공한다. 하지만 이들만으로 동시 실행 코드를 구현하기 어렵다. 
* 오래걸리는 A 계산이 끝나면 B를 실행하라 와 같은 요구사항을 쉽게 구현할 수 있어야 한다. 
* Future로 이와같은 동작을 구현하는것은 쉽지 않다. 다음과 같은 선언형 기능이 있다면 유용하게 사용할 수 있을것이다. 
  * 두 개의 비동기 계산 결과를 하나로 합친다. 두 계산은 하나에 의존하는 상황일수도, 독립적인 계산일수도 있다. 
  * Future 집합이 샐행하는 모든 테스크의 완료를 기다린다. 
  * Future 집합에서 가장 빨리 완료되는 테스크를 기다렸다가 결과를 얻는다. (예를 들어 여러 테스크가 다양한 방식으로 같은 결과를 얻는 방법)
  * 프로그램적으로 Future를 완료 시킨다. (비동기 동작에 수동으로 결과 제공)
  * Future 완료 동작에 반응한다. (결과를 기다리며 블록되지 않고 결과가 준비되었다는 알림을 받은 다음 Future의 결과로 원하는 추가 동작을 수행가능)
* 선언형으로 Future를 사용할 수 있는 CompletableFuture 클래스에 대해 알아본다.
* Stream과 비슷하게 람다표현식과 파이프라이닝을 활용, 따라서 Future와 CompletableFuture는 Collection과 Stream의 관계에 비유가능하다. 

### CompletableFuture로 비동기 애플리케이션 만들기
* 첫쨰. 고객에게 비동기 API를 제공하는 방법을 배운다. 
* 둘쨰. 동기 API를 사용해야할 때 코드를 비블록으로 만드는 방법을 배운다. 두 개의 비동기 동작을 파이프라인으로 만드는 방법과 두 개의 동작 결과를 하나의 비동기 계산으로 합치는 방법.
* 셋째. 비동기 동작의 완료에 대응하는 방법을 배운다.

## 비동기 API 구현
```java
public class Shop {
  public double getPrice(String product) {
      return calculatePrice(product);
  }

  private double calculatePrice(String product) {
      delay();
      return new Random().nextDouble() * product.charAt(0) + product.charAt(1);
  }
  
  public static void delay() {
      try {
          Thread.sleep(1000L);
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
  }
}
```

* getPrice는 외부 요청과 같이 시간이 오래걸리는 작업을 수행 할 수 있으므로 임의로 1초 동안 sleep 메소드를 호출하였다. 
* 위 API를 사용자가 호출하는 경우 비동기 동작이 완료될때까지 1초 동안 블록된다. 
* 동기 메소드를 비동기 메소드로 소비하는 방법을 알아보자.

### 동기 메서드를 비동기 메서드로 변환
* 동기 메서드 getPrice를 비동기 메서드로 변환하려면 이름과 반환값을 변경해야 한다. 
  
```java
public Future<Double> getPriceAnsync(String product)
```

* Future는 결과값의 핸들일 뿐 계산이 완료되면 get 메서들르 통해 결과를 얻을 수 있다. 다시말해 getPriceAnsync 메서드는 즉시 반환되고 호출자 스레드는 다른 작업을 수행할 수 있다.

```java
public Future<Double> getPriceAnsync(String product) {
    CompletableFuture<Double> futurePrice = new CompletableFuture<>();
    
    new Thread(() -> {
        double price = calculatePrice(product); // 다른 스레드에서 비동기로 계산 
        futurePrice.complete(price); // 결과값 전달
    }).start();
    
    return futurePrice;
}
```

* 상점은 비동기 API를 제공함으로 즉시 Future를 반환한다. 클라이언트는 전달 받은 Future를 이용하여 적절한 시점에 결과를 얻을 수 있고, 그 동안 다른 작업을 수행 가능하다. 
* Future의 get 메서드 호출시 결과값을 가지고 있다면 곧바로 값을 읽지만 그렇지 않으면 계산이 완료될때 까지 블록한다.

### 에러 처리 방법
* 가격을 계산하는 동안 에러가 발생하는 경우 해당 쓰레드에만 영향을 미치게 되어 전체적인 결과값이 잘못되거나 클라이언트에서 응답을 무한히 기다리게 될 수 있다. 
* 클라이언트는 타임아웃 값을 받는 get 메서드를 활용하여 문제를 해결할 수있다. 하지만 일반적으로는 어떠한 이유로 TimeoutException이 발생한지는 알수 없을것이다.
* CompleteExceptionally 메서드를 이용하여 CompletableFuture 내부에서 발생한 예외를 클라이언트로 전달해보자. 

```java
public Future<Double> getPriceAnsync(String product) {
    CompletableFuture<Double> futurePrice = new CompletableFuture<>();

    new Thread(() -> {
        try {
            double price = calculatePrice(product); // 다른 스레드에서 비동기로 계산
            futurePrice.complete(price); // 결과값 전달
        } catch (Exception ex) {
            futurePrice.completeExceptionally(ex); // 문제가 발생하는 경우 에러를 포함시켜 Future를 종료
        }
    }).start();

    return futurePrice;
}
```

#### 팩토리 메서드 supplyAsync로 CompletableFuture 만들기
  
```java
public Future<Double> getPriceAnsync(String product) {
    return CompletableFuture.supplyAsync(() -> calculatePrice(product));
}
```

## 비블록 코드 만들기

```java
private List<Shop> shops = Arrays.asList(new Shop("shop1"), 
            new Shop("shop2"), 
            new Shop("shop3"),
            new Shop("shop4"));

public List<String> findPrices(String product) {
    return shops.stream()
            .map(shop -> String.format("%s is %.2f", shop.getName(), shop.getPrice(product)))
            .collect(Collectors.toList());
}
```

* 위와 같은 예제를 실행한다면 shops의 수 만큼 price를 순차적으로 계산하게 되어 많은 시간이 소요될 것이다. 

### 병렬 스트림으로 요청 병렬화 하기

```java
public List<String> findPrices(String product) {
    return shops.parallelStream()
            .map(shop -> String.format("%s is %.2f", shop.getName(), shop.getPrice(product)))
            .collect(Collectors.toList());
}
```

* 병렬 스트림을 이용하여 동시에 가격을 계산할 수 있도록 개선하면 시간이 단축된다. 
* 다음은 CompletableFuture를 활용하여 findPrices 메서드의 동기 호출을 비동기 호출로 변경해보자. 

### CompletableFuture로 비동기 호출 구현하기

```java
// 팩토리 메서드를 활용
public List<String> findPrices(String product) {
    List<CompletableFuture<String>> priceFutures = shops.stream()
            .map(shop -> CompletableFuture.supplyAsync(() -> String.format("%s is %.2f", shop.getName(), shop.getPrice(product))))
            .collect(Collectors.toList());


    return priceFutures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
}
```

* CompletableFuture 리스트를 만든 후 계산이 끝난 결과를 추출하는 예시이다. CompletableFuture의 join메서드를 활용했는데 Future의 get 메서드와 같은 의미를 갖는다. 
* 다른점으로는 join 메서드는 예외를 발생시키지 않는다는 점이다. 