---
title: 모던 자바 인 액션 - 8장 컬렉션 API 개선
description: 모던 자바 인 액션 - 8장 컬렉션 API 개선
categories:
 - dev
tags:
 - java
comments: true
---
> Modern Java In Action 정리 - 컬렉션 API 개선

  * 컬렉션 팩토리 사용하기
  * 리스트 및 집합과 사용할 새로운 관용패턴 배우기
  * 맵과 사용할 새로운 관용 패턴 배우기

`모던 자바 인 액션 책을 보고 정리한 글입니다.` 

작성중인 글입니다.

# 컬렉션 팩토리
* 자바 9에서는 작은 컬렉션 객체를 쉽게 만들수 있는 몇 가지 방법을 제공한다. 
```java
List<String> friends = new ArrayList<>();
friends.add("Raphael");
friends.add("Olivia");
friends.add("Thibaut");
```
* 위처럼 세 문자열을 저장하는데 많은 코드가 소요된다 따라서 아래와 같이 사용하여 코드를 줄일 수 있다.
```java
List<String> friends = Arrays.asList("Raphael", "Olivia", "Thibaut");
```
* 고정된 크기의 리스트를 만들었으니 새로운 요소를 추가하거나 요소를 삭제한다면 UnsupportedOperationException 이 발생한다. 요소를 갱신하는것은 정상적으로 작동한다.
* Java 9 부터는 작은 리스트, 집합, 맵을 쉽게 만들 수 있도록 팩토리 메서드를 제공한다.

### 리스트 팩토리
* List.of 팩토리 메서드를 활용하여 간단하게 리스트를 만들수 있게 되었다.
```java
List<String> friends = List.of("Raphael", "Olivia", "Thibaut");
```
* of 메소드를 사용하더라도 요소를 추가하거나 삭제하면 여전히 UnsupportedOperationException 에러가 발생한다. 
* 때로는 컬렉션이 의도치 않게 변경되는것을 막는것이 더 효과적일수 있다.
* Arrays.asList와 of의 차이점은 가변인수를 사용하지 않는다는것이다. 
```java

    static <E> List<E> of() {
        return ImmutableCollections.emptyList();
    }

    static <E> List<E> of(E e1) {
        return new List12(e1);
    }
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
        return new ListN(new Object[]{e1, e2, e3, e4, e5, e6, e7, e8, e9, e10});
    }
```
* 가변인수를 사용한다면 그만큼의 배열을 리스트로 만들고 추후 객체 반환까지 해야하는 비용이 발생하지만 리스트 팩토리 메서드를 활용해 불필요한 비용을 줄일수 있게 되었다.

### 집합 팩토리
* List.of와 비슷하게 변경 불가능한 집합을 만들수 있다.
```java
Set<String> friends = Set.of("Raphael", "Olivia", "Thibaut");
```

### 맵 팩토리
* 맵을 만드는것은 리스트나 Set을 만드는것에 비해 조금 복잡하지만 Java 9 에서 두가지 방법으로 맵을 만들수 있도록 제공하고 있다.
```java
// Key - Value 를 번갈아 가며 생성
Map<String, Integer> friendsMap = Map.of("Raphael", 30, "Olivia", 30, "Thibaut", 30);

// Map의 인수가 많을경우 entry를 활용해서 만드는것이 좋다.
Map<String, Integer> friendsMapEntry = Map.ofEntries(entry("Raphael", 30),
                entry("Olivia", 30),
                entry("Thibaut", 30));
```

## 리스트와 집합 처리
* 자바 8에서는 List, Set 인터페이스에 다음과 같은 메서드를 추가했다. 
* removeIf : Predicate를 만족하는 요소를 제거한다. List나 Set을 구현하거나 구현을 상속받은 클래스에서 이용할 수 있다
* replaceAll : 리스트에서 이용할수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다.
* sort : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.
* 위 메서드들은 호출한 컬렉션 자체를 변경하게 된다. 일반적으로 새로운 결과를 만드는 스트림과는 달리 기존 컬렉션에 변화를 주는 기능이 추가된 이유는 무엇일까 ? 

### removeIf
```java
for (Transaction transaction : transactions) {
  if (True) {
    transactions.remove(transaction);
  }
}
```
* 위 코드는 ConcurrentModificationException 에러를 발생시킨다. for - each 루프는 내부적으로 iterator 객체를 사용하므로 아래와 같이 해석된다.
```java
for (Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext();) {
  Transaction transaction = iterator.next();
  if (true) {
    transactions.remove(transaction);
  }
}
```
* 두 개의 개별 객체가 컬렉션을 관리하는 것에 주목.
* Iterator 객체 : next(), hasNext()를 사용해 소스를 질의 한다.
* Collection 객체 : remove()를 호출하여 요소를 삭제
* 결과적으로 반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않고 있다. 아래와 같이 Iterator 객체를 명시적으로 삭제하여 문제를 해결할 수 있다.
```java
for (Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext();) {
  Transaction transaction = iterator.next();
  if (true) {
    iterator.remove();
  }
}
```
* 코드가 조금 복잡해졌지만 위 코드 패턴은 Java8의 removeIf 메서드로 변경할 수 있다. 위에서 말한것 처럼 removeIf는 Predicate를 인수로 받는다.
```java
transactions.removeIf(transaction -> true);
```

### replaceAll 메서드
* List 인터페이스의 replaceAll 메서드를 이용하여 리스트의 각 요소를 새로운 요소로 변경할 수 있다. 일반적으로 스트림 Api 를 사용한다면 아래와 같이 사용가능하다.
```java
referenceCodes.stream()
              .map(Strings::toUpperCase))
              .collect(toList());
```
* 위 처럼 스트림을 활용한다면 새로운 컬렉션이 생성되고 기존 컬렉션은 변경되지 않는다. 기존 컬렉션을 변경하기 위해 아래와 같이 사용할 수 있다. 
```java
for (ListIterator<String> iterator = referenceCodes.listIterator(); iterator.hasNext();) {
  iterator.hasNext();
  String code = iterator.next();
  iterator.set(code.toUpperCase());
}
```
* 코드가 복잡해지고 컬렉션 객체를 Iterator와 혼용하여 사용한다면 반복과 컬렉션 변경이 동시에 이루어 지며 쉽게 문제를 일으킨다. 
* Java8 에서 제공하는 기능을 사용하도록 하자
```java
referenceCodes.replaceAll(code -> code.toUpperCase());
```