---
title: 쿠버네티스 인 액션 - 12장 쿠버네티스 API 서버 보안
description: 쿠버네티스 인 액션 - 12장 쿠버네티스 API 서버 보안
categories:
 - dev
tags:
 - kubernetes
comments: true
---
> Kubernetes In Action 정리 - 쿠버네티스 API 서버 보안

  * 인증에 대한 이해
  * 서비스 어카운트란 무엇이며 사용하는 이유
  * 역할 기반 액세스 제어(RBAC) 플러그인 이해
  * 롤과 롤바인딩 사용
  * 클러스터롤과 클러스터롤바인딩 사용
  * 디폴트 롤과 바인딩 이해

## 12.1 인증 이해
API 서버는 하나 이상의 인증 플러그인으로 구성할 수 있다. API 서버가 요청을 받으면 인증 플러그인 목록을 거쳐 요청이 전달, 각각 인증 플러그인이 요청을 검사한다.  
여러 인증 플러그인을 사용할 수 있으며 인증 플러그인은 다음 방법을 사용해 클라이언트의 아이덴티티를 얻는다. 

* 클라이언트의 인증서
* HTTP 헤더로 전달된 인증 토큰
* 기본 HTTP 인증
* 기타

### 12.1.1 사용자와 그룹
인증 플러그인은 인증된 사용자의 이름과 그룹을 반환한다. 쿠버네티스는 해당 정보를 어디에도 저장하지 않으며 이를 사용해 사용자의 권한을 검사한다. 

### 사용자
쿠버네티스는 API 서버에 접속하는 두 종류의 클라이언트를 구분
* 사용자
* 파드(파드 내부에서 실행되는 어플리케이션)

사용자는 싱글 사인 온과 같은 외부 시스템에 의해 관리되어야 하지만 파드는 서비스 어카운트라는 매커니즘을 사용하며 쿠버네티스 리소스로 생성되고 관리된다. 이와 대조적으로 사용자 계정을 나타내는 자원은 없으며 이는 API 서버를 통해 사용자를 생성, 변경, 삭제할 수 없다는 것이다. 

### 그룹
사용자와 서비스 어카운트는 하나 이상의 그룹에 속할 수 있다. 그룹은 사용자 각각 권한을 부여하지 않고 여러 사용자를 한번에 그룹화 하기 위한 용도이다.  
인증 플러그인이 반환하는 그룹은 임의의 그룹을 나타내는 문자열이지만 내장된 그룹은 특별한 의미를 가진다. 

* system:unauthenticated 그룹은 어떤 인증 플러그인에서도 클라이언트를 인증할 수 없는 요청에 사용
* system:authenticated 그룹은 성공적으로 인증된 사용자에게 자동으로 할당
* system:serviceaccounts 그룹은 시스템의 모든 서비스어카운트를 포함
* system:serviceaccounts:<namespace> 는 특정 네임스페이스에 모든 서비스 어카운트를 포함

### 12.1.2 서비스 어카운트 소개
모든 파드는 파드에서 실행중인 어플리케이션의 아이덴티티를 나타내는 서비스 어카운트와 연계되어 있다. 시크릿 볼륨으로 컨테이너 파일시스템에 마운트된 `/var/run/secrets/kubernetes.io/serviceaccount/token` 파일은 서비스 어카운트의 인증 토큰을 가지고 있다. 어플리케이션이 토큰을 사용하여 API 서버에 접속하면 인증 플러그인이 인증을 시도하고 사용자 이름을 API 서버 코어로 전달한다.  
서비스 어카운트의 형식은 다음과 같다. `system:serviceaccount:<namespace>:<service account name>`  
API 서버는 설정된 인가 플러그인에 사용자 이름을 전달하여 권한 검증을 거치게 된다. 

### 서비스 어카운트 리소스
서비스어카운트는 파드, 시크릿, 컨피그맵 등과 같은 리소스이며 개별 네임스페이스로 위치가 지정된다. 각 네임스페이스마다 default 서비스 어카운트가 자동으로 생성된다. 
```bash
$ kubectl get sa
NAME      SECRETS   AGE
default   1         66d
```
파드는 하나의 서비스와 연계되지만 여러 파드는 같은 서비스 어카운트를 사용할 수 있다. 또한 파드는 같은 네임스페이스의 서비스 어카운트만 사용가능하다. 

### 서비스어카운트가 인가와 어떻게 밀접하게 연계되어 있는지 이해
파드 매니페스트에 서비스 어카운트 이름을 지정하여 파드에 서비스 어카운트를 할당 할 수 있다. 할당하지 않을 경우 default 서비스 어카운트를 사용한다. 
파드에 서로 다른 서비스 어카운트를 할당할 경우 각 파드 별로 액세스 가능한 리소스를 제어 할 수 있다. 현재는 역할 기반 액세스 제어((RBAC) 플러그인을 대부분 사용한다. 

### 12.1.3 서비스 어카운트 생성
모든 파드에 default 서비스 어카운트를 사용하지 않는 이유는 클러스터 보안을 위해서 이다. 메타데이터를 읽을 필요가 없는 파드는 API 요청을 제한 하여야 하고 권한이 필요한 파드에게만 권할을 줄 수 있어야 한다. 

### 서비스 어카운트 생성
```bash
$ kubectl create serviceaccount foo
serviceaccount/foo created

$ kubectl describe serviceaccount foo
Name:                foo
Namespace:           default
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none> // 서비스 어카운트를 사용하는 파드에 이 필드의 값이 추가. 현재는 설정하지 않아 none이다.
Mountable secrets:   foo-token-sh8nk // 마운트 가능한 시크릿이 강제화 된 경우 이 서비스 어카운트를 사용하는 파드만 해당 시크릿을 마운트 가능
Tokens:              foo-token-sh8nk // 인증 토큰, 첫 번째 토큰이 마운드 된다.
Events:              <none>
```

사용자 정의 토큰 시크릿이 생성되어 서비스 어카운트와 연계된 것을 볼 수 있다. 

```bash
$ kubectl describe secret foo-token-sh8nk
Name:         foo-token-sh8nk
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: foo
              kubernetes.io/service-account.uid: 6a10cc2d-1e57-428c-8e93-551d0649356c

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1038 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI...
```

### 서비스어카운트의 마운트 가능한 시크릿 이해
기본적으로 파드는 원하는 모든 시크릿을 마운트 할 수 있으며 파드가 서비스 어카운트의 마운트 가능한 시크릿 목록에 있는 시크릿만 마운트 하도록 파드의 서비스 어카운트를 설정할 수 있다.  
이 기능을 사용하려면 서비스 어카운트가 다음 어노테이션을 포함하고 있어야 한다. `kubernetes.io/enforce-mountable-secret="true"` 서비스 어카운트에 이 어노테이션을 달릴 경우 이를 사용하는 모든 파드는 서비스 어카운트에 마운트 가능한 시크릿만 마운트 할 수 있다. 

### 서비스어카운트의 이미지 풀 시크릿 이해
이미지 풀 시크릿은 프라이빗 이미지 리포지터리에서 컨테이너 이미지를 가져오는 데 필요한 자격증명을 가진 시크릿이다. 
서비스어카운트를 사용하여 모든 파드에 특정 이미지 풀 시크릿을 추가하여 각 파드마다 개별적으로 추가하지 않아도 된다. 

### 12.1.4 파드에 서비스 어카운트 할당

### 사용자 정의 서비스 어카운트를 사용하는 파드 생성

```yaml
apiVersion: v1
kind: pod
metadata: 
  name: curl-custom-sa
spec:
  serviceAccountName: foo
  ...
```

```bash
$ kubectl exec -it curl-custom-sa -c main cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI...
```

## 12.2 역할 기반 액세스 제어로 클러스터 보안
RBAC는 권한이 없는 사용자가 클러스터 상태를 보거나 수정하지 못하게 막는다. 

### 12.2.1 RBAC 인가 플러그인 소개
쿠버네티스 API 서버는 REST 인터페이스를 제공하므로 사용자는 서버에 HTTP 요청을 보내 액션을 수행한다. 사용자는 요청에 자격증명을 포함 시켜 자신을 인증한다. 

### 액션 이해하기
REST 클라이언트는 get, post, put, delete등의 요청을 특정 REST 리소스를 타나내는 URL로 보낸다. 쿠버네티스에서 이러한 리소스에는 파드. 서비스, 시크릿 등이 있다. 
* 파드 가져오기 (GET)
* 서비스 생성하기 (CREATE)
* 시크릿 업데이트 (UPDATE)
* 기타
API 서버 내에서 실행되는 RBAC와 같은 인가 플러그인은 클라이언트가 요청한 자원에서 요청한 동사를 수행할 수 있는지 판별한다. 
| HTTP 메서드 | 단일 리소스에 관한 동사 | 컬렉션에 관한 동사|
|---|:---:|---:|
| GET, HEAD | get (and watch for watching) | list(and watch) |
| POST | create | n/a |
| PUT | update | n/a |
| PATCH | patch | n/a |
| DELETE | delete | deletecollection |

### RBAC 플러그인 이해 
RBAC 인가 플러그인은 사용자가 액션을 수행할 수 있는지 여부를 결정하는 핵심 요소로 사용자 롤을 사용한다. 주체는 하나 이상의 롤과 연관되어 있고 각 롤은 특정 리소스에 특정 동사를 수행할 수 있다. 
사용자에게 여러 롤이 있는 경우 롤에서 허용하는 모든 작업을 수행 할 수 있다.  
예를 들어 사용자에게 시크릿 정보를 업데이트 하는 권한이 없으면 API 서버는 시크릿 정보에 대해 PUT 또는 PATCH 요청을 수행하지 못하게 한다. 

### 12.2.2 RBAC 리소스 소개
RBAC 인가 규칙은 네 개의 리소스로 구성되며 두 개의 그룹으로 분류할 수 있다. 
* 롤과 클러스터롤: 리소스에 수행할 수 있는 동사를 지정한다. 
* 롤바인딩과 클러스터롤바인딩: 위의 롤을 특정 사용자, 그룹, 또는 서비스 어카운트에 바인딩한다. 

![role](/assets/images/post/k8s/role.png)
