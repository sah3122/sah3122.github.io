---
title: 모던 자바 인 액션 - 15장 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
description: 모던 자바 인 액션 - 15장 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
categories:
 - dev
tags:
 - java
comments: true
---
> Modern Java In Action 정리 - CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

  * Thread, Future, 자바가 풍부한 동시성 API를 제공하도록 공요하는 진화의 힘
  * 비동기 API
  * 동시 컴퓨팅의 박스와 채널 뷰
  * CompletableFuture 콤비네이터로 박스를 동적으로 연결
  * 리액티브 프로그래밍용 자바 9 플로 API의 기초를 이루는 발행 구독 프로토콜
  * 리액티브 프로그래밍과 리액티브 시스템

`모던 자바 인 액션 책을 보고 정리한 글입니다.` 

작성중인 글입니다.

## 동시성을 구현하는 자비 지원의 진화
* 처음 자바는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용하여 잠궜다, 그 후 조금더 진화된 ExecutorService 인터페이스, 높은 수준의 결과 즉 Runnable, Thread의 변형을 반환하는 Callable<T> and Future<T>, 제네릭 등을 지원했다. 
* ExecutorServices는 Runnable과 Callable 둘 다 실행 가능하다. 이런 기능들이 추가 됨에 따라 멀티코어 CPU에서 쉽게 병렬 프로그래밍을 구현할 수 있었다. 
* 자바는 Future를 조합하는 기능을 추가하며 동시성을 강화(CompletableFuture)했고, 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원.

### 스레드와 높은 수준의 추상화
* 일반적으로 프로세스는 운영체제에 한개 이상의 스레드 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 테스트클 동시에 또는 협력적으로 실행할 수 있다. 
* 이전에 스트림을 활용하여 외부 반복(명시적 루프) 대신 내부 반복을 통해 병렬 프로그래밍을 하는 방법을 배웠다. 결론적으로 병렬 스트림의 반복은 명시적인 스레드를 사용하는 것에 비해 높은 수준의 개념이라는것을 알 수 있다. 
* 정리 하자면 스트림을 활용하여 스레드 사용패턴을 **추상화** 할 수 있다. 

### Executor와 스레드 풀
* Executor 프레임 워크와 스레드 풀을 통해 스레드를 테스크 제출과 실행을 분리 할 수 있도록 구현할 수 있다. 
* 일반적으로 스레드를 생성하는 비용이 크기 때문에 일정 갯수의 스레드를 스레드 풀에 미리 생성 및 등록하여 사용한다. 
* 자바 ExecutorService는 테스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공, newFixedThreadPool과 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 생성할 수 있다.
* newFixedThreadPool는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다. 
* 프로그래머는 테스크(Runnable, Callable)를 제공하면 스레드가 이를 실행한다. 
* **스레드 풀 그리고 스레드 풀이 나쁜 이유**
* 대부분의 관점에서 스레드를 직접 사용하는것 보단 스레드 풀을 이용하는것이 바람직하지만 두가지 사항을 주의해야 한다. 
  * k 스레드를 가진 스레드 풀은 오직 k 만큼의 스레드를 동시에 실행 가능하다. 
    * 초과로 제출된 테스크는 큐에 저장되어 이전 테스크가 종료되기 전까지 대기하게 된다. 
    * 일반적인 상황에서는 불필요한 스레드를 생성하지 않기 때문에 문제되지 않지만 실행중인 테스크에서 Sleep이 걸리거나 I/O를 기다리게 되면 성능이 급혁하게 저하된다. 
    * 만약 5 개의 스레드를 갖는 스레드 풀에 20개의 테스크가 할당되고 3개의 스레드가 I/O를 기다리게 되면 결론적으로 2개의 스레드가 15개의 테스크를 처리해야 한다. 
    * 처음 제출한 테스크가 나중의 테스크의 제출을 기다리를 상황에 빠진다면 데드락에 걸릴수도 있다. 
* 프로그램을 종료하기전 모든 스레드 풀을 종료하는 습관을 가져야한다. 
  * 풀의 워커 스레드가 만들어진 다음 다른 테스크의 제출을 기다리며 종료되지 않은 상태로 남을수도 있다. 
  * 보통 장기간 실행하는 인터넷 서비스를 관리하며 오래 실행되는 ExecutorService를 갖는건 흔한일이며 자바는 이런상황을 다루도록 Thread.setDaemon 메서드를 지원한다. 