---
title: 모던 자바 인 액션 - 9장 리팩터링, 테스팅, 디버깅
description: 모던 자바 인 액션 - 9장 리팩터링, 테스팅, 디버깅
categories:
 - dev
tags:
 - java
comments: true
---
> Modern Java In Action 정리 - 리팩터링, 테스팅, 디버깅

  * 람다 표현식으로 코드 리팩터링하기
  * 람다 표현식이 객체지향 설계 패턴에 미치는 영향
  * 람다 표현식 테스팅
  * 람다 표현식과 스트림 API 사용 코드 디버깅

`모던 자바 인 액션 책을 보고 정리한 글입니다.` 

작성중인 글입니다.

## 가독성과 유연성을 개선하는 리팩토링
* 람다, 메서드 참조, 스트림 등의 기능을 이용해 가독성을 높이고 유연한 코드로 리팩토링하는것을 설명.

### 코드 가독성 개선
* 익명 클래스를 람다 표현식으로 리팩토링
* 람다 표현식을 메서드 참조로 리팩토링
* 명령형 데이터 처리를 스트림으로 리팩토링

### 익명 클래스를 람다 표현식으로 리팩토링
* 하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩토링 할 수 있다. 

```java
Runnable r1 = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello");
        }
    };
    
Runnable r2 = () -> System.out.println("Hello");
```

* 모든 익명 클래스를 람다 표현식으로 변환할 수 있는것은 아니다. 
  1. 익명 클래스에서 사용한 this, super는 람다 표현식에서 서로 다른 의미를 가지게 된다. 
  2. this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 의미하게 된다. 
  3. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴수 있다. 하지만 다음 코드에서 보여주는것 처럼 람다 표현식으로는 가릴수 없다.


```java
int a = 10;

Runnable r1 = new Runnable() {
    int a = 20;    
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

Runnable r2 = () -> {
    int a = 20; // compile error
    System.out.println("Hello");
};
```
* 익명 클래스를 람다 표현식으로 변경하면 콘텍스트 오버로딩에 따른 모호함이 초래된다. 
* 익명 클래스는 인스턴스화 할때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라지기 때문이다.


```java
interface Task {
    public void execute();
}
public static void doSomeThing(Runnable r) {
    r.run();
}

public static void doSomeThing(Task t) {
    t.execute();
}

doSomeThing(new Task() {
    public void execute() {
        System.out.println("do");
    }
});

doSomeThing(() -> System.out.println("do")); // 어떤 것이 실행되어야 하는지 알수 없다. 
doSomeThing((Task)() -> System.out.println("do")); 
```
* 익명 클래스를 람다 표현식으로 변경하는 경우 Runnable 과 Task 중 어떤 클래스를 사용해야 하는지 알수 없으므로 모호함이 발생한다. 
* 명시적 형변환을 이용해서 처리할 수 있지만 일반적으로 IDE에서 이러한 모호함을 처리해준다.