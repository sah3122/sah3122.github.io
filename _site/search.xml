<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 9장 리팩터링, 테스팅, 디버깅]]></title>
      <url>/dev/2020/10/22/modern-java06/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리 - 리팩터링, 테스팅, 디버깅  람다 표현식으로 코드 리팩터링하기  람다 표현식이 객체지향 설계 패턴에 미치는 영향  람다 표현식 테스팅  람다 표현식과 스트림 API 사용 코드 디버깅모던 자바 인 액션 책을 보고 정리한 글입니다.작성중인 글입니다.가독성과 유연성을 개선하는 리팩토링  람다, 메서드 참조, 스트림 등의 기능을 이용해 가독성을 높이고 유연한 코드로 리팩토링하는것을 설명.코드 가독성 개선  익명 클래스를 람다 표현식으로 리팩토링  람다 표현식을 메서드 참조로 리팩토링  명령형 데이터 처리를 스트림으로 리팩토링익명 클래스를 람다 표현식으로 리팩토링  하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩토링 할 수 있다.Runnable r1 = new Runnable() {        @Override        public void run() {            System.out.println("Hello");        }    };    Runnable r2 = () -&gt; System.out.println("Hello");  모든 익명 클래스를 람다 표현식으로 변환할 수 있는것은 아니다.          익명 클래스에서 사용한 this, super는 람다 표현식에서 서로 다른 의미를 가지게 된다.      this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 의미하게 된다.      익명 클래스는 감싸고 있는 클래스의 변수를 가릴수 있다. 하지만 다음 코드에서 보여주는것 처럼 람다 표현식으로는 가릴수 없다.      int a = 10;Runnable r1 = new Runnable() {    int a = 20;        @Override    public void run() {        System.out.println("Hello");    }};Runnable r2 = () -&gt; {    int a = 20; // compile error    System.out.println("Hello");};  익명 클래스를 람다 표현식으로 변경하면 콘텍스트 오버로딩에 따른 모호함이 초래된다.  익명 클래스는 인스턴스화 할때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라지기 때문이다.interface Task {    public void execute();}public static void doSomeThing(Runnable r) {    r.run();}public static void doSomeThing(Task t) {    t.execute();}doSomeThing(new Task() {    public void execute() {        System.out.println("do");    }});doSomeThing(() -&gt; System.out.println("do")); // 어떤 것이 실행되어야 하는지 알수 없다. doSomeThing((Task)() -&gt; System.out.println("do"));   익명 클래스를 람다 표현식으로 변경하는 경우 Runnable 과 Task 중 어떤 클래스를 사용해야 하는지 알수 없으므로 모호함이 발생한다.  명시적 형변환을 이용해서 처리할 수 있지만 일반적으로 IDE에서 이러한 모호함을 처리해준다.람다 표현식을 메서드 참조로 리펙토링 하기  람다 표현식을 메소드 참조로 변환하면 가독성을 높아지고 코드의 의도를 명확하게 표현할 수 있다.Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishByCaloricLevel = menu.stream()                .collect(groupingBy(dish -&gt; {                    if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;                    else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;                    else return CaloricLevel.FAT;                }));public CaloricLevel getCaloricLevel() {    if (this.calories &lt;= 400) return CaloricLevel.DIET;    else if (this.calories &lt;= 700) return CaloricLevel.NORMAL;    else return CaloricLevel.FAT;}Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishByCaloricLevel = menu.stream()                .collect(groupingBy(Dish::getCaloricLevel));  comparingBy와 mayBy 같은 정적 헬퍼 메서드를 활용하는것도 좋다.inventory.sort((Apple a1, Apple a2) -&gt; a1. getWeight().compareTo(a2.getWeight()));inventory.sort(comparing(Apple::getWeight))명령형 데이터 처리를 스트림으로 리팩토링하기List&lt;String&gt; dishNames = new ArrayList&lt;&gt;();for (Dish dish : menu) {  if (dish.getCalories() &gt; 300) {    dishNames.add(dish.getName());  }}menu.stream()  .filter(d -&gt; d.getCalories() &gt; 300)  .map(Dish::getName)  .collect(toList());코드 유연성 개선  함수형 인터페이스 적용          조건부 연기 실행 패턴      실행 어라운드 패턴        조건부 연기 실행  실제 작업을 처리하는 코드 내부에 제어 흐름문이 복잡하게 얽힌 코드를 흔히 볼 수 있다.  if (logger.isLoggable(Log.FINER)) {    logger.finer("Problem: " + generateDiagnostic());  }  위 코드는 다음과 같은 사항에 문제가 있다.          logger의 상태가 isLoggable이라는 메서드에 의해 클라이언트로 노출된다.      메시지를 로깅할 때마다 logger 객체의 상태를 매번 확인해야 할까 ?        다음처럼 메시지를 로깅하기 전에 logger 객체가 적절한 수준으로 설정되었는지 내부적으로 확인하는 log 메서드를 사용하는것이 바람직하다.  logger.log(Level.FINER, "Problem: " + generateDiagnostic());  불필요한 if 문은 사라졌지만 여전히 위 코드는 문제가 있다.          조건에 맞지 않더라도 항상 로깅 메시지를 평가하게 된다.        람다를 이용하여 이러한 문제를 해결하자. 특정 조건에서만 메시지가 생성될 수 있도록 메시지 생성 과정을 연기해야 한다.  Java 8에서는 이와 같은 문제를 해결할 수 있도록 Supplier를 제공하고 있다.public void log(Level level, Supplier&lt;String&gt; msgSupplier);logger.log(Level.FINER, () -&gt; "Problem: " + generateDiagnostic());public vodid log(Level level, Supplier&lt;String&gt; msgSupplier) {  if (logger.isLoggable(level)) {    log(level, msgSupplier.get()); //람다 실행  }}  log 메서드는 조건에 맞는 경우에만 실행되고 인수로 넘겨진 람다를 내부적으로 실행할 수 있게 변경되었다.  이러한 방법으로 객체 상태를 자주확인하는 상황이나 객체의 일부 메서드를 확인한 다음에 메서드를 호출하도록 새로운 메서드를 구현하는것이 좋다.      코드의 가독성이 좋아질 뿐만 아니라 캡슐화(객체 상태가 클라이언트로 노출되지 않는다.)가 강화 된다.    실행 어라운드  매번 같은 준비, 종료 과정을 반복적으로 수행하는 코드를 람다로 리팩토링 해보자.String oneLine = processFile((BufferedReader b) -&gt; b.readLine()); // 람다 전달String twoLine = processFile((BufferedReader b) -&gt; b.readLine() + b.readLine()); // 다른 람다 전달public static String processLine(BufferedReaderProcessor p) throws IOException {  try (BufferdReader br = new BufferedReader(new FileReader("file.txt"))) {    return p.process(br); // 인수로 전달된 BufferedReaderProcessor 실행  }}public interface BufferedReaderProcessor {  String process(BufferedReader b) throws IOException;}  람다로 BufferedReader 객체의 동작을 결정할 수 있는 것은 함수형 인터페이스 BufferedReaderProcessor 덕분이다.람다로 객체지향 디자인 패턴 리팩터링 하기  디자인 패턴에 람다 표현식이 더해지면서 색다른 기능을 발휘 하게 되었다.  즉, 람다를 이용하여 이전에 디자인 패턴으로 해결하던 문제를 더 쉽게 간단하게 해결할 수 있다.  람다 표현식으로 기존의 많은 객체지향 디자인 패턴을 제거하거나 간결하게 재 구현할 수 있다.  이절에선 다섯 가지 패턴을 살펴본다.          전략(Strategy)      템플릿 메서드(Template Method)      옵저버(Observer)      의무 체인(Chain of Responsibility)      팩토리(Factory)      전략 패턴  전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임시 적절한 알고리즘을 선택하는 기법이다.  전략 패턴은 크게 클라이언트 -&gt; 전략 -&gt; A, B (런타임시 선택) 으로 구성된다.          알고리즘을 나타내는 인터페이스 (Strategy 인터페이스)      다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현 (StrategyA, StrategyB)      전략 객체를 사용하는 한 개 이상의 클라이언트        예시로 오직 소문자 또는 숫자로 이루어져야하는 등 텍스트 입력이 다양한 조건에 맞도록 포맷되어있는지 검증하는 로직이 존재한다고 가정하자.@FunctionalInterfacepublic interface ValidationStrategy {    boolean execute(String s);}public class IsAllLowerCase implements ValidationStrategy {    @Override    public boolean execute(String s) {        return s.matches("[a-z]+");    }}public class isNumeric implements ValidationStrategy {    @Override    public boolean execute(String s) {        return s.matches("\\d+");    }}public class Validator {    private final ValidationStrategy validationStrategy;    public Validator(ValidationStrategy validationStrategy) {        this.validationStrategy = validationStrategy;    }        public boolean validate(String s) {        return validationStrategy.execute(s);    }}Validator numericValidator = new Validator(new isNumeric());numericValidator.validate("aaa");Validator lowerCaseValidator = new Validator(new IsAllLowerCase());lowerCaseValidator.validate("bbbb");  람다를 사용하지 않고 위와 같이 구현할 수 있다.  람다를 사용한 코드를 살펴보자.Validator lowerCaseValidator2 = new Validator((String s) -&gt; s.matches("[a-z]+"));lowerCaseValidator2.validate("bbbb");Validator numericValidator2 = new Validator((String s) -&gt; s.matches("\\d+"));numericValidator2.validate("1234");  ValidationStreategy는 함수형 인터페이스이며 Predicate과 같은 함수 디스크럼터를 갖고 있음을 파악했을것이다.  따라서 잔략을 구현하는 새로운 클래스를 만드는것보다 람다 표현식을 전달하여 간결하게 나타낼 수 있다.  위 코드에서 확인할 수 있듯이 람다 표현식을 전달하면 전략 패턴에서 발생하는 자잘한 코드를 제거할 수 있다.  추가적으로 람다 표현식은 전략을 캡슐화 하는 효과도 존재한다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 8장 컬렉션 API 개선]]></title>
      <url>/dev/2020/10/13/modern-java05/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리 - 컬렉션 API 개선  컬렉션 팩토리 사용하기  리스트 및 집합과 사용할 새로운 관용패턴 배우기  맵과 사용할 새로운 관용 패턴 배우기모던 자바 인 액션 책을 보고 정리한 글입니다.컬렉션 팩토리  자바 9에서는 작은 컬렉션 객체를 쉽게 만들수 있는 몇 가지 방법을 제공한다.    List&lt;String&gt; friends = new ArrayList&lt;&gt;();friends.add("Raphael");friends.add("Olivia");friends.add("Thibaut");        위처럼 세 문자열을 저장하는데 많은 코드가 소요된다 따라서 아래와 같이 사용하여 코드를 줄일 수 있다.    List&lt;String&gt; friends = Arrays.asList("Raphael", "Olivia", "Thibaut");        고정된 크기의 리스트를 만들었으니 새로운 요소를 추가하거나 요소를 삭제한다면 UnsupportedOperationException 이 발생한다. 요소를 갱신하는것은 정상적으로 작동한다.  Java 9 부터는 작은 리스트, 집합, 맵을 쉽게 만들 수 있도록 팩토리 메서드를 제공한다.리스트 팩토리  List.of 팩토리 메서드를 활용하여 간단하게 리스트를 만들수 있게 되었다.    List&lt;String&gt; friends = List.of("Raphael", "Olivia", "Thibaut");        of 메소드를 사용하더라도 요소를 추가하거나 삭제하면 여전히 UnsupportedOperationException 에러가 발생한다.  때로는 컬렉션이 의도치 않게 변경되는것을 막는것이 더 효과적일수 있다.  Arrays.asList와 of의 차이점은 가변인수를 사용하지 않는다는것이다.      static &lt;E&gt; List&lt;E&gt; of() {      return ImmutableCollections.emptyList();  }  static &lt;E&gt; List&lt;E&gt; of(E e1) {      return new List12(e1);  }  static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {      return new ListN(new Object[]{e1, e2, e3, e4, e5, e6, e7, e8, e9, e10});  }        가변인수를 사용한다면 그만큼의 배열을 리스트로 만들고 추후 객체 반환까지 해야하는 비용이 발생하지만 리스트 팩토리 메서드를 활용해 불필요한 비용을 줄일수 있게 되었다.집합 팩토리  List.of와 비슷하게 변경 불가능한 집합을 만들수 있다.    Set&lt;String&gt; friends = Set.of("Raphael", "Olivia", "Thibaut");      맵 팩토리  맵을 만드는것은 리스트나 Set을 만드는것에 비해 조금 복잡하지만 Java 9 에서 두가지 방법으로 맵을 만들수 있도록 제공하고 있다.// Key - Value 를 번갈아 가며 생성Map&lt;String, Integer&gt; friendsMap = Map.of("Raphael", 30, "Olivia", 30, "Thibaut", 30);// Map의 인수가 많을경우 entry를 활용해서 만드는것이 좋다.Map&lt;String, Integer&gt; friendsMapEntry = Map.ofEntries(entry("Raphael", 30),                entry("Olivia", 30),                entry("Thibaut", 30));리스트와 집합 처리  자바 8에서는 List, Set 인터페이스에 다음과 같은 메서드를 추가했다.  removeIf : Predicate를 만족하는 요소를 제거한다. List나 Set을 구현하거나 구현을 상속받은 클래스에서 이용할 수 있다  replaceAll : 리스트에서 이용할수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다.  sort : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.  위 메서드들은 호출한 컬렉션 자체를 변경하게 된다. 일반적으로 새로운 결과를 만드는 스트림과는 달리 기존 컬렉션에 변화를 주는 기능이 추가된 이유는 무엇일까 ?removeIffor (Transaction transaction : transactions) {  if (True) {    transactions.remove(transaction);  }}  위 코드는 ConcurrentModificationException 에러를 발생시킨다. for - each 루프는 내부적으로 iterator 객체를 사용하므로 아래와 같이 해석된다.    for (Iterator&lt;Transaction&gt; iterator = transactions.iterator(); iterator.hasNext();) {Transaction transaction = iterator.next();if (true) {  transactions.remove(transaction);}}        두 개의 개별 객체가 컬렉션을 관리하는 것에 주목.  Iterator 객체 : next(), hasNext()를 사용해 소스를 질의 한다.  Collection 객체 : remove()를 호출하여 요소를 삭제  결과적으로 반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않고 있다. 아래와 같이 Iterator 객체를 명시적으로 삭제하여 문제를 해결할 수 있다.    for (Iterator&lt;Transaction&gt; iterator = transactions.iterator(); iterator.hasNext();) {Transaction transaction = iterator.next();if (true) {  iterator.remove();}}        코드가 조금 복잡해졌지만 위 코드 패턴은 Java8의 removeIf 메서드로 변경할 수 있다. 위에서 말한것 처럼 removeIf는 Predicate를 인수로 받는다.    transactions.removeIf(transaction -&gt; true);      replaceAll 메서드  List 인터페이스의 replaceAll 메서드를 이용하여 리스트의 각 요소를 새로운 요소로 변경할 수 있다. 일반적으로 스트림 Api 를 사용한다면 아래와 같이 사용가능하다.    referenceCodes.stream()            .map(Strings::toUpperCase))            .collect(toList());        위 처럼 스트림을 활용한다면 새로운 컬렉션이 생성되고 기존 컬렉션은 변경되지 않는다. 기존 컬렉션을 변경하기 위해 아래와 같이 사용할 수 있다.    for (ListIterator&lt;String&gt; iterator = referenceCodes.listIterator(); iterator.hasNext();) {iterator.hasNext();String code = iterator.next();iterator.set(code.toUpperCase());}        코드가 복잡해지고 컬렉션 객체를 Iterator와 혼용하여 사용한다면 반복과 컬렉션 변경이 동시에 이루어 지며 쉽게 문제를 일으킨다.  Java8 에서 제공하는 기능을 사용하도록 하자    referenceCodes.replaceAll(code -&gt; code.toUpperCase());      맵 처리forEach 메서드  맵에서 Key, Value을 반복하며 확인하려면 Map.Entry&lt;K, V&gt;의 반복자를 활용해야 한다.  Java 8 부터 Map 인터페이스는 BiConsumer (Key, Value를 인수로 받는다.)를 인수로 받는 forEach 메서드가 추가되어 간편하게 구현할 수 있다.    Map&lt;String, Integer&gt; ageOfFriends = new HashMap&lt;&gt;();ageOfFriends.forEach((friend, age) -&gt; print(friend + "is" + age)))      정렬 메서드  다음 두 개의 새로운 유틸리티를 활용하여 맵의 항목을 key 또는 Value를 기준으로 정렬할 수 있다.  Entry.comparingByValue  Entry.comparingByKeyMap&lt;String, String&gt; favouriteMovies = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Cristina", "Matrix"), entry("Olivia", "James Bond"));favouriteMovies.entrySet()               .stream()               .sorted(Entry.comparingByKey());getOrDefault  기존엔 맵에 존재하지 않는 키로 값을 찾으려할때 NPE가 발생할 가능성이 있어 Null 체크가 필요했다.  현재는 getOrDefault 라는 메소드가 지원되니 안전하게 문제를 해결할 수 있습니다.Map&lt;String, String&gt; favouriteMovies = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Cristina", "Matrix"), entry("Olivia", "James Bond"));favouriteMovies.getOrDefault("Olivia", "Matrix"); // James Bond 출력favouriteMovies.getOrDefault("Thibaut", "Matrix"); // Matrix 출력  키가 존재하더라도 값이 Nulㅣ인 경우에는 여전히 Null 을 반환하게 되니 주의하자.계산 패턴  맵에 키가 존재하는지 여부에 따라 어떤 동작을 실행하고 결과를 저장해야 하는 상황이 필요할 때가 있다.  다음 세가지 메소드가 이러한 상황에서 도움이 된다.  computeIfAbsent : 제공된 키에 해당하는 값이 존재하지 않으면(값이 없거나 Null) 제공된 키로 새로운 Value를 맵에 추가한다.  computeIfPresent : 제공된 키가 존재하면 새로운 Value로 맵에 추가한다.  compute : 제공된 키로 새 Value를 추가한다.삭제 패턴  제공된 키에 해당하는 맵 항목을 제거하는 remove는 존재하지만 특정 key에 특정 value일때만 제거 할 수 있도록 오버라이드된 메소드가 존재한다.  remove(key, value);교체 패턴  맵의 항목을 변경하는데 사용할 수 있는 두 개의 메서드가 추가되었다.  replaceAll : BiFunction을 적용한 결과로 각 항목의 값을 교체한다. 이전에 알려준 List.replaceAll과 비슷한 기능이다.  replace : 키가 존재하면 맵의 값을 바꾼다. 키가 특정 값으로 매핑되었을때만 변경하도록 하는 오버로드된 버전도 있다.    Map&lt;String, String&gt; favouriteMovies = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Cristina", "Matrix"), entry("Olivia", "James Bond"));favouriteMovies.replaceAll((friend, movie) -&gt; movie.toUpperCase());      Merge  두 그룹의 연락처를 포함하는 두 맵을 합친다고 가정하자. 일반적으로 putAll을 사용할 수 있다.    Map&lt;String, String&gt; family = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Cristina", "Matrix"));Map&lt;String, String&gt; friends = Map.ofEntries(entry("Olivia", "James Bond"));Map&lt;String, String&gt; everyone = new HashMap&lt;&gt;(family);everyone.putAll(friends);        중복된 키가 존재하지 않는다면 위 코드는 정상적으로 동작할 것이다.  만약 중복된 키가 존재하고 값을 유연하게 다루기 위해 merge 메서드를 활용할 수 있다.  merge 메서드는 중복된 메서드를 어떤 방식으로 합칠지 결정하는 BiFunction 을 인수로 받는다.    Map&lt;String, String&gt; family = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Cristina", "Matrix"));Map&lt;String, String&gt; friends = Map.ofEntries(entry("Olivia", "James Bond"), entry("Cristina", "James bond"));Map&lt;String, String&gt; everyone = new HashMap&lt;&gt;(family);everyone.merge(k, v, (movie1, movie2) -&gt; movie1 + movie2));        지정된 키와 연관된 값이 없거나 값이 Null 일경우 merge는 키를 널이 아닌 값과 연결한다.  merge는 연결된 값을 주어진 매핑함수의 결과 값으로 대치하거나 결과가 Null일 경우 항목을 제거한다.ConcurrentHashMap  ConcurrentHashMap은 동시성 친화적이며 최신기술을 반영한 HashMap 버전이다.  ConcurrentHashMap은 스트림에서 봤던것과 비슷한 종류의 세 가지 연산을 지원한다.          forEach : 각 (key, value) 쌍에 주어진 액션을 실행      reduce : 모든 (key, value) 쌍을 제공된 리듀스 함수를 이용해 결과로 합침      search : 널이 아닌 값을 반환할 때 까지 각 (key, value)쌍에 함수를 적용        다음처럼 키에 함수 받기, 값, Map.Entry, (key, value)인수를 이용한 네 가지 연산 형태를 지원          key, value로 연산 (forEach, reduce, search)      key로 연산(forEachKey, reduceKeys, searchKeys)      value로 연산(forEachValue, reduceValues, searchValues)      Map.Entry 객체로 연산(forEachEntry, reduceEntries, searchEntries)        이들 연산은 ConcurrentHashMap의 상태를 잠그지 않고 연산을 수행한다는 점을 주목하자, 따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존하지 않아야 한다.  ConcurrentHashMap은 맵의 매핑 개수를 확인하는 mappingCount 메서드를 제공한다.  기존 size 메서드 대신 새 코드에서는 int를 반환하는 mappingCount 메서드를 사용하는것이 좋다.  ConcurrentHashMap을 집합 뷰로 반환한느 keySet이라는 새로운 메서드도 제공한다.  맵을 바꾸면 집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다.  newKeySet이라는 새 메서드를 이용해 ConcurrentHashMap으로 유지되는 집합을 만들 수도 있다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 7장 병렬 데이터 처리와 성능]]></title>
      <url>/dev/2020/09/28/modern-java04/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리 - 병렬 데이터 처리와 성능  병렬 스트림으로 데이터를 병렬 처리하기  병렬 스트림의 성능 분석  포크 / 조인 프레임워크  Spliterator로 스트림 데이터 쪼개기모던 자바 인 액션 책을 보고 정리한 글입니다.병렬 스트림  병렬 스트림 이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.      // 일반적인 숫자 합을 구하는 스트림  public long sequentialSum(long n) {      return Stream.iterate(1L, i -&gt; i +1)              .limit(n)              .reduce(0L, Long::sum);  }      순차 스트림을 병렬 스트림으로 변환  순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.      public long parallelSum(long n) {      return Stream.iterate(1L, i -&gt; i +1)              .limit(n)              .parallel()              .reduce(0L, Long::sum);  }        순차 스트림에 parallel을 호출한다고 스트림 자체는 영향을 받지 않는다.  내부적으로 parallel을 호출하면 병렬로 실행을 하도록 boolean 플레그가 설정된다.  반대로 sequential을 호출하여 병렬 스트림을 순차 스트림으로 변경할 수 있다. 두 메서드를 활용해 병렬 연산과 순차연산을 제어 할 수 있다.    stream.parallel()    .filter()    .sequential()    .map()    .parallel()    .reduce();        parallel과 sequential 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.위 예제에서는 마지막이 병렬이기 때문에 파이프라인은 전체적으로 병렬로 실행된다.스트림 성능 측정  병렬화를 이용하면 순차나 반복 형식에 비해 성능이 더 좋아질까 ? 성능 최적화시 항상 측정을 통해 개선 여부를 확인해야 한다.  측정 툴 로는 JMH (Java Microvenchmark Harness)를 사용하여 측정할 수 있다.  위 예제를 측정한다면 전통적인 for-loop를 사용한 결과가 가장 빠르다는걸 알수 있고 예상 외로 병렬 스트림을 활용한 결과 보다 순차 스트림을 활용한 결과가 더 빠르다는걸 알수 있다.  이러한 결과가 나온 이유로는 아래 두가지 문제점을 예상할 수 있다.          반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야한다.      반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.        두번째 문제가 중요한데 병렬 스트림을 활용하려면 그에 맞는 스트림 모델이 필요하기 때문이다.  병렬 스트림을 활용하기 위해선 청크 단위로 분리하는것이 중요한데 위 예제에서는 리듀싱 과정에서 전체 스트림이 준비되지 않아 결국 하나의 스레드에서 연산을 하게되고 스레드를 할당하는 리소스만 사용하게 된것이다.  더 특화된 메서드 사용  박싱 / 언박싱에 필요한 오버헤드를 줄이기 위해 LongStream, IntStream과 같이 기본형 특화 스트림을 사용하는 방법이 있다.  LongStream.rangeClosed 와 같이 청크로 분할 할 수 있는 숫자 범위를 제한한다면 병렬 스트림을 활용할 수 있을것 같다.  기본형 특화 스트림을 사용한다면 for-loop 보다 더 빠른 결과를 얻을수 있고 rangeClosed 와 병렬스트림을 활용한다면 더욱 빠른 실행 결과를 얻을 수 있다.병렬 스트림의 올바른 사용법  병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 변경하는 알고리즘을 사용하기 떄문에 발생.```javapublic long sideEffectSum(long n) {  Accumulator accumulator = new Accumulator();  LongStream.rangeClosed(1, n).forEach(accumulator::add);  return accumulator.total;}public class Accumulator {    public long total = 0;    public void add(long value) {        total += value;    }}* 위 코드는 본질적으로 순차 실행할 수 있도록 구현되었고, 병렬로 실행한다면 문제가 발생한다. * 특히 total에 접근할 때 마다 데이터 레이스 문제가 발생한다. (다수의 스레드에서 동시에 데이터에 접근)### 병렬 스트림을 효과적으로 사용하기* 병렬 스트림을 사용한다면 반드시 직접 측정하라.* 박싱을 주의하라. 오토 박싱 / 언박싱 과정에서 사용되는 리소스는 상상이상으로 크다. 기본형 특화 스트림을 고민하자.* 순차 스트림보다 병렬 스트림을 사용하면 성능이 떨어지는 연산이 존재한다. 특히 limit 이나 findFirst와 같이 요소의 순서에 의존하는 연산은 병렬 스트림과 적합하지 않다.    findFirst 보다 findAny를 사용하고 정렬된 스트림에 unorderd를 호출한다면 비정렬된 스트림을 얻을 수 있다.* 스트림에서 수행되는 전체 연산 비용을 고려, 처리할 요소 N 연산 비용 Q라고 가정 N * Q 에서 Q의 비용이 큰 경우 병렬 스트림을 사용한다면 성능을 개선할 가능성이 있다.* 소량의 데이터는 병렬 스트림을 사용해도 큰 이점을 얻지 못한다.* 적절한 자료구조를 사용하는지 판단하라. 예를 들면 ArrayList를 LinkedList보다 효율적으로 분할 할 수 있다. (전체 탐색을 하지 않고 리스트를 분할 할 수 있기 때문)* 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질수 있다. 예를들면 SIZED 스트림은 정확히 같은 크기의 스트림을 분할하는 반면 filter 연산이 있으면 스트림의 크기를 가늠하기 어렵다.* 최종 연산의 병합 과정 비용을 살펴보라. 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 가능성이 있다.* ArrayList, IntSream.range는 병렬 스트림을 사용하기 최적화 되어 있다.* HashSet, TreeSet은 병렬 스트림을 사용해도 좋다.* LinkedList, Stream.iterate 는 병렬스트림을 사용하면 성능이 떨어질것이다.## 포크 / 조인 프레임워크* 포크 / 조인 프레임워크는 병렬화 할 수 있는 작없을 재귀적으로 작은 작업으로 분할한 다음 서브테스크 각각의 결과를 합쳐 전체 결과를 만들도록 설계되었다.* 포크 / 조인 프레임워크에서는 서브테스크를 Thread Pool(ForkJoinPool)의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다.### RecursiveTask 활용* 스레드풀을 이용하려면 RecursiveTask&lt;R&gt;의 서브클래스를 만들어야 한다. * R은 병렬화된 테스크가 생성하는 결과 형식 또는 결과가 없을때는 RecursiveAction형식이다.* RecursiveTask를 정의 하려면 추상메서드 compute를 구현해야 한다.```javaprotected abstract R compute();  compute 메서드는 테스크를 서브 테스트로 분할하는 로직과 더이상 분할 할수 없을떄 서브테스트의 결과를 생산할 알고리즘을 정의한다.    if (서브테스트 분할불가능) {순차적으로 테스트 계산} else {서브테스크 분할 재귀 호출}        분할 정복 알고리즘의 병렬화 버전이라고 볼수 있다.포크/조인 프레임워크를 제대로 사용하는 방법  join 메서드를 테스크에 호출시 결과가 준비될때까지 호출자를 블락한다. 따라서 서브텟크가 모두 시작된 다음에 join 메서드를 실행해야 한다.  RecursiveTask 내에서는 ForkJoinPool의 invoke 메서드를 사용하지 말아야 한다. 대신 compute나 fork메서드를 직접 호출할 수 있다. 순차 코드에서 병렬 계산을 시작할떄만 invoke를 사용한다.  서브테스크에 fork메서드를 호출해 ForkJoinPool의 일정을 조절할 수 있다.  포크 / 조인 프레임워크를 이용한 병렬 계산은 디버깅이 어렵다.  병렬 스트림에서 살펴본 것처럼 멀티코어에 포크 / 조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거라는 생각은 버려야한다.작업 훔치기  포크 / 조인 프레임워크에서는 Work Stealing 이라는 기법으로 작업을 관리한다.  Work Stealing에서는 ForkJoinPool의 모든 스레드를 거의 공정하게 분배한다. 각각의 스레드는 자신에게 할당된 테스크를 포함한 이중 연결리스트를 참조하며작업이 끝날때 마다 큐의 헤드에서 작업을 가져와 처리한다.  하나의 스레드에서 모든 작업이 끝이나면 유휴 상태로 변경하기 보다는 다른 스레드의 큐의 꼬리에서 작업을 훔쳐와 실행하게 된다.Spliterator 인터페이스  자바 8부터 Spliterator 라는 인터페이스가 추가되었다. Spliterator는 분할할 수 있는 반복자란 의미이며 Iterator처럼 소스의 요소 탐색 기능을 제공하며 병렬 작업에 특화 되어 있다.  자바 8 은 컬렉션 프레임워크에 포함된 모든 자료구조에 사용할 수 있는 기본 Spliterator 구현을 제공한다.    public interface Spliterator&lt;T&gt; {boolean tryAdvance(Consumer&lt;? super T&gt; action);Spliterator&lt;T&gt; trySplit();long estimateSize();int characteristics();}        T는 Spliterator에서 탐색하는 요소의 형식을 가리킨다.  tryAdvance 메서드는 Spilterator의 요소를 하나씩 순차적으로 소비하며 탐색해야할 요소가 남아 있으면 True를 리턴한다.  trySplit 메서드는 Spliterator의 일부 요소를 분할해서 두번쨰 Spilterator를 생성하는 메서드이다.  estimateSize로 탐색해양할 요소의 갯수를 구할수 있다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[스프링 클라우드 서비스 이해 - Zuul Proxy]]></title>
      <url>/dev/spring/cloud/2020/09/12/spring-cloud-zuul/</url>
      <content type="text"><![CDATA[  Spring Cloud Zuul에 대해서 간단히 알아보자.작성중인 글입니다.Spring Cloud Zuul 이란 ?Netflix에서 개발한 MSA 환경에서 Routing 과 Filtering 을 위한 서비스 라고 이해 하면 될것 같다.Zuul을 사용하면 아래와 같은 기능들을 설정할 수 있다고 합니다.  Authentication  Insights  Stress Testing  Canary Testing  Dynamic Routing  Service Migration  Load Shedding  Security  Static Response handling  Active/Active traffic management개발환경 설정기본적으로 아래와 같은 디펜던시를 추가.dependencies {    implementation 'org.springframework.boot:spring-boot-starter-web'    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-zuul'    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'    annotationProcessor 'org.projectlombok:lombok'    testImplementation('org.springframework.boot:spring-boot-starter-test') {        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'    }}ZuulProxy를 사용한다고 선언 해주어야 한다.@SpringBootApplication@EnableZuulProxypublic class ZuulproxyApplication {    public static void main(String[] args) {        SpringApplication.run(ZuulproxyApplication.class, args);    }}Zuul Proxy 설정dean-service 경로로 들어오는 요청에 대해서 지정한 api 서버로의 routing 을 설정해보자.zuul:  routes:    dean-service:      path: /dean-service/**      url: http://localhost:8081/dean-servicepath와 같은 경우 /* 와 같이 특정 url 에 한정해서 설정하는 것 보단 /** 와 같이 계층적으로 모든 api가 매칭 될 수 있도록 설정하는것을 권장하고 있다.위 설정을 진행하고 미리 만들어둔 서버로 요청이 잘 가는지 테스트 해보자.정상적으로 routing이 되는것을 확인할 수 있습니다 :)Provider 설정Response에 대한 응답 처리를 하고 싶을때 사용. 공식 문서에 나와 있는 예제는 Timeout, Internal Server Error 가 발생하였을때 Custom 한 응답을 내려 줄 수 있도록 설정하고 있습니다.@Componentpublic class DeanServiceProvider implements FallbackProvider {    @Override    public String getRoute() {        return "dean-service";    }    @Override    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {        if (cause instanceof HystrixTimeoutException) {            return response(HttpStatus.GATEWAY_TIMEOUT);        } else {            return response(HttpStatus.INTERNAL_SERVER_ERROR);        }    }    private ClientHttpResponse response(final HttpStatus status) {        return new ClientHttpResponse() {            @Override            public HttpStatus getStatusCode() throws IOException {                return status;            }            @Override            public int getRawStatusCode() throws IOException {                return status.value();            }            @Override            public String getStatusText() throws IOException {                return status.getReasonPhrase();            }            @Override            public void close() {            }            @Override            public InputStream getBody() throws IOException {                return new ByteArrayInputStream("fallback".getBytes());            }            @Override            public HttpHeaders getHeaders() {                HttpHeaders headers = new HttpHeaders();                headers.setContentType(MediaType.APPLICATION_JSON);                return headers;            }        };    }}]]></content>
      <categories>
        
          <category> dev </category>
        
          <category> spring </category>
        
          <category> cloud </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 6장 스트림으로 데이터 수집 정리]]></title>
      <url>/dev/2020/08/31/modern-java03/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리 - 스트림으로 데이터 수집  목표      Collectors 클래스로 컬렉션을 만들고 사용하기    하나의 값으로 데이터 스트림 리듀스 하기    특별한 리듀싱 요약 연산    데이터 그룹화와 분할    자신만의 커스텀 컬렉터 개발  모던 자바 인 액션 책을 보고 정리한 글입니다.스트림으로 데이터 수집컬렉터란 무엇인가 ?  Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.    고급 리듀싱 기능을 수행하는 컬렉터    collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.구체적으로 스트림에 collect를 호출하면 스트림 요소에 내부적으로 리듀싱 연산이 수행된다. 명령형 프로그래밍에서 직접 구현해야 했던 부분들이 자동으로 수행된다는 점이다.  보통 함수를 요소로 변환(toList처럼 데이터 자체를 변환하는것보다 데이터 저장 구조를 변환하는 작업이 더 빈번하다.)할 때는 컬렉터를 적용하여 최종 결과를 특정 자료구조로 뽑아낸다.  Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공해준다.미리 정의된 컬렉터  groupingBy 와 같이 Collectors 클래스에서 제공하는 메서드의 기능을 설명한다.Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.          스트림의 요소를 하나의 값으로 리듀스 하고 요약      요소 그룹화      요소 분할      리듀싱과 요약  컬렉터 인스턴스를 활용해서 어떤 작업을 할 수 있는지 파악  예를 들면 counting() 이라는 팩토리 메서드가 환한하는 컬렉터로 다음과 같은 과정을 생략 할 수 있다.          menu.stream().collect(Collectors.counting());      menu.stream().counting();      스트림 값에서 최댓값과 최솟값 검색  메뉴에서 가장 높은 칼로리와 낮은 칼로리의 요리를 찾는다고 가정, Collectors.maxBy, Collectors.MinBy 두 개의 메서드를 활용해서 스트림의 최댓값과 최솟값을 계산할 수 있다.  두 컬렉터는 스트림의 요소를 비교하는데 사용하는 Comparator를 인수로 받는다.```javaComparator dishComparator = Comparator.comparingInt(Dish::getCalories);Optional mostCalorieDish = menu.stream()                .collect(maxBy(dishComparator));* Optional 객체로 반환된 이유를 생각해보자. 만약 menu가 비어 있다면 어떤 요리도 반환되지 않을것이기 때문에 Optional로 반환하는것이다.* 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 사용된다. 이러한 연산을 **요약**연산이라고 부른다.### 요약 연산* Collectors 클래스는 Collectors.summingInt라는 특별한 요약 팩토리 메서드를 제공한다.```java// 메뉴 리스트의 총 칼로리를 계산하는 코드Integer totalCalories = menu.stream().collect(summingInt(Dish::getCalories));  이러한 요약 연산은 내부적으로 reducing 연산이 실행되며 초깃값을 기준으로 스트림을 탐색하여 값을 더하게 된다.  Collectors.summingLong, Collectors.summingDouble 메서드는 같은 방식으로 동작하며 long, double 형으로 데이터를 요약하는것만 다르다.  컬렉터를 활용해서 최댓값, 최솟값, 합계, 평균등을 계산하는 방식을 살펴보았는데 두개 이상의 연산을 한번에 수행해야 하는 경우 summarizingInt를 사용하게 된다.    IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));// IntSummaryStatistics[count=4, sum=1200, min=100, average=200, max=300]      문자열 연결  컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출하여 추출된 문자열을 하나로 연결해 반환한다.    String shortMenu = menu.stream()              .map(Dish::getName)              .collect(joining());        joining 메서드는 내부적으로 StringBuilder를 이용해 문자열을 하나로 만든다.  Dish 클래스가 toString을 구현하였다면 아래와 같이 생략하여 정의한 toString으로 추출할 수 있다.    String shortMenu = menu.stream()              .collect(joining());        연결된 두 요소 사이에 구분 문자열을 넣거나 prefix, suffix를 넣을수도 있다.    String shortMenu = menu.stream()              .map(Dish::getName)              .collect(joining(", ", "[", "]"));      범용 리듀싱 요약 연산  컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다.    Integer total = menu.stream()              .collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j));        리듀싱 연산은 세가지 인수를 받는다.          첫번쨰 인수는 시작값이거나 스트림이 비엇을 때 반환값      변환 함수      BinaryOperator        다음 처럼 한 개의 인수를 가진 reducing 버전을 이용해 가장 칼로리가 높은 요리를 찾을 수도 있다.    Optional&lt;Dish&gt; collect1 = menu.stream()              .collect(reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));      그룹화  데이터를 하나 이상의 집합으로 분류하여 그룹화 하는것도 데이터 베이스에서 많이 사용되는 작업이다.  스트림에서 제공하는 팩토리 메서드 (Collectors.gruopingBy)를 사용하여 메뉴를 그룹화 해보자.```javaMap&lt;DishType, List&gt; dishByType = menu.stream()              .collect(groupingBy(Dish::getDishType));Map&lt;CaloricLevel, List&gt; dishByCaloricLevel = menu.stream()                .collect(groupingBy(dish -&gt; {                    if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;                    else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;                    else return CaloricLevel.FAT;                }));### 그룹화된 요소 조작* 500 칼로리가 넘는 요리들만 필터링 한다고 가정할때 아래와 같은 코드를 작성할 수 있다.```javaMap&lt;DishType, List&lt;Dish&gt;&gt; dishByType = menu.stream()                .filter(dish -&gt; dish.getCalories() &gt; 500)                .collect(groupingBy(Dish::getDishType));  위와 같이 작성시 조건에 맞는 요소가 하나도 존재하지 않을시 Map의 key가 존재 하지 않는다. 이러한 경우 아래와 같이 작성    Map&lt;DishType, List&lt;Dish&gt;&gt; dishByType = menu.stream()              .collect(groupingBy(Dish::getDishType, filtering(dish -&gt; dish.getCalories() &gt; 500, toList())));        그룹화된 항목을 조작하는 다른 유용한 기능 중 하나로 맵핑 함수를 이용해 요소를 변환하는 작업이 있다.filtering 컬렉터와 같은 이유로 Collectors 클래스는 매핑 함수와 각 항목에 적용한 함수를 모으는 데 사용하는 또 다른 컬렉터를 인수로 받는 mapping 메서드를 제공    // Name List 로 그룹화Map&lt;DishType, List&lt;String&gt;&gt; dishByName = menu.stream()              .collect(groupingBy(Dish::getDishType, mapping(Dish::getName, toList())));        컬렉터를 사용하면 일반 맵이 아닌 flatMap 변환을 수행할 수 있다.    Map&lt;String, List&lt;String&gt;&gt; dishTags = new HashMap&lt;&gt;();      dishTags.put("pork", Arrays.asList("greasy", "salty"));      Map&lt;DishType, Set&lt;String&gt;&gt; dishByDishTag = menu.stream()              .collect(groupingBy(Dish::getDishType,                      flatMapping(dish -&gt; dishTags.get(dish.getName()).stream(), toSet())));      다수준 그룹화  두 인수를 받는 팩토리 메서드 Collectors.groupingBy 를 이용해 항목을 다수준으로 그룹화 할 수 있다.  Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받는다.    Map&lt;DishType, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishTypeMapMap = menu.stream()              .collect(groupingBy(Dish::getDishType, groupingBy(dish -&gt; {                  if (dish.getCalories() &gt; 400) return CaloricLevel.DIET;                  else return CaloricLevel.FAT;              })));      서브그룹으로 데이터 수집  groupBy로 넘겨주는 컬렉터의 형식은 제한이 없다. 아래와 같이 두번째 인수로 counting 컬렉터를 전달해 메뉴에서 요리의 수를 종류별로 계산 가능하다.    Map&lt;DishType, Long&gt; dishTypeLongMap = menu.stream()              .collect(groupingBy(Dish::getDishType, counting()));        분류 함수 한개의 인수를 받는 groupingBy(f)는 groupingBy(f, toList())의 축약형이다.  가장 높은 칼로리를 가지는 메뉴도 구현 가능하다.    Map&lt;DishType, Optional&lt;Dish&gt;&gt; dishTypeOptionalMap = menu.stream()              .collect(groupingBy(Dish::getDishType, maxBy(Comparator.comparingInt(Dish::getCalories))));        팩토리 메서드 maxBy 가 생성하는 컬렉터의 형식에 따라 Optional 형식으로 바인딩 되었다. 실제 메뉴의 요리중 Optional.empty()를 값으로 가지는 메뉴는 없으나 groupingBy 컬렉터는스트림의 첫번째 요소를 찾은 이후에 그룹화 맵에 새로운 키를 추가한다. (lazy binging)  Optional로 값을 감쌀 필요가 없으므로 Optional을 삭제 할 수있다. CollectingAndThen을 활용하는 것이다.    Map&lt;DishType, Dish&gt; dishTypeDishMap = menu.stream()              .collect(groupingBy(Dish::getDishType, collectingAndThen(maxBy(Comparator.comparingInt(Dish::getCalories)), Optional::get)));        groupingBy와 함께 사용하는 다른 컬렉터 예제  일반적으로 스트림에서 같은 그룹으로 분류된 모든 요소에 리듀싱 작업을 수행할 때는 팩토리 메서드 groupingBy에 두 번째 인수로 전달한 컬렉터를 이용한다.  예를들어 모든 요리의 칼로리합을 구할때는 아래와 같이 사용한다.    Map&lt;DishType, Integer&gt; dishTypeIntegerMap = menu.stream()              .collect(groupingBy(Dish::getDishType, summingInt(Dish::getCalories)));        이 외에도 mapping 메서드로 만들어진 컬렉터도 groupingBy와 자주 사용된다.  mapping은 다양한 형식의 객체를 주어진 형식의 컬렌터에 맞게 변환하는 역할을 한다.  각 요리 형식에 존재하는 모든 CaloricLevel값을 구할때는 아래와 같이 사용한다.```javaMap&lt;DishType, Set&gt; dishTypeSetMap = menu.stream()              .collect(groupingBy(Dish::getDishType, mapping(dish -&gt; {                  if (dish.getCalories() &gt; 400) return CaloricLevel.DIET;                  else return CaloricLevel.FAT;              }, toSet())));// toCollection을 사용하면 원하는 SetCollection으로 반환할 수 있다. Map&lt;DishType, HashSet&gt; dishTypeHashSetMap = menu.stream()                .collect(groupingBy(Dish::getDishType, mapping(dish -&gt; {                    if (dish.getCalories() &gt; 400) return CaloricLevel.DIET;                    else return CaloricLevel.FAT;                }, toCollection(HashSet::new))));## 분할* 분할은 분할함수라 불리는 Predicate를 분류 함수로 사용하는 특수한 그룹화 기능이다.```javaMap&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = menu.stream()                .collect(partitioningBy(Dish::isVegetarian)); &lt;- 분할 함수// filter를 사용할 수도 있다.List&lt;Dish&gt; vegetarianDishes = menu.stream()                .filter(Dish::isVegetarian)                .collect(toList()); 분할의 장점  분할 함수를 사용하면 참, 거짓 두가지 요소의 스트림 리스트를 모두 유지할 수 있다는것이 장점이다.  컬렉터를 두번째 인수로 전달할 수 있는 오버로드된 partioningBy 메서드도 존재한다.Map&lt;Boolean, Map&lt;DishType, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = menu.stream()                .collect(partitioningBy(Dish::isVegetarian, groupingBy(Dish::getDishType)));// 채식 중 가장 높은 칼로리의 음식과 채식이 아닌 음식중 가장 높은 칼로리의 음식Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian = menu.stream()                .collect(partitioningBy(Dish::isVegetarian,                        collectingAndThen(maxBy(Comparator.comparingInt(Dish::getCalories)), Optional::get)));정리  collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법을 인수로 갖는 최종연산이다.  스트림의 요소를 하나의 값으로 리듀스 하고 요약하는 컬렉터뿐 아니라 최솟값, 최댓값, 평균값을 계산하는 컬렉터 등이 미리 정의되어 있다.  미리 정의된 컬렉터인 groupingBy로 스트림의 요소를 그룹화 하거나, partitioningBy로 스트림의 요소를 분할 할 수 있다.  컬렉터는 다수준의 그룹화, 분할, 리듀싱 연산에 적합하게 설계되어 있다.  collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉터를 개발할 수 있다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 5장 스트림 활용 정리]]></title>
      <url>/dev/2020/08/25/modern-java02/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리 - 스트림 활용모던 자바 인 액션 책을 보고 정리한 글입니다.스트림 활용  필터링          Predicate로 필터링                  스트림 인터페이스는 filter를 지원한다. filter 메서드는 Predicate(Boolean을 리턴하는 함수)를 인수로 받아 일치하는 모든 요소를 포함하는 스트림을 반환한다.          고유요소로 필터링을 하기 위해선 distinct 메소드를 사용한다. (hashcode, equals로 결정)                      스트림 슬라이싱          TakeWhile 활용 - java 9 부터 지원                  만약 필터링을 할 대상이 이미 정렬이 되어 있는 대상이라면 filter를 사용하기 보다는 takewhile을 사용하는것을 권장한다.          predicate를 만족하지 않는 첫번째 지점부터 마지막 스트림을 버린다.          takeWhile은 filter + break 라고 정의할 수있다.              // 전체 리스트 순회  List&lt;Dish&gt; filterMenu = specialMenu.stream()                            .filter(dish -&gt; dish.getCalories() &lt; 320)                            .collect(toList());          // 조건에 맞지 않으면 Stop  List&lt;Dish&gt; filterMenu = specialMenu.stream()                            .takeWhile(dish -&gt; dish.getCalories() &lt; 320)                            .collect(toList());                                          DropWhile 활용 - java 9 부터 지원                  나머지 요소를 선택하려면 DropWhile을 사용할 수 있다.          predicate를 처음으로 만족하지 지점까지의 요소를 버리는 작업을 진행.              // 처음으로 거짓이 되는 지점까지 버림.  List&lt;Dish&gt; filterMenu = specialMenu.stream()                            .dropWhile(dish -&gt; dish.getCalories() &lt; 320)                            .collect(toList());                                          스트림 축소                  스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 limit(n) 메서드를 지원한다.              // 3개 요소 반환  List&lt;Dish&gt; filterMenu = specialMenu.stream()                            .filter(dish -&gt; dish.getCalories() &lt; 320)                            .limit(3)                            .collect(toList());                                          요소 건너뛰기                  스트림은 처음 n개의 요소를 제외한 스트림을 반환하는 skip(n) 메서드를 지원한다.          n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 스트림이 반환된다.              // 처음 3개 요소 건너뛰기  List&lt;Dish&gt; filterMenu = specialMenu.stream()                            .filter(dish -&gt; dish.getCalories() &lt; 320)                            .skip(3)                            .collect(toList());                                            매핑          특정 객체에서 특정 데이터를 선택하는 작업은 데이터 처리 과정에서 자주 수행되는 연산이다.스트림 API의 map과 flatMap 메서드는 특정 데이터를 선택하는 기능을 제공한다.      스트림의 각 요소에 함수 적용하기                  스트림은 함수를 인수로 받는 map 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다.                // 요리명을 추출하는 예제    List&lt;String&gt; dishNames = menu.stream()                            .map(Dish::getName)                            .collect(toList());    // 단어 리스트의 글자수 추출    List&lt;String&gt; words = Arrays.asList("Modern", "Java", "In", "Action");    List&lt;Integer&gt; wordLengths = words.stream()          .map(String::length)          .collect(toList());    // map 을 연결하여 요리명의 글자수 추출    List&lt;String&gt; dishNames = menu.stream()                            .map(Dish::getName)                            .map(String::length)                            .collect(toList());                                                                  스트림 평면화                  이전 예제를 사용하여 리스트에서 고유문자로 이루어진 리스트를 반환 해보자.          예를들어 [“hello”, “world”] 리스트가 [“h”, “e”, “l”, “l”, “o”, “w”, “o”, “r”, “l”, “d”] 가 되도록 변경하는 것이다.              words.stream()        .map(word -&gt; word.split(""))        .distinct()        .collect(tolist())                                위와 같이 실행한다면 map의 결과값으로 Stream&lt;String[]&gt;이 될것이다. 원하는 결과는 Stream인데 어떻게 구현헤야 할지 생각 해보자.          방법을 모른다면 간단하지가 않다. flatMap은 사용해 문제를 해결할수 있다.              List&lt;String&gt; uniqueCharacters = words.stream()          .map(word -&gt; word.split("")) // 각 단어를 개별 문자를 포함하는 배열로 변환           .flatMap(Arrays::stream) // 생성된 스트림을 하나의 스트림으로 평면화          .distinct()          .collect(toList());                                flatMap은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉, map(Arrays::stream)과 달리 flatMap은 하나의 평면화된 스트림을 반환한다.요약하면 flatMap 메서드는 스트림의 각 값을 다른 스트림으로 만든 다음 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.                      검색과 매칭          특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리도 자주 사용된다.      요소 매칭                  스트림은 allMatch, anyMatch, noneMatch, findFirst, findAny등 다양한 유틸리티 메서드를 지원한다.                          Predicate가 적어도 한 요소와 일치 하는지 확인                                  boolean isMatch = menu.stream().anyMatch(Dish::isVegetarian)                                            Predicate가 모든 요소와 일치하는지 검사                                  boolean isMatch = menu.stream().allMatch(Dish::isVegetarian)                                            boolean값을 반환 하기 때문에 최종연산에 포함된다.                                NoneMatch                          noneMatch는 allMatch와 반대 연산을 수행한다. 즉. noneMatch는 주어진 predicate와 일치하는 요소가 없는지 확인한다.                                          요소 검색                  findAny 메서드는 현재 스트림에서 임의의 요소를 반환한다. findAny 메서드를 다른 스트림 연산과 연결해서 사용할 수 있다.\              // filter 와 findAny를 활용해 채식 요리를 선택하는 방법  Optional&lt;Dish&gt; dish = words.stream()          .filter(Dish::isVegetarian)          .findAny();                                Optional 이란 값의 존재 여부를 표현하는 컨테이너 클래스이다. 이전 예제에서 findAny는 아무 요소도 반환하지 않을 수 있다. NPE를 발생 시킬 수 있으므로java 8 라이브러리는 Optional을 만들었고 해당 내용은 나중에 정리 하겠습니다.          첫 번째 요소 찾기                          리스트 또는 정렬된 데이터로 부터 생성된 스트림은 논리적인 아이템 순서가 정해져 있을 수 있다. 이런 스트림에서 첫번째 요소를 찾기 위한 방법은 findFirst를 사용하는 것이다.                //  3으로 나누어 떨어지는 첫 번째 제곱근 값을 반환하는 코드.List&lt;Integer&gt; someNumbers = Arrays.asList(1, 2, 3, 4, 5);Optional&lt;Integer&gt; first = someNumbers.stream()        .map(n -&gt; n * n)        .filter(n -&gt; n % 3 == 0)        .findFirst();                                                              findAny와 findFirst는 언제 사용하나 ?                          두 개의 메서드를 모두 제공하는 이유는 병렬성 때문이다. 병렬 실행에서는 첫번째 반환 요소를 선택하기 어려우니 반환 순서가 상관이 없다면 병렬 스트림에서 제약이 적은 findAny를 주로 사용한다.                                            리듀싱          스트림의 최종연산 중 하나로 마지막 결과가 나올때까지 스트림의 모든 요소를 반복적으로 처리하는 과정      함수형 프로그래밍 언어 용어로는 이과정이 마치 종이를 작은 조각이 될때까지 반복해서 접는것과 비슷하다 하여 폴드라고 부른다.                  요소의 합                          reduce 메서드를 살펴보기 전에 for-each 루프를 이용해 리스트의 숫자 요소를 더하는 코드를 확인                  int sum = 0;  for (int x : numbers) {    sum += x;  }                                            numbers의 요소는 결과에 반복적으로 더해진다. 리스트에서 하나의 숫자가 남을 때 까지 reduce 과정을 반복한다.              파라미터                                  sum 변수의 초깃값 0                  리스트의 모든 요소를 조합하는 연산 (+)                                            reduce를 사용하면 애플리케이션의 반복된 패턴을 추상화 할 수 있다.                                  int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);                                            reduce는 두개의 인수를 갖는다.                                  초깃값 0.                  두 요소를 조합해 새로운 값을 만드는 BinaryOperator. 예제에서는 람다 표현식 (a, b) -&gt; a + b를 사용했다.                                            reduce로 다른 람다, 즉 (a, b) -&gt; a * b를 넘겨주면 모든 요소에 곱셈을 적용할 수 있다.              Java 8 에서는 Integer 클래스에 두 숫자를 더하는 정적 sum 메서드를 지원하여 아래와 같이 사용할 수 있다.                                  int sum = numbers.stream().reduce(0, Integer::sum);                                                              초깃값 없음                          초깃값을 받지 않도록 오버로드된 reduce는 결과값으로 Optional객체를 반환한다.              Optional sum = numbers.stream().reduce((a, b) -&gt; a + b);                                최대값, 최솟값                          최대값과 최솟값을 찾는 연산도 reduce를 활용하면 쉽게 할 수 있다.                                  Optional max = numbers.stream().reduce(Integer::max);                  Optional min = numbers.stream().reduce(Integer::min);                  메소드 레퍼런스 대신 람다 표현식을 사용해도 되지만 메소드 레퍼런스를 활용할 수 있으면 활용하도록 하자.                                          (x, y) -&gt; x &gt; y ? x : y;                                                                                                                기본형 특화 스트림          숫자 스트림으로 매핑                  스트림을 특화 스트림으로 사용할 땐 mapToInt, mapToDouble, mapToLong을 가장 많이 사용한다.          이들 스트림은 map과 같은 역할을 하지만 Stream 가 아닌 특화된 스트림을 반환한다.              int calories = menu.stream()                      .mapToInt(Dish::getCalories)                      .sum();                                mapToInt 메서드는 각 요리에서 모든 칼로리를(Integer)형태로 추출한 다음 IntStream을 반환 한다. 따라서 IntStream에서 제공하는 sum과 같은 메소드를 사용할 수 있다.                    객체 스트림으로 복원하기                  IntStream으로 만든 다음, 다시 Stream으로 만들기 위한 방법          IntStream과 같은 특화된 스트림은 각 스트림의 기본값들만 만들수 있다. IntStream의 map 연산은 int를 인수로 받아 int를 반환하는 람다 (IntUnaryOperator)를 인수로 받게 된다.하지만 정수가 아닌 Dish와 같은 값을 반환 하기 위해선 스트림 인터페이스에 정의된 연산을 사용해야 한다. 이런 경우 boxed 메서드를 사용할 수 있다.              IntStream intStream = menu.stream().mapToInt(Dish::getCalories);  Stream&lt;Integer&gt; stream = intStream.boxed();                                          숫자 범위                  특정 범위의 숫자를 이용하거나 정의하기 위한 메서드                          IntSteram.rangeClose(1, 100) // 1 ~ 100 의 숫자 범위를 만든다.              range()는 열려있는 연산을 하기 때문에 마지막 숫자가 범위에 포함되지 않는다.                                            스트림 만들기          값으로 스트림 만들기                  Stream.of(“Modern “, “Java”, “In”, “Action”);                    null 가능한 스트림 만들기 - Java 9부터 지원          Stream&lt;String&gt; homeValueStream = Stream.ofNullable(System.getProperty("home"));                    null이 될 수 있는 객체를 포함하는 스트림 값을 flatMap을 사용한다면 더욱 유용하게 사용할 수 있다.          Stream&lt;String&gt; values = Stream.of("config", "home", "user")                                .flatMap(key -&gt; Stream.ofNullable(System.getProperty(key)))                    배열로 스트림 만들기          int[] nubmers = {1, 2, 3, 4, 5};  int sum = Arrays.stream(numbers).sum();                    함수로 무한 스트림 만들기                  iterate 사용              Stream.iterate(0, n -&gt; n + 2)        .limit(10)        .forEach(System.out::println)                                iterate 메서드는 초깃값과 람다를 활용하여 스트림을 생성 할 수 있다. 이때 생성되는 스트림은 무한적이기 때문에 반드시 limit과 같은 메서드를 사용하여 범위를 지정해주어야 한다.          iterate는 순차적으로 실행되며 무한적으로 새엇ㅇ되는 스트림을 언바운드 스트림이라고 표현한다.          Java 9 부터는 iterate 에서 Predicate를 지원한다.              // 0 부터 시작하여 100 보다 작은 수의 스트림 생성  Stream.iterate(0, n -&gt; n &lt; 100, n -&gt; n + 2)        .forEach(System.out::println)  // 아래와 같은 방법은 사용할 수 없다. 스트림의 종료시점을 알수 없기 때문이다 .  Stream.iterate(0, n -&gt; n + 2)        .filter(n -&gt; n &lt; 100)        .forEach(System.out::println)  // 스트림 쇼트서킷을 지원하는 takeWhile을 사용하는것이 해법이다.        Stream.iterate(0, n -&gt; n + 2)        .takeWhile(n -&gt; n &lt; 100)        .forEach(System.out::println)                                      generate 사용                                  iterate와 비슷하게 generate도 요구할 때 값을 계산하는 무한 스트림을 만들 수 있다.                  iterate와 차이점은 생산된 값을 연속적으로 계산하지 않고 Supplier 를 인수로 받아 새로운 값을 생성한다.                      Stream.generate(Math::random)        .limit(5)        .forEach(System.out::println)                                                                                                                정리          스트림 API를 사용하면 복잡한 데이터 처리 질의를 할수 있다.      filter, distinct, takeWhile(java 9), skip, limit, 메서드로 스트림을 필터링 하거나 자를 수 있다.      소스가 정렬되어 있는 가정하에 takeWhile, dropWhile 메서드를 효과적으로 사용할 수있다.      map, flatMap 메서드로 스트림의 요소를 추출하거나 변환 할 수있다.      findFirst, findAny 메서드로 스트림의 요소를 검색할 수 있다.      allMatch, anyMatch, noneMatch 메서드를 이용해서 주어진 프레디케이트와 일치하는 요소를 스트림에서 검색할 수 있다.                  이들 메서드는 쇼트 서킷(short circuit)으로 결과를 찾는 즉시 반환하며, 전체 스트림을 처리하지 않는다.                    reduce 메서드로 스트림의 모든 요소를 반복 조합하며 값을 도출할 수 있다.      filter, map 등은 상태를 저장하지 않는 상태 없는 연산(stateless operation)이다. reduce 같은 연산은 값을 계산하는데 필요한 상태를 저장한다.sorted, distinct 등의 메서드는 새로운 스트림을 반환하기에 앞서 스트림의 모든 요소를 버퍼에 저장해야한다. 이런 메서드들을 stateful operation 이라고 부른다.      IntStream, LongStream, DoubleStream은 기본형 특화 스트림이다. 이들 연산은 각각의 기본형에 맞게 특화 되어 있다.      컬렉션뿐 아니라 값, 배열, 파일, iterate와 generate 같은 메서드로도 스트림을 만들 수 있다.      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[모던 자바 인 액션 - 1,2부 정리]]></title>
      <url>/dev/2020/07/16/modern-java01/</url>
      <content type="text"><![CDATA[  Modern Java In Action 정리모던 자바 인 액션 책을 보고 정리한 글입니다.람다 표현식  람다 표현식은 익명 함수의 일종이다. 이름은 없지만, 파라미터 리스트, 바디, 반환 형식을 가지며 예외를 던질 수 있다.  람다 표현식으로 간결하고 가독성 좋은 코드를 구현할 수 있다.  함수형 인터페이스는 하나의 추상 메서드만을 정의하는 인터페이스이다. @FunctionalInterface로 나타내어 둘 이상의 추상 메서드를 정의 하지 못하게 막을 수 있다.Default 메서드는 함수형 인터페이스에서도 구현이 가능하다.  함수형 인터페이스를 기대하는 곳에서만 람다 표현식을 사용할 수 있다.  람다 표현식을 이용하여 함수형 인터페이스의 추상 메서드를 즉석으로 제공할 수 있으며, 람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다.  java.util.function 패키지는 Predicate, Function&lt;T, R&gt;, Supplier, Consumer, BinaryOperator 등을 포함하여 자주 사용하는 다양한 함수형 인터페이스를 제공한다.  자바 8은 Predicate와 Function&lt;T, R&gt;같은 제네릭 함수형 인터페이스와 관련한 박싱 동작을 피할 수 있는 IntPredicate, IntToLongFunction 등과 같은 기본형 특화 인터페이스를 제공한다.  기본형 특화 인터페이스를 사용하여 불필요한 박싱, 언박싱 과정을 피할 수 있게 된다.  실행 어라운드 패턴 (자원할당, 자원 정리 등 코드 중간에 실행해야 하는 로직)을 람다와 함께 활용하여 유연성과 재사용성을 추가로 얻을 수 있다.  람다 표현식의 기대형식(type expected)를 대상형식(target type)이라고 한다.  메서드 참조를 사용하여 기존 메서드 구현을 재사용하고 가독성을 높일 수 있다.  Comparator, Predicate, Function 같은 함수형 인터페이스는 람다 표현식을 조립할 수 있는 다양한 디폴트 메서드를 제공한다.스트림  스트림이란 ?          데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소이다.      연속된 요소 : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.      소스 : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.      데이터 처리 연산 : 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원        스트림의 특징          파이프 라아닝 : 스트림연산은 일반적으로 스트림 연산끼리 연결하여 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다.그 덕분에 게으름(laziness), 쇼트서킷(short circuting)같은 최적화도 얻을 수 있다,      내부 반복 : 반복자를 이용하여 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.        정리          스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원한다.      스트림은 내부 반복을 지원한다. 내부 반복은 filter, map, sorted등의 연산으로 반복을 추상화 한다.      스트림에는 중간 연산과 최종 연산이 있다.      중간 연산은 filter와 map처럼 스트림을 반환하면서 다른 연산과 연결되는 연산이다. 중간 연산을 이용해서 파이프 라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성할 수 없다.      forEach나 count처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종연산이라 한다.      스트림의 요소는 요청할 때 게으른(lazily) 연산을 시도한다.      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Kotlin Study - 코틀린과 객체 지향 프로그래밍]]></title>
      <url>/dev/2020/07/12/kotlin-study02/</url>
      <content type="text"><![CDATA[  Kotlin Study - 코틀린과 객체 지향 프로그래밍코틀린 프로그래밍 책을 공부하며 정리한 글입니다.코틀린과 객체 지향 프로그래밍  모든 것은 객체다.  객체는 메시지를 보내고 받는 방식으로 통신한다.(객체 관점)  객체는 자신만의 메모리를 갖는다.(객체 관점)  모든 객체는 클래스의 인스턴스다.(반드시 객체여야 한다.)  클래스는 인스턴스를 위한 공유되는 행위를 갖는다.(프로그램 리스트에서 객체의 형태로)  코틀린은 위 내용을 모두 지원하며 현대적인 OOP 언어의 세 가지 기둥인 캡슐화, 상속, 다형성을 지원하고 있다.클래스  클래스는 객체 지향 프로그래밍 언어에서 핵심적인 구성요소이다. 클래스는 타입의 행위와, 데이터를 나타낸다.      class Deposit {  }        코틀린은 자바와 다르게 같은 소스 파일 안에 여러 클래스를 정의 할 수 있다. 접근 지정자를 명시하지 않는다면 public 접근지정자가 정의된다. (java는 package-private)  위 예제에서는 기본 생성자를 가지고 있다. 새로운 생성자를 정의하고 싶다면 아래와 같이 할 수 있다.      class Person constructor(val firstName: String, val lastName: String)  fun main(args: Array&lt;String&gt;) {    val person = Person("dongchul", "lee")  }        위 코드에서의 constructor 키워드는 주 생성자를 의미하게 된다. 코틀린 컴파일러는 생성자 컨텍스트를 가지고 있으며 init 블록을 활용하여 주 생성자의 한 부분으로 코드를 동작 시킬 수 있다.      class Person constructor(val firstName: String, val lastName: String?) {    init {      require(firstName.trim().length &gt; 0) {"invalid argument"}      ...    }  }        위 생성자 코드에서의 인자는 어떤 방식으로 정의 되는것인가 ? 매개변수인가 ? 그렇지 않다. 2개의 인자는 프로퍼티로 정의 된다. 자바 코드에서 예를 들면 아래와 같이 사용할 수 있게 된다.      Person person = new Person("dongchul", "lee");  System.out.print(person.getFirstName());  System.out.print(person.getLastName());        이름만 존재하고 성을 Nullable로 정의하는 생성자를 만들땐 this를 활용하여 아래와 같이 할 수 있다.      constructor(firstName: String) : this(fristName, null)        생성자 인자에 접두사로 val이나 var를 반드시 붙일 필요는 없으며 getter 메소드가 필요없는 경우에는 다음과 같이 할 수 있다.      class Person2(firstName: String, lastName: String) {    private val name: String    private val age: Int?    init {      this.name = "$firstName,$lastName"      this.age = 10    }    fun getName(): String = this.name    fun getAge(): Int? = this.age  }        첫번째와는 달리 getName, getAge 두개의 메소드를 지원하게 될것이다.접근 레벨  internal : internal은 모듈 내 어디에서든 새로운 클래스 인스턴스르 생성할 수 있음을 의미  private : private으로 설정한 클래스는 이를 정의한 파일 스코프 내부에서만 접근 가능  protected : protected 접근 레벨은 오직 서브 클래스에서만 사용할 수 있다. 파일 레벨의 타입을 선언하는 경우 protected를 사용할 수 없다.중첩 클래스class OuterClass {  class NestedClass {  }}  중첩 클래스에서도 접근 레벨을 설정할 수 있다. 중첩 클래스를 private로 설정하면 NestedClass는 OuterClass 스코프 내부에서만 생성 가능.  자바에서는 정적 클래스와 비 정적 클래스, 이렇게 두 가지 형태의 중첩 클래스를 지원한다.static 키워드를 사용해 선언한 중첩 클래스는 정적 중첩 클래스라 부르고 비 정정으로 선언한 클래스는 내부 클래스라고 부른다. 중첩 클래스는 해당 클래스를 둘러싼 클래스의 멤버로 간주한다.      class Outer {    static class StaticNestedClass {}    class Inner {}  }        코틀린에는 자바에서의 this 보다 더욱 강력한 this@label이란 표현식이 존재한다. 레이블 구조를 사용하면 this를 사용해 바깥 스코프를 참조 할 수 있게된다.      class A {    private val somefield: Int = 1    inner class B {      private val somefield: Int = 1      fun foo(s: String) {        println(this.somefield)        println(this@B.somefield)        println(this@A.somefield)      }    }  }        열거형 클래스    열거형은 클래스의 구체적인 타입으로, 주어진 enum 타입 변수는 미리 정의된 상수로 제한된다.    enum class Day {  MONDAY, TUESDAY. WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY}      정적 메소드와 컴패니언 오브젝트  코틀린은 자바와는 달리 클래스를 위한 정적 메소드를 지원하지 않는다.  코틀린에서 정적 메소드는 클래스 레벨이 아닌 패키지 레벨에 정의하는것이 바람직하다.    fun showFirst(input: String) {if (input.isEmpty()) throw IllegalArgumentException()return input.first()}        위 코드를 실행하게 되면 코틀린 컴파일러는 새로운 final 클래스를 만들게 되고 정의한 함수가 추가되어 있는것을 확인할 수있다.  코틀린은 스칼라에서 발견한 싱글톤 개념을 가지고 왔다.      object Singleton {    private var count = 0    fun doSomeThing(): Unit {      println(++count)    }  }        코틀린에서도 자바에서 호출하는 것 처럼 정적 메소드를 호출할 수 있는 방법이 있다. 이를 위해선 객체를 클래스 안에 위치 시킨 다음, 이를 컴패니언 오브젝트로 지정해야 한다.      // factory pattern   interface StudentFactory {    fun create(name: String): Student  }  class Student private constructor(val name: String) {    companion object : StudentFactory {      override fun create(name: String) : Student {        return Student(name)      }    }  }        새로운 인스턴스를 만들기 위해선 Student.create("name") 을 선언해야 한다. Student.create는 Student.Companion.create 와 같은 코드를 작성하는 축약형이다.인터페이스  인터페이스는 계약에 불과하며, 연관된 기능의 집합에 대한 정의를 가지고 있다. 자바 8 버전과 마찬가지로, 코틀린 인터페이스도 추상 메소드를 선언하는것 뿐만 아니라 메소드 구현체를 가질 수 있다.추상 클래스와는 달리, 인터페이스는 상태를 가질수는 없으나 프로퍼티를 가질수는 있다.      interface Document {    val version: Long    val size: Long    val name: String    get() = "NoNmae"          fun save(input: InputStream)    fun load(stream: OutputStream)    fun getDescription(): String { return "Document $name has $size" }  }        위 인터페이스는 프로퍼티 3개와 메소드 3개를 정의하고 있다.상속  상속은 객체지향 프로그래밍의 핵심이다. 상속은 기존 클래스를 재활용 또는 확장하여 행위를 수정한 새로운 클래스를 생성하게 해준다. 기존 클래스를 슈퍼 클래스(또는 부모 클래스)라 부르고, 생성된 새로운 클래스를 파생 클래스 라고 부른다.      enum class CardType {    VISA, MASTERCARD, AMEX  }      open class Payment(val amount: BigDecimal)   class CardPayment(amount: BigDecimal, val number: String, val expiryDate: DateTime, val type: CardType) : Payment(amount)        위 코드를 살펴보면 Payment 클래스는 open이라는 키워드로 정의하였다. open 키워드를 통하여 Payment클래스는 상속이 가능하다고 나타내고, 코틀린 설계자들은 기본적으로 클래스는 상속에 닫혀있다고 설계하였다.  CardPayment를 보면 : Payment 를 사용하였는데, 이는 Payment를 확장한 CardPayment 로 해석할 수 있다.  앞서 코드에서는 CardPayment 클래스는 주 생성자를 가지고 있다. 그러므로 Payment(amount)처럼 부모 클래스의 생성자를 호출 하였다. 만약 주 생성자가 없는 클래스에서는 어떻게 상속을 구현할까 ?      class ChequePayment : Payment {    constructor(amount: BigDeciaml, name: String) : super(amount) {      ...    }  }        주 생성자를 생성하지 않았기 때문에 두 번째 생성자 정의에서 부모 생성자를 호출 하고 있다.  하나의 클래스는 상속을 하나만 할 수 있지만 인터페이스는 여러개 구현 할 수 있다.      interface Drivable {    fun drive()  }      interface Sailable {    fun saill()  }  class AmphibiousCar(val name: String) : Drivable, Sailable {    override fun drive() {      println("")    }    override fun saill() {      println("")    }  }        추상 클래스    코틀린에서 추상 클래스를 정의하는 방법      abstract class A {    abstract fun doSomething()  }        인터페이스와는 달리 추상 클래스는 함수의 메소드를 정의하지 않는 경우 해당 함수에 추상함수로 표시해주어야 한다.  재정의 가능함 함수를 상속하고 파생 클래스에서 abstract로 표시할 수 있다.      open class AParent protected constructor() {    open fun someMethod(): Int = Random().nextInt()  }  abstract class DDerived : AParent() {    abstract override fun someMethod() : Int  }  class AlwaysOne : DDerived() {    override fun someMethod() : Int {      return 1    }  }      인터페이스 또는 추상클래스  Is - a Vs Can - Do : 파생된 클래스에 대하여 Is - a 관계가 성립될 수 없다면 추상클래스보다는 인터페이스를 사용해야 한다.인터페이스는 Can - Do 관계를 뜻한다. 각기 다른 두 객체 타입에 Can - Do 기능이 해당된다면, 인터페이스 구현으로 진행해야 한다.  코드재사용 촉진 - 정의돈 모든 메소드의 구현을 제공해야 하는 인터페이스보다 클래스를 상속하여 코드를 재사용 할 수 있다. 파생 클래스는 정의된 메소드의 일부분만 재 정의 하거나 구현하면된다.  버전관리 - 인터페이스를 사용하며 새로운 멤버가 추가되는 경우 모든 파생클래스가 새로운 구현체를 추가하도록 코드수정이 필요하다.똑같은 일이 추상클래스를 사용하는 경우에는 발생하지 않는다.다형성  캡슐화와 상속에 이어 다형성이 객체지향 프로그래밍의 세 번째 기둥으로 정의된다. 다형성은 타입 단계에서 ‘어떻게’로부터 ‘무엇’을 분리한다. 다형성이 제공하는 장점 중 하나는 코드 조직화와 가독성 향상이다. 또한 새로운 기능이 추가되는 경우 유연하게 확장할 수 있다.오버라이딩 규칙  코틀린은 자바보다 더욱 명시적인 언어이다. 각 메소드는 파생된 클래스에서 오버라이딩 될 수 있다. 코틀린에서는 함수를 재정의 하기 위해선 open이라는 키워드를 사용해야 한다. 메소드를 재정의 한다는것을 알리기 위해 override를 명시해줘야 하는것도 특징이다.      abstract class SingleEngineAirplane protected constructor() {    abstract fun fly()  }  class CesnaAirplane : SingleEngineAirplane() {    override fun fly() {      println("Flying a cesna")    }  }        메소드 앞에 final 키워드를 추가함으로써 파생 클래스에서 함수를 오버라이드 하는것을 명시적으로 막을수 있다.      class CesnaAirplane : SingleEngineAirplane() {    final override fun fly() {      println("Flying a cesna")    }  }        프로퍼티 역시 가상으로 표현할 수 있다.      open class Base {    open val property1: String      get() = "Base::value"  }  class Derived1 : Base() {    override val property1: String      get() = "Derived::value"  }  class Derived2(override val property1: String) : Base() {}      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> kotlin </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Kotlin Study - 기본기]]></title>
      <url>/dev/2020/07/09/kotlin-study01/</url>
      <content type="text"><![CDATA[  Kotlin Study - 코틀린 기본기코틀린 프로그래밍 책을 공부하며 정리한 글입니다.코틀린 기본기var와 val  코틀린에는 변수를 선언하기 위한 두가지 키워드가 존재.          var          // 생성과 동시에 초기화  var name = "kotlin"        // 생성 후 초기화  var name: String  name = "kotlin"        // var로 선언한 변수는 값을 변경할 수 있다.  var name = "dobby"  name = "dongchul"                    val                  읽기 전용 변수를 선언하기 위해선 val 키워드 사용, 자바에서 final 변수를 선언하는것과 같다.          생성과 동시에 초기화를 해줘야한다.          읽기 전용 변수는 인스턴스 자신이 불변이 되는것을 의미하지 않음. 재할당을 막는 키워드 (java도 동일하다.)            val name = "kotlin"                                          타입 추론  위 예제에서 변수를 초기화 시 타입을 포함하지 않을것을 확인할 수 있다. 이는 변수를 선언하는 과정에서 타입 추론을 통하여 적절한 타입을 찾아주기 때문이다.이같은 기능은 java에서도 11 버전이상 지원 된다.  값과 변수만 타입추론을 사용하지 않고 타입추론은 함수 시그니처로 매개변수 타입을 추론하는 클로저에서도 사용한다.      fun plusOne(x: Int) = x + 1        때로는 :을 이용하여 명시적으로 선언하는것이 도움이 된다.      val explicitType: Number = 12.3      기본 타입  자바와 코틀린 간의 큰 차이점은 코틀린은 모든 것이 객체라는 것이다. 다시 말하여 코틀린에서는 자바에서 지원하는 원시타입 (boolean, int)이 존재하지 않는다.코틀린은 원시타입을 모두 객체로 승격시킴으로써 언어에서 래퍼 객체의 필요성을 전부 제거 했다.  코틀린 컴파일러는 성능을 이유로 기본 타입을 가능하면 JVM 원시 타입으로 다시 매핑하려 한다. 때로는 값이 박싱되어야 하는데(Nullable, Generic) 이러한 타입은 객체를 요구하는 곳에 자동으로 위치하게 된다.          박싱된 각기 다른 두 값은 같은 인스턴스를 사용하지 않기 때문에, 박싱된 값에 대하여는 참조 동등성을 보장하지 않는다.        숫자            타입      길이                  Long      64              Int      32              Short      16              Byte      8              Double      64              Float      32        // 정수 기본값  val int = 123  val long = 123456L  // 부동소수점 기본값  val double = 12,34  val float = 12.34F  val hexadeciaml = 0xAB  val binary = 0b010101  코틀린은 자동으로 숫자를 확장하지 않기 때문에 반드시 명시적인 확장이 필요하다.      val int = 123  val long = int.toLong()      Boolean  불리언은 좀더 표중화 되어 있고, 부저으 논리곱, 논리합 연산자를 지원.문자  char 는 단일 문자를 나타낸다. 문자 리터럴은 ‘A’, ‘Z’처럼 단일 따옴표 사용.문자열  문자열은 자바와 마찬가지로 불변이다. 문자열 리터럴은 이중 또는 삼중 따옴표를 사용하여 생성한다.  이중 따옴표를 사용하면 이스케이프된 문자열을 생성      val string = "string with \n new line"        삼중 따옴표는 원시 문자열을 생성, 원시 문자열에서는 이스케이프가 필요하지 않고, 모든 문자를 포함한다.      var rawString = """  raw string is super useful for strings that span many lines"""        또한 문자열은 for 루프에서 사용가능한 이터레이터 함수를 제공배열  코틀린에서는 라이브러리 함수인 arrayOf()를 사용하여 배열을 생성할 수 있다.      var array = arrayOf(1, 2, 3)        다른 방법으론 초기 크기와 각 요소를 생성하는 데 사용되는 함수로 부터 배열을 생성할 수 있다.      var perfectSquares = Array(10) {k -&gt; k * k}  // 0, 1, 4, 9 ...        자바와는 다르게 코틀린은 언어차원에서 배열이 특별하진 않다, 배열은 일반적인 컬렉션 클래스일 뿐이다. 배열의 인스턴스는 이터레이터와 get, set함수를 지원하며 괄호 문법도 지원한다.  코틀린 JVM에선 원시타입으로 표현될 박싱타입을 피하고자 원시타입에 특화된 배열 클래스를 제공한다.          ByteArray, CharArray, ShortArray, IntArray, LongArray, BooleanArray, FloatArray, DoubleArray 지원      패키지  패키지는 네임스페이스 단위로 코드를 나눌 수 있게 해준다.      package me.study.kt  class Foo  fun bar(): String = "bar"        패키지명은 클래스, 객체, 인터페이스 또는 함수에 대한 정규화된 이름을 제공하기 위하여 사용  위 예제에서 Foo클래스는 me.study.kt.Foo라는 정규화된 이름을 가지며, 최상위 함수인 bar는 me.study.kt.bar라는 정규화된 이름을 가진다.임포트명 변경  다른 패키지에서 동일한 이름의 클래스를 사용한다면 alias를 설정할 수 있다.      import me.study.kt.Foo  import me.study.java.Foo as JavaFoo  fun doubleFoo() {    val foo = Foo()    val javaFoo = JavaFoo()  }      문자열 템플릿  코틀린은 문자열 합치기도 사용가능하지만 많은 언어에서 지원하고 있는 문자열 템플릿 기능을 지원한다.  값이나 변수에 접두사로 $를 사용하여 간단하게 추가할 수 있다.      val name = "Sam"  val str = "hello $name"        임의의 표현식 같은 경우 접두사로 $를 추가하고 괄호 {}로 식을 감싸는 방법으로 추가할 수 있다.      val name = "Sam"  val str = "hello $name. Your name has ${name.length} characters"      범위  범위는 시작하는 값과 끝나는 값의 사이의 간격으로 정의, 비교가능한 타입은 범위를 생성할 수 있으며 .. 연산자를 사용해 생성  생성한 범위는 in 연산자를 사용하여 검사, 범위의 포함되기 위해선 시작값이 값이 크거나 같고, 끝나는 값보다 작거나 같아야 한다.      val aToz = "a" .. "z"  val isTrue = "c" in aToz  val oneToNine = 1 .. 9  val isFalse = 11 in oneToNine        정수형 범위(int, long, char)역시 for루프에서 사용할 수 있다.  연산자로 처리할 수 없는 범위를 생성하기 위한 라이브러리 함수도 존재, 예를들면 downTo(0)는 숫자를 하나씩 내리는 순으로 범위 생성하고rangeTo()는 하나씩 숫자를 올리는 순으로 범위 생성한다. 두 함수 모두 숫자 타입에 확장 함수형태로 정의되어 있다.      val countingDown = 100.downTo(0)  val rangeTo = 10.rangeTo(20)        범위를 생성하고 나면 새로운 범위를 반환할 수 있다. step()함수를 사용하여 범위에 있는 연속적인 항의 델타 값을 변경할 수 있다.      val oneToFifty = 1..50  val oddNumbers = oneToFifty.step(2)        step() 함수에 음수 값을 사용해 숫자가 감소하는 범위를 만드는건 불가. 마지막으로 reversed()함수를 사용하면 범위를 반전시킬 수 있다.reversed() 함수는 시작값과 끝나는 값이 바뀐 새로운 범위를 리턴하며 단계값은 갑소하는 값이 된다.      val countingDownEvenNumbers = (2..100).step(2).reversed()      루프  코틀린은 여러 언어에서 볼 수 있는 일반적인 루프 구조인 while 루프와 for 루프를 지원한다. while 루프의 경우 다른 언어에서의 사용법과 동일하다.  코틀린의 for 루프는 이터레이터라는 이름의 함수나 확장 함수를 정의한 객체를 반복하는데 사용된다. 모든 컬렉션은 이 함수를 제공한다.      val list = listOf(1, 2, 3, 4)  for (k in list) {    println(l)  }  val set = setOf(1, 2, 3, 4)  for (k in set) {    println(k)  }        in 연산자는 항상 for 루프와 함께 사용된다. 연속적인 범위는 컬렉션을 지원하는 것뿐만 아니라 인라인 또는 바깥에서 정의하는것도 직접 지원한다.      val oneToTen = 1..10  for (k in oneToTen) {    for (j in 1..5) {      println(k * j)    }  }              컴파일러는 범위를 특별한 방법으로 처리하며, JVM에서 직접 지원하는 인덱스 기반 for루프로 컴파일 한다. 이로 인해 이터레이터 객체를 생성함으로써 발생하는 성능상의 불이익을 피할 수 있다.        객체를 for 루프에서 사용하기 위하여 iterator라 불리는 함수를 구현해야 한다. 이 함수는 다음 두 함수를 제공하는 객체의 인스턴스를 반환해야 한다.          operator fun hasNext(): boolean      operator fun next(): T        코틀린은 표준 String 클래스도 iterator 확장 함수를 제공하기 때문에 for 루프에서 사용할 수 있다.  배열은 indices라는 확장 함수를 갖고 있으며, 이 함수는 배열의 인덱스를 반복하는데 사용할 수 있다.      for (index in array.indices) {    println("Element $index is ${array[index]})  }              컴파일러는 배열에 대하여도 범위 루프와 마찬가지로 성능상의 불이익을 피하고자 배열을 일반적인 인덱스 기반의 for 루프로 컴파일한다.      예외 처리  코틀린에서 모든 예외는 Unchekced Exception이다.          CheckedException_UncheckedException        예외를 처리할 때는 자바와 마찬가지로 try, catch, finally 블록을 사용할 수 있다.클래스 인스턴스화  코틀린에선 객체를 생성할 때 new 키워드를 사용하지 않는다.      val file = File("/etc/nginx/nginx.conf")  val date = Bigdecimal(100)      참조 동등성과 구조 동등성  두 객체가 메모리상에서 동일한 객체를 가리키고 있는 경우 -&gt; 참조 동등성          두 참조가 같은 인스턴스를 확인하기 위해선 === 연산자를 사용한다.        메모리상에서 두 객체는 다른 객체이지만 서로 같은 값을 가지고 있는 경우 -&gt; 구조 동등성          두 객체가 같은 값을 사용하기 위하연 == 연산자를 사용한다.      이러한 함수 호출은 모든 클래스가 반드시 정의해놓고 있는 equals 함수를 사용하는 것으로 전환된다. 이는 자바에서 == 연산자가 사용되는 방법과는 다름을 명심해야한다.자바에서 == 연산자는 참조 동등성을 의미하며 이는 일반적으로 피해야하는 사항이다.      가시성 제어자 (접근 제어자)  가시성 제어자는 public, internal, protected, private 네가지가 있다. 제어자를 입력하지 않는다면 기본값은 public 제어자이다. 자바의 경우 기본값은 package-private 이다.  private          private로 정의한 최상위 함수, 클래스 또는 인터페이스는 오직 같은 파일에서만 접근할 수 있다.      클래스, 인터페이스 또는 객체 내부에 있는 private 함수나 프로퍼티는 오직 같은 클래스나 인터페이스 또는 객체의 다른 멤버로만 접근할 수 있다.        protected          최상위 함수, 클래스, 인터페이스 그리고 객체는 protected로 선언할 수 없다. 클래스나 인터페이스 내부에서 protected로 선언한 함수나 프로퍼티는 해당 클래스 또는 인터페이스뿐만 아니라 서브클래스 멤버까지만 접근 가능.        internal          internal은 모듈 개념을 다룬다. maven이나 gradle 또는 intellij 모듈로 정의된다.      internal로 정의한 코드는 같은 모듈에 있는 다른 클래스나 함수에서 접근 가능. internal은 전체에서 public처럼 동작하기 보단 모듈에서의 public 개념이다.        internal class Person {  fun age(): Int = 21}                    표현식으로서의 흐름 제어  표현식은 값을 평가하는 구문이다. 다음 표현식은 true를 평가한다.      "hello".startWith("h")        구문은 결과 값을 반환하지는 않는다.      //값을 대입은 하지만 반환하지는 않는 코드  val a = 1        자바에서의 if - else나 try - catch 와 같은 흐름 제어 블록은 구문이다. 이러한 구문은 값을 평가하지 않고 외부에서 변수를 초기화 해주어야 한다.      public boolean isZero(int x) {    boolean zero;    if (x == 0)       isZero = true;    else       isZero = false;    return isZero;  }        반면 코틀린에서의 if - else나 try - catch 흐름 제어 블록은 표현식이다. 결과값을 직접 대입할 수 있고, 함수로부터 반환 할수도 다른 함수에 인자로 전달할 수 있다.      val date = Date()  val today = if (date.year == 2016) true else false  fun isZero(x: Int): Boolean {    return if (x == 0) true else false  }  val success = try {    readFile()    true  } catch (e: IOException) {    false  }              if를 표현식으로 사용할 경우에는 반드시 else를 포함하여야 한다. 그렇지 않으면 컴파일 에러가 발생할 것이다.      널 문법  코틀린에서는 널을 지정할 수 있는 변수를 ?와 함께 선언할 것을 요구한다.      var str: String? = null        타입 확인과 형변환          is 연산자를 사용하여 타입을 확인한다. is 연산자는 자바의 instanceOf 연산자와 같은 기능을 함          fun isString(any: Any): Boolean {    return if (any is String) true else false  }                똑똑한 형변환              자바에서의 형변환은 명시적으로 수행해야 한다.      public void printStringLength(Object obj) {    if (obj instanceOf String) {      String str = (String) obj;      System.out.print(str.length());    }  }        코틀린 컴파일러는 Smart cast를 통하여 암시적으로 타입을 형변환 하게 된다.      fun printStringLength(any: Any) {    if (any is String) {      println(any.length)    }  }      명시적 형변환  명시적으로 타입을 변환 하기 위해선 as 연산자를 사용한다. 형변환을 하지 못하는 경우 ClassCastException을 발생      fun length(any: Any): Int {    val string = any as String    return string.length  }        Null이 가능한 값으로 형 변환을 하기 위해선 Null을 허용하는 변수로 선언해주어야 한다.      val string: String? = any as String        형변환이 실패한 경우 널 값을 대신 전달 받고 싶으면 안전한 형변환 연산자인 as? 를 사용할 수 있다.      val any = "/home/users"  val string: String? = any as? String // string  val file: File? = any as? File // null        when 표현식    when 에서는 마지막 분기가 else가 되도록 강제한다.    fun whatNumber(x: Int) {  when (x) {    0 -&gt; println("x is zero")    1 -&gt; println("x is 1")    else -&gt; println("x is neither 0 nor 1")  }}        if … else 및 try … catch와 마찬가지로 when도 표현식으로 사용될 수 있다.      fun isMinOrMax(x: Int): Boolean {    val isZero = when (x) {      Int.MIN_VALUE -&gt; true      Int.MAX_VALUE -&gt; true      1,2 -&gt; true // 분기가 같은 경우 콤마를 사용하여 묶을 수 있다.       else -&gt; false    }    return isZero  }        when은 각 조건에 상수만 매치하도록 제한하지 않는다. 반환하는 타입이 매치하는 타입과 같으면 어떤 함수든 사용 가능하다.      fun isAbs(x: Int): Boolean {    return when (x) {      Math.abs(x) -&gt; true      else -&gt; false    }  }        when은 범위 연산자 역시 지원한다. in 연산자를 사용해 값이 범위 안에 포함되어 있는지를 확인할 수 있으며, 만약 포함되어 있다면 해당 조건은 true로 평가된다.      fun isSingleDigit(x: Int): Boolean {    return when (x) {      in -9..9 -&gt; true      else -&gt; false    }  }  fun isDieNumber(x: Int): Boolean {     return when (x) {       in listOf(1, 2, 3, 4, 5, 6) -&gt; true       else -&gt; false     }  }  fun startsWithFoo(any: Any): Boolean {    return when (any) {      is String -&gt; any.startWith("Foo")      else -&gt; false    }  }        인자가 없는 when은 if … else 절을 대체하게 된다.      fun whenWithourArgs(x: Int, y: Int) {    when {      x &lt; y -&gt; println("x is less than y")      x &gt; y -&gt; println("x is greater than y")      else -&gt; println("x must equal y")    }  }      타입 체게  코틀린에선 최상위 타입을 Any라고 부른다. 이는 자바의 오브젝트 타입과 유사하다.  Any 타입은 toString, hashCode, equals 메소드를 정의하고 있다. 또한 apply, let, to와 같은 확장 함수도 정의하고 있다.  Unit 타입은 자바의 void 와 유사하다. 유닛은 싱글톤 인스턴스와 함께 적절한 타입 Unit이나 ()로 나타낸다. 함수가 유닛을 반환하도록 정의되어 있다면, 이 함수는 싱글톤 유닛 인스턴스를 반환할것이다.  Nothing은 값을 지니지 않는 타입이다. Any가 모든 타입의 슈퍼클래스이고 Nothing은 모든 타입의 서브클래스이다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> kotlin </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Azure API Management Service 활용법]]></title>
      <url>/dev/2020/06/17/azure-api-managerment-service/</url>
      <content type="text"><![CDATA[  Azure API Management Service를 사용한 API 응답 캐싱Azure API Management Service 캐싱을 활용한 글로벌 서비스 성능 최적화 방법을 간단하게 공유드립니다. 해당 방식은 정적인 응답을 반환하는 경우에 사용할 수 있으며 실시간으로 응답이 변경되거나 조건에 따라 다른 응답을 반환하는 경우에는 목적에 맞지 않을수 있습니다.API Management Service란 ?APIM(API Management)은 기존 백 엔드 서비스를 위해 일관된 최신 API 게이트웨이를 빠르게 만드는 방법입니다.API Management를 사용하여 조직은 외부, 파트너 및 내부의 개발자에게 API를 게시하여 데이터 및 서비스의 잠재성을 활용할 수 있습니다. 모든 곳의 비즈니스는 디지털 플랫폼으로 운영을 확장함으로써 새로운 채널을 생성하고, 새로운 고객을 찾고, 기존 고객과 더 깊은 관계를 구축하고자 합니다. API Management는 개발자 참여, 비즈니스 통찰력, 분석, 보안과 보호 등을 통해 성공적인 API 프로그램을 보장하는 핵심적인 역량을 제공합니다. Azure API Management를 통해 원하는 백 엔드를 사용하고 해당 백 엔드에 따라 모든 기능을 갖춘 API 프로그램을 시작할 수 있습니다.API 게이트웨이 는 다음 작업을 수행하는 엔드포인트입니다.  API 호출 수락 후 백 엔드로 라우팅합니다.  API 키, JWT 토큰, 인증서 및 기타 자격 증명을 확인합니다.  사용 할당량 및 속도 제한을 적용합니다.  코드 수정 없이 즉석에서 API를 변환합니다.  설정된 위치에 백 엔드 응답을 캐시합니다.  분석용으로 호출 메타데이터를 기록합니다.공식 문서에 따르면 위와 같은 기능들을 제공하는 서비스라고 설명되어 있습니다. 위 기능을 포함하여 많은 기능들을 제공하니 공식 문서를 확인해주시길 바랍니다.API 호출 수락 후 백 엔드로 라우팅, 설정된 위치에 백 엔드 응답을 캐시 두가지 기능을 사용하여 기존에 사용되고 있던 API를 글로벌 환경에서 효율적으로 서비스 하기 위해 테스트를 진행 하였습니다.사용 배경현재 사용하고 있는 API서버는 홍콩 리전에 배포되어 있으며 미국 버지니아 기준 간단한 GET 요청을 보낼 시 약 1초 정도의 응답시간이 소요되고 있었습니다. 트래픽이 많은 서비스는 아니지만 페이지 접근 시 1초 이상의 응답시간이 걸리는 API를 개선하고 준비하고 있는 이벤트 서비스를 사용자 친화적으로 제공하기 위하여 응답시간을 줄이기 위한 작업을 시작하였습니다.설정      API Management 서비스를 생성합니다.이때 주의 할 점은 다수의 Location 설정을 위하여 프리미엄 이상의 서비스를 선택해야 합니다.         API 연동API Management 서비스가 활성화 되면 연동할 API의 정보를 추가해줘야 합니다.OpenAPI 등록서비스를 사용하여 추가할 수 있습니다.  OpenAPI Spec에 맞춘 json파일을 업로드 하여 API Gateway와 연동합니다.json파일은 Swagger2.0 기반 api 문서를 그대로 사용할 수 있게 되어있습니다.정상적으로 API연동을 마치면 위와 같이 API목록을 확인 할 수 있습니다.  캐시 설정 및 지역 추가API 요청시 응답값을 캐싱하여 빠르게 응답을 전달해주기 위하여 적절한 캐시 설정이 필요합니다. 공식 문서에서 제공하고 있는 캐시 설정을 적용해보았습니다.Azure API Management에서 캐싱을 추가하여 성능 향상 | Microsoft Docs 문서를 참고하여 미국 지역에 새로운 API GW를 추가를 끝으로 캐싱을 위한 설정은 끝이 납니다.Azure API Management 서비스를 여러 Azure 지역에 배포 - Azure API Management | Microsoft Docs테스트API GW와 캐싱을 사용하여 어느 정도의 성능 향상이 있었는지 정리한 결과입니다. 테스트는 AWS EC2(버지니아)에서 진행하였습니다.기존 API 요청 응답시간  0.961115  0.929669  0.920897  0.912583  0.921966API GW 요청 응답시간  0.058033  0.059246  0.065591  0.057714  0.057355결과와 같이 대략 15배 이상 응답시간이 단축된것을 확인할 수 있습니다.위 설정만으로 완전한 최적화가 이루어지지는 않겠지만 글로벌 서비스를 운영하는 경우 API GW를 사용한 캐싱은성능 최적화를 위하여 고려해볼 가치가 있는것 같습니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> azure </tag>
        
          <tag> cloud </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[스프링 부트 정리]]></title>
      <url>/dev/2020/06/09/spring-boot/</url>
      <content type="text"><![CDATA[  백기선님 강의 스프링 부트 개념과 활용 정리 노트강의 내용을 다시한번 복습하기 위하여 정리합니다.스프링 부트란 독립적이며, 프로덕션 레벨의 스프링 기반 어플리케이션을 간편하게 만들수 있게 도와주는 툴입니다.스프링 부트 원리  의존성 관리 이해          스프링 부트에서는 자동으로 의존성을 관리 해준다.      일반적으로 spring-boot-stater-parent에 정의되어 있는 라이브러리는 버전을 명시하지 않아도 현재 사용하는 스프링 부트 버전에 맞게 자동으로 버전을 찾아 적용한다.      parent에 등록되지 않은 라이브러리를 사용할 때는 버전을 명시해줘야 한다.      특정 버전을 사용하고 싶을땐 버전을 명시한게 우선순위를 가지게 된다.        의존성 관리 응용          의존성 추가                  스프링 부트가 관리 해주지않는 라이브러리는 버전을 명시해주는것이 좋다.                    의존성 변경                  스프링 부트가 관리해주는 버전도 변경 할 수 있다.                      자동 설정 이해          @EnableAutoConfiguration (@SpringBootApplication 안에 포함되어 있다.)                  autoconfiguration 으로 등록된 bean 은 component scan으로 등록하는 bean을 덮어 쓴다.          ConditionalOnMissingBean - 빈이 등록 되어 있지 않을때 빈 등록함.          component scan -&gt; autoConfiguration 순으로                    Spring Bean은 사실 두 단계로 나눠서 생성된다.                  1단계 : @ComponentScan          2단계 : @EnableAutoConfiguration                    @ComponentScan                  @Component          @Configuration @Repository @Service @Controller @RestController                    EnableAutoConfiguration                  spring.factories                          org.springframework.boot.autoconfigure.EnableAutoConfiguration                                @Configuration          @ConditionalOnXxxYyyZzz                    @SpringBootApplication 은 아래 3가지 애노테이션을 포함 하고 있다.                  @SpringBootConfiguration          @EnableAutoConfiguration          @ComponentScan                      내장 서블릿 컨테이너          스프링 부트는 서버가 아니다      포트 설정 가능      톰캣에 컨텍스트 추가      서블릿 만들기      톰캣에 서블릿 추가      컨텍스트에 서블릿 매핑      톰캣 실행 및 대기      이 모든 과정을 보다 상세히, 유연하게 설정하고 실행해주는게 바로 스프링 부트의 자동설정                  Step 1 : ServletWebServerFactoryAutoConfiguration (서블릿 웹 서버 생성)                          TomcatServletWebServerFactoryCustomizer (서버 커스터마이징)                                Step 2 : DispatcherServletAutoConfiguration                          서블릿 만들고 등록                                            내장 웹 서버 응용 1부 : 컨테이너와 서버 포트          다른 서블릿 컨테이너로 변경                  boot-starter에 포함된 tomcat 의존성 제외          undertow, jetty … 의존성 추가                    웹 서버 사용하지 않기                  properties에 application-type 추가                    포트 변경        내장 웹 서버 응용 2부 : https 와 http2          HTTPS 설정하기                  키스토어 만들기                          https://gist.github.com/keesun/f93f0b83d7232137283450e08a53c4fd                                HTTP는 사용못함 ?                          기본적으로 http 커넥터는 1개라 https설정을 하게 되면 http를 사용하지 못한다.              Connector를 따로 등록 해 주어야 한다.```java  /**                                  https와 http를 사용하기 위해 connector 등록.  *  */  @Bean  public ServletWebServerFactory serverFactory() {  TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();  tomcat.addAdditionalTomcatConnectors(createStandardConnector());  return tomcat;  }                                private Connector createStandardConnector() {      Connector connector = new Connector(“org.apache/.coyote.http11.Http11NioProtocol”);      connector.setPort(8080);      return createStandardConnector();  }```                                                        HTTP2                  SSL은 기본적으로 적용되어 있어야 함          undertow는 별다른 설정 없이 properties로 설정 가능          tomcat은 8.5 버전 이하에선 설정할 것들이 많아 권장하지 않음          tomcat 9 &amp; java 9 이상부터 사용 권장                    톰캣 HTTP2                  JDK9와 Tomcat 9+ cncjs          링크 참조                          링크                                          독립적으로 실행 가능한 JAR                  mvn package -&gt; 독립적으로 실행 가능한 JAR 파일 하나가 생성됨          spring-maven-plugin이 해주는 일 (패키징)          과거 “uber” jar 사용                          모든 클래스 (의존성 및 애플리케이션)을 하나로 압축하는 방법              뭐가 어디에서 온건지 알 수 없음                                  무슨 라이브러리를 사용한건지                                            내용은 다르지만 이름이 같은 파일이 또 어떻게 ?                                스프링 부트의 전략                          내장 JAR : 기본적으로 자바에는 내장 JAR를 로딩하는 표준적인 방법이 없음              애플리케이션 클래스와 라이브러리 위치 구분              org.springframework.boot.loader.jar.JarFile을 사용해서 내장 JAR 를 읽는다.              org.springframework.boot.loader.Launcher를 사용해서 실행한다.                                          스프링 부트 활용  스프링 부트 활용 소개          스프링 부트 핵심 기능                  SpringApplication          외부 설정          프로파일          로깅          테스트          Spring-Dev-Tools                    각종 기술 연동                  스프링 웹 MVC          스프링 데이터          스프링 시큐리티          REST API 클라이언트          …                      SpringApplication          기본 로그 레벨 : INFO      FailureAnalyzer      배너                  banner.txt | gif | jpg          classpath 또는 spring.banner.location          ${spring-booot.version} 등의 변수를 사용할 수 있음          Banner 클래스를 구현 후 SpringApplication.setBanner() 등으로 설정 가능                    SpringApplicationBuilder로 빌터 패턴 사용 가능.          //SpringApplication.run(SpringBootGetStartApplication.class, args);  new SpringApplicationBuilder()          .sources(SpringBootGetStartApplication.class)          .run(args);                    ApplicationEvent 등록                  ApplicationContext를 만들기 전에 사용하는 리스너는 Bean을 등록할 수 없다.                          SpringApplication.addListeners()                  // applicationStartingEvent 는 application context 생성 전에 발생하기 때문에 이렇게 등록 해줘야 한다,  SpringApplication app = new SpringApplication(SpringBootGetStartApplication.class);  app.addListeners(new SampleListener());  @Component  public class SampleListener implements ApplicationListener&lt;ApplicationStartedEvent&gt; {      @Override      public void onApplicationEvent(ApplicationStartedEvent ApplicationStartedEvent) {          System.out.println("Application is Startied");      }  }  @Component  public class SampleListener implements ApplicationListener&lt;ApplicationStartingEvent&gt;       @Override      public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {          System.out.println("Application is Starting");      }  }                                                                        WebApplication Type 설정                  WebApplicationType                          NONE : 서블릿과 Webflux가 없을때              SERVLET : Servlet              REACTIVE : WebFlux                SpringApplication app = new SpringApplication(SpringBootGetStartApplication.class);app.setWebApplicationType(WebApplicationType.NONE);app.run(args);                                                                        애플리케이션 아규먼트 사용하기                  -D는 JVM 옵션          –Application Arguments          ApplicationArguments를 빈으로 등록해주니깐 가져다 사용하면 된다.                    애플리케이션 실행한 뒤 뭔가 다른 작업을 하고 싶을 경우                  ApplicationRunner(추천) 또는 CommandLineRunner          순서 지정 기능 @Order                      외부 설정          properties      yaml      환경 변수      커맨드 라인 아규먼트      프로퍼티 우선순위                  유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties          테스트에 있는 @TestPropertySource                          @TestPropertySource(locations = “classpath:/test.properties”)                                @SpringBootTest 애노테이션의 properties 애트리뷰트                          @SpringBootTest(properties = “dongchul.name=dong2”)                                커맨드 라인 아규먼트          SPRING_APPLICATION_JSON (환경 변수 또는 시스템 프로티) 에 들어있는 프로퍼티          ServletConfig 파라미터          ServletContext 파라미터          java:comp/env JNDI 애트리뷰트          System.getProperties() 자바 시스템 프로퍼티          OS 환경 변수          RandomValuePropertySource          JAR 밖에 있는 특정 프로파일용 application properties          JAR 안에 있는 특정 프로파일용 application properties          JAR 밖에 있는 application properties          JAR 안에 있는 application properties          @PropertySource          기본 프로퍼티 (SpringApplication.setDefaultProperties)                    application.properties 우선순위                  file:./config/          file:./          classpath:/config/          classpath:/                    랜덤 값 설정하기                  ${random.*}                    플레이스 홀더                  name = dongchul          fullName = ${name} lee                    타입 - 세이프 프로퍼티 @ConfigurationProperties          @Component  @ConfigurationProperties("dongchul")  @Validated // 프로퍼티 값을 검증 하기 위해 사용  public class DonghculProperties {      @NotEmpty      private String name;      @Size(min = 0,max = 100)      private int age;      private String fullName;      ...  }                          여러 프로퍼티를 묶어서 읽어올 수 있음.          빈으로 등록해서 다른 빈에 주입 할 수 있음                          @EnableConfigurtionProperties              @Component              @Bean                                융통성 있는 바인딩                          context-path (kebab)              context_path (under score)              contextPath (camel)              CONTEXTPATH                                프로퍼티 타입 컨버전                          @DurationUnit                                프로퍼티 값 검증                          @Validated              JSR-303(@NotNull, …)                                메타 정보 생성          @Value                          SpEL을 사용할수 있지만 위 기능들을 전부 사용하지 못한다.                                            프로파일          @Profile 애노테이션은 어디에서 사용하는가 ?                  @Configuration          @Component                    어떤 프로파일을 활성화 할 것인가 ?                  spring.profiles.active                    어떤 프로파일을 추가할 것인가 ?                  spring.profiles.include                    프로파일용 프로퍼티                  application-{profile}.properties / yml                      로깅          로깅 퍼사드 vs 로거                  Commons Logging, SLF4j          JUL, Log4J2, LogBack                    스프링 5에 로거 관련 변경 사항                  https://docs.spring.io/spring/docs/5.0.0.RC3/spring-framework-reference/overview.html#overview-logging          Spring-JCL                          Commons Logging -&gt; SLF4j or Log4j2                                          스프링 부트 로깅                  기본 포멧          –debug (일부 핵심 라이브러리만 디버깅 모드 설정)          –trace (전부 다 디버깅 모드 설정)          컬러 출력 : spring.output.ansi.enabled          파일 출력 : logging.file 또는 logging.path          로그 레벨 조정 : logging.level.패키지 = 로그레벨                    커스텀 로그 설정 파일 사용하기                  https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html          Logback : logback-spring.xml (추천, logback.xml보다 더 많은 기능을 사용할 수 있다.)              &lt;?xml version="1.0" encoding="UTF-8"?&gt;  &lt;configuration&gt;      &lt;include resource="org/springframework/boot/logging/logback/base.xml"/&gt;      &lt;logger name="me.study" level="DEBUG"/&gt;  &lt;/configuration&gt;                                Log4J2 : log4j2-spring.xml          JUL (비추) : logging.properties          Logback extention                          프로파일 &lt;springProfile name="프로파일"&gt;              Environment 프로퍼티 &lt;springProperty&gt;                                          로거를 Log4j2로 변경하기                  https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html#howto-configure-log4j-for-logging                      테스트          시작은 spring-boot-starter-test를 추가하는것 부터                  test scope로 추가                    @SpringBootTest - 통합 테스트용                  @RunWith(SpringRunner.class)랑 같이 써야함 - (Junit5 부터는 생략 가능하다.)          빈 설정 파일은 설정을 안해주나 ? 알아서 찾는다. (@SpringBootApplication)          WebEnvironment                          MOCK : mock servlet environment : 내장 톰캣 구동 안함.              RANDOM_PORT, DEFINED_PORT : 내장 톰캣 사용 함              NONE : 서블릿 환경 제공 안함                                          @MockBean                  ApplicaionContext에 들어있는 빈을 Mock으로 만든 객체로 교체 함          모든 @Test 마다 자동으로 리셋                    슬라이스 테스트                  레이어 별로 잘라서 테스트하고 싶을떄          @JsonTest          @WebMvcTest          @WebFluxTest          @DataJpaTest          …                    테스트 유틸                  OutputCapture (log 및 stdout 관련 테스트)          TestPropertyValues          TestRestTemplate          ConfigFileApplicationContextInitailizer                        /**  *  * @SpringBootTest  * 통합 테스트용  *  * @WebMvcTest(SampleContorller.class)  * 슬라이싱 테스트용  * 선언한 Controller 관련된 Bean 만 생성 하기 때문에  * Service ,Repository 같은 Bean 들은 모킹 해야 한다.  */  @RunWith(SpringRunner.class)  //@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK) // 기본값  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) // 실제로 서버가 구동됨. rest template 로 확인 해야함.  @AutoConfigureMockMvc // mock mvc를 사용 하기 위함  public class SampleControllerTest {      // async client test for webflux      // webflux의존성을 가지고 있어야 사용 가능.      @Autowired      WebTestClient webTestClient;      @Autowired      MockMvc mockMvc;      @Autowired      TestRestTemplate testRestTemplate;      @MockBean //컨트롤러 테스트를 위해 모킹.      SampleService mockSampleService;      @Test      public void hello() throws Exception {          // sample service 를 mocking          when(mockSampleService.getName()).thenReturn("dongchul");          mockMvc.perform(get("/hello"))                  .andExpect(status().isOk())                  .andExpect(content().string("hello dongchul"))                  .andDo(print());          String result = testRestTemplate.getForObject("/hello", String.class);          assertEquals(result, "hello dongchul");          webTestClient.get().uri("/hello")                  .exchange()                  .expectStatus()                  .isOk()                  .expectBody(String.class)                  .isEqualTo("hello dongchul");      }  }        Spring Boot Devtools          캐시 설정을 개발 환경에 맞게 변경.      클래스패스에 있는 파일이 변경 될 때 마다 자동으로 재시작.                  직접 껐다 켜는것(cold starts) 보다 빠르다.          릴로딩 보다는 느리다. (JRebel같은게 아님)          리스타트 하고 싶지 않은 리소스는 ? spring.devtools.restart.exclude          리스타트 기능 끄려면 ? spring.devtools.restart.enabled = false                    라이브 릴로드 ? 리스타트 했을 때 브라우저 자동 리프레시 하는 기능                  브라우저 플러그인 설치해야 함          라이브 릴로드 서버 끄려면 ? spring.devtools.liveload.enabled = false                    글로벌 설정                  ~/.spring-boot-devtools.properties                    리모트 애플리케이션        스프링 웹 MVC          레퍼런스      스프링 부트 MVC                  자동 설정으로 제공하는 여러 기본 기능(앞으로 살펴볼 예정)                    스프링 MVC 확장                  @Configuration + WebMvcConfigurer                    스프링 MVC 재정의                  @Configuration + @EnableWebMvc                    HttpMessageConverters                  HTTP 요청 본문을 객체로 변경하거나, 객체를 HTTP 응답 본문으로 변경 할 때 사용                          {“username”:”dongchul”, “password”:”123”} &lt;-&gt; User                  @PostMapping("/user")  public User create(@RequestBody User user) {      return user;  }                                                              스프링 부트                          뷰 리졸버 설정 제공              HttpMessageConvertersAutoConfiguration                                          정적 리소스 매핑 “/**”                  기본 리소스 위치                          classpath:/static              classpath:/public              classpath:/resources/              classpath:/META-INF/resources              예) “/hello.html” =&gt; static/hello.html              spring.mvc.static-path-pattern: 매핑 설정 변경 가능              spring.mvc-static-locations: 리소스 찾을 위치 변경 가능                                Last-Modified 헤더를 보고 304 응답을 보냄          ResourceHttpRequestHandler가 처리                          WebMvcConfigurer의 addResourceHandlers로 커스터마이징 가능                                          웹 JAR 맵핑 “/webjars/*”                  버전 생략 하고 사용하려면 webjars-locator-core 의존성 추가                    웰컴 페이지                  index.html 찾아보고 있으면 제공          index.템플릿 찾아보고 있으면 제공          둘다 없으면 에러페이지 노출                    파비콘                  favicon.ico 파일을 static 폴더 하위에 제공          파비콘 만들기 파비콘                    템플릿 엔진                  스프링 부트가 자동설정을 지원하는 템플릿 엔진                          FreeMarker              Groovy              Thymeleaf              Mustache                                JSP를 권장하지 않는 이유                          JAR 패키징 할 때는 동작하지 않고 WAR 패키징 해야함.              Undertow는 JSP를 지원하지 않음.                                Thymeleaf 사용하기                          https://www.thymeleaf.org              https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html              의존성 추가 : spring-boot-starter-thymeleaf              템플릿 파일 위치 : /src/main/resources/template              예제 : https://github.com/thymeleaf/thymeleafexamples-stsm/blob/3.0-master/src/main/webapp/WEB-INF/templates/seedstartermng.html                                          HTML 템블릿 뷰 테스트를 보다 전문적으로 하자.                  http://htmlunit.sourceforge.net/          http://htmlunit.sourceforge.net/gettingStarted.html          의존성 추가          @Autowired WebClient                    ExceptionHandler                  스프링 @MVC 예외 처리 방법                          @ControllerAdvice              @ExceptionHanlder                  @ExceptionHandler(SampleException.class)  public @ResponseBody AppError sampleError(SampleException e) {      AppError appError = new AppError();      appError.setMessage("error.app.key");      appError.setReason("IDK");      return appError;  }                                                              스프링 부트가 제공하는 기본 예외 처리기                          BasicErrorController                                  HTML 과 JSON 응답 지원                                            커스터마이징 방법                                  ErrorController 구현                                                              커스텀 에러 페이지                          상태 코드 값에 따라 에러 페이지 보여주기              src/main/resources/static/error/              404.html              5xx.html              ErrorViewResolver 구현                                          Spring HATEOASHypermedia As The Engine Of Application State                  서버 : 현재 리소스와 연관된 링크 정보를 클라이언트에게 제공한다.          클라이언트 : 연관된 링크 정보를 바탕으로 리소스에 접근한다.          연관된 링크 정보                          Relation              Hypertext Reference                                spring-boot-starter-hateoas 의존성 추가          https://spring.io/understanding/HATEOAS          https://spring.io/guides/gs/rest-hateoas/          https://docs.spring.io/spring-hateoas/docs/current/reference/html/          ObjectMapper 제공                          커스터마이징                                  property에 spring.jackson.* 값 변환하는 방식 추천                                            Jackson2ObjectMapperBuilder                                LinkDiscovers 제공                                          클라이언트 쪽에서 링크 정보를 Rel 이름으로 찾을 때 사용할 수 있는 XPath 확장 클래스```javapublic class Hello extends RepresentationModel {  private String prefix;                private String name;  …}                                      public Hello hello() {    Hello hello = new Hello();    hello.setName(“dongchul”);    hello.setPrefix(“Hey, “);            hello.add(linkTo(SampleController.class).withSelfRel());return hello; } ```                                          CORS                  SOP와 CORS                          Single-Origin Policy              Cross-Origin Resource Sharing              Origin ?                                  URI 스키마 (http, https)                  hostname (localhost…)                  포트 (8080, 18080)                                                              스프링 MVC @CrossOrigin                          https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web.html#mvc-cors              @Controller나 @RequestMapping에 추가 하거나                  @CrossOrigin(origins = "http://localhost:18080")  @GetMapping("/hello")  public Hello hello() {      Hello hello = new Hello();  }                                            WebMvcConfigurer 사용해서 글로벌 설정                  @Override  public void addCorsMappings(CorsRegistry registry) {      registry.addMapping("/**")              .allowedOrigins("htt://localhost:18080");  }                                                                          스프링 데이터          인메모리 데이터베이스                  지원하는 인-메모리 데이터베이스                          H2 (추천, 콘솔때문에)              HSQL              Derby                                Spring-JDBC가 클래스패스에 있으면 자동 설정이 필요한 빈을 설정 해준다.                          DataSource              JdbcTemplate                                인-메모리 데이터베이스 기본 연결 정보 확인 하는 방법                          URL : “testdb”              username : “sa”              password : “”                                H2 콘솔 사용하는 방법                          spring-boot-devtools를 추가 하거나              spring.h2.console.enabled=true 추가              /h2-console로 접속 (path변경 가능)                                          MySQL                  지원하는 DBCP                          HikariCP (기본)                                  https://github.com/brettwooldridge/HikariCP#frequently-used                                            Tomcat CP              Commonc DBCP2                                DBCP 설정                          spring.datasource.hikari.*              spring.datasource.tomcat.*              spring.datasource.dbcp2.*                                MySQL 라이센스 (GPL) 주의                          MySQL 대신 MariaDB 사용 검토              소스 코드 공개 의무 여부 확인                                MySQL 접속시 에러                          MySQL 5.* 최신 버전 사용할 때 문제                                  Sat Jul 21 11:17:59 PDT 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.                                            해결                                  jdbc:mysql:/localhost:3306/springboot?useSSL=false                                            MySQL 8.* 최신 버전 사용할 때 문제                                  com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed                                            해결                                  jdbc:mysql:/localhost:3306/springboot?useSSL=false&amp;allowPublicKeyRetrieval=true                                                                        PostgreSQL                  Mysql 과는 달리 라이센스 문제가 없다. 가장 추천하는 DB                    Spring-Data-JPA                  ORM(Object-Relational Mapping)과 JPA (Java Persistence API)                          객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크              http://hibernate.org/what-is-an-orm              JPA: ORM을 위한 자바(EE) 표준                                스프링 데이터 JPA                          Repository 빈 자동 생성              쿼리 메소드 자동 구현              @EnableJpaRepositories (스프링 부트가 자동으로 설정 해줌.)                                스프링 데이터 JPA 사용하기                          @Entity 클래스 만들기              Repository 만들기                                스프링 데이터 리파지토리 테스트 만들기                          H2 DB를 테스트 의존성에 추가하기              @DataJpaTest (슬라이스 테스트) 작성                                  테스트를 실행할 때는 Inmemory DB를 사용하는것을 추천.                    @RunWith(SpringRunner.class)@DataJpaTest // 슬라이싱 테스트 DataSource, JdbcTemplate, Repository 등을 주입 받는다. 인메모리 데이터 베이스가 반드시 필요함public class AccountRepositoryTest {    @Autowired    DataSource dataSource;    @Autowired    JdbcTemplate jdbcTemplate;    @Autowired    AccountRepository accountRepository;    ...}                                                                                                    JPA를 사용한 데이터베이스 초기화                          spring.jpa.hibernate.dll.auto                                  create                  create-drop                  update                  validate                                            spring.jpa.generate-dll=true로 설정 해줘야 한다.                                SQL 스크립트를 사용한 데이터베이스 초기화                          schema.sql 또는 schema-${platform}.sql              data.sql 또는 data-${platform}.sql              ${platform} 값은 spring.datasource.platform으로 설정 가능.                                데이터베이스 마이그레이션 툴                          Flyway 와 Liquibase가 대표적, Flyway 사용              https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/#howto-execute-flyway-database-migrations-on-startup              의존성 추가                                  org.flywaydb:flyway-core                                            마이그레이션 디렉토리                                  /resource/db/migration 또는 db/migration/{vendor}                  spring.flyway.location으로 변경 가능                                            마이그레이션 파일 이름                                  한번 적용이 된 파일은 절대 수정하면 안되고 새로운 파일을 만들어서 버전을 올려야 한다.                  V숫자__이름.sql                  V는 꼭 대문자                  숫자는 순차적으로 (타임스템프 권장)                  숫자와 이름 사이에 언더바 두개                  이름은 가능한 서술적으로                                                              Redis                          캐시, 메시지 브로커, 키/벨류 스토어 등으로 사용 가능              의존성 추가                                  spring-boot-starter-data-redis                                            스프링 데이터 Redis                                  https://projects.spring.io/spring-data-redis/                  StringRedisTemplate 또는 RedisTemplate                  extends CrudRepository                                            Redis 주요 커맨드                                  https://redis.io/commands                  keys *                  get {key}                  hgetall {key}                  hget {key} {column}                                            커스터마이징                                  spring.redis.*                                                              MongoDB                          스프링 데이터 몽고 DB                                  Mongotemplate                  MongoRepository                  내장형 MongoDB (테스트용)                                          de.flapdoodle.embed:de.flapdoodle.embed.mongo                                                        @DataMongoTest                                                              Neo4J                          Neo4j는 노드간의 연관 관계를 영속화 하는데 유리한 그래프 데이터베이스              스프링 데이터 Neo4J                                  Neo4jTemplate (Deprecated)                  SessionFactory                  Neo4jRepository                                                                        스프링 시큐리티                  웹 시큐리티          메소드 시큐리티          다양한 인증 방법 지원                          LDAP, 폼 인증, Basic 인증, OAuth, …                                스프링 부트 시큐리티 자동 설정                          SecurityAutoConfiguration              UserDetailServiceAutoConfiguration              spring-boot-starter-secutiry                                  스프링 시큐리티 5.* 의존성 추가                                            모든 요청에 인증이 필요함              기본 사용자 생성                                  Username : user                  Password : 애플리케이션을 실행 할 때 마다 랜덤 값 생성 (콘솔 출력)                  spring.security.user.name                  spring.security.user.password                                            인증 관련 각종 이벤트 발생                                  DefaultAuthenticationEventPublisher 빈 등록                  다양한 인증 에러 핸들러 등록 가능                                                              UserDetailsService 구현                          https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc-authentication-userdetailsservice              UserDetails 를 구현한 기본 구현체(User)를 Spring Security에서 제공해준다.                @Servicepublic class SecutiryAccountService implements UserDetailsService {    @Autowired    private PasswordEncoder passwordEncoder;    @Autowired    private SecurityAccountRepository securityAccountRepository;    public SecurityAccount createAccount(String username, String password) {        SecurityAccount securityAccount = new SecurityAccount();        securityAccount.setUsername(username);        securityAccount.setPassword(passwordEncoder.encode(password));        return securityAccountRepository.save(securityAccount);    }    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        Optional&lt;SecurityAccount&gt; byUserName = securityAccountRepository.findByUserName(username);        SecurityAccount securityAccount = byUserName.orElseThrow(() -&gt; new UsernameNotFoundException(username));        return new User(securityAccount.getUsername(), securityAccount.getPassword(), authorites()); // UserDetails 를 구현한 기본 구현체를 Spring Security에서 제공해준다.    }    private Collection&lt;? extends GrantedAuthority&gt; authorites() {        return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));    }}                                                              PasswordEncoder 설정 및 사용                          https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#core-services-password-encoding                // Noop : 사용해서는 안되는 방법. 아무 인코딩 / 디코딩을 하지 않는 방법@Beanpublic PasswordEncoder passwordEncoder() {    //return NoOpPasswordEncoder.getInstance();    return PasswordEncoderFactories.createDelegatingPasswordEncoder();}                                                                          RestTemplate 과 WebClient          RestTemplate                  Blocking I/O 기반의 Synchronous API          RestTemplateAutoConfiguration          프로젝트에 spring-web 모듈이 있다면 RestTemplateBuilder를 빈으로 등록해준다.          https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#rest-client-access          기본적으로 java.net.HttpURLConnection 사용          커스터마이징                          로컬 커스터마이징              글로벌 커스터마이징                                  RestTemplateCustomizer                  빈 재정의                                                                        WebClient                  Non-Blocking I/O 기반의 Asynchronous API          WebClientAutoConfiguration          프로젝트에 spring-webflux 모듈이 있다면 WebClient.Builder를 빈으로 등록해준다.          https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client          기본적으로 Reactor Netty의 HTTP 클라이언트 사용          커스터마이징                          로컬 커스터마이징              글로벌 커스터마이징                                  WebClientCustomizer                  빈 재정의                    @Componentpublic class RestRunner implements ApplicationRunner {@AutowiredRestTemplateBuilder restTemplateBuilder;@AutowiredWebClient.Builder builder;@Overridepublic void run(ApplicationArguments args) throws Exception {    RestTemplate restTemplate = restTemplateBuilder.build();    WebClient webClient = builder.build();    StopWatch stopWatch = new StopWatch();    stopWatch.start();    String helloResult = restTemplate.getForObject("http://localhost:8080/hello", String.class);    System.out.println(helloResult);    String worldResult = restTemplate.getForObject("http://localhost:8080/world", String.class);    System.out.println(worldResult);    Mono&lt;String&gt; helloMono = webClient.get().uri("http://localhost:8080/hello")            .retrieve()            .bodyToMono(String.class);    //subscribe 시 실제로 요청을 보내게 되며 non blocking 으로 동작 한다.    helloMono.subscribe(s -&gt; {        System.out.println(s);        if(stopWatch.isRunning())            stopWatch.stop();        System.out.println(stopWatch.prettyPrint());        stopWatch.start();    });    Mono&lt;String&gt; worldMono = webClient.get().uri("http://localhost:8080/world")            .retrieve()            .bodyToMono(String.class);    worldMono.subscribe(s -&gt; {        System.out.println(s);        if(stopWatch.isRunning())            stopWatch.stop();        System.out.println(stopWatch.prettyPrint());        stopWatch.start();    });    stopWatch.stop();    System.out.println(stopWatch.prettyPrint());}}                                                                                                                스프링 부트 운영          스프링 부트 Actuator                  의존성                          spring-boot-starter-actuator                                애플리케이션의 각종 정보를 확인 할 수 있는 Endpoints                          다양한 Endpoints 제공              JMX 또는 HTTP를 통해 접근 가능 함              shutdown을 제외한 모든 Endpoint는 기본적으로 활성화 상태              활성화 옵션 조정                                  management.endpoints.enabled-by-default=false                  management.endpoint.info.enabled=true                                                              JConsole 사용하기                          https://docs.oracle.com/javase/tutorial/jmx/mbeans/              https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html                                VisualVM 사용하기                          https://visualvm.github.io/download.html              java 10이상은 포함되어 있지 않다.              jconsole보다 확인하기 편하다                                HTTP 사용하기                          /acturator              health와 info를 제외한 대부분의 Endpoint가 기본적으로 비공개 상태              공개 옵션 조정                                  management.endpoints.web.expose.include=*                  management.endpoints.web.expose.exclude=env,beans                                                              스프링 부트 어드민                          https://github.com/codecentric/spring-boot-admin 스프링 부트 Actuator UI 제공              어드민 서버 설정                                  @EnableAdminServer                  spring-boot-admin-starter-server 의존성 필요                                            클라이언트 설정                                  spring-boot-admin-starter-client 의존성 필요                  spring.boot.admin.client.url=http://localhost:8080(어드민 서버 주소)                  management.endpoints.web.exposure.include=*                                            운영중에도 로그 레벨 변경 가능              스프링 시큐리티를 반드시 설정 해야 한다.                                          ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[스프링 프레임워크 핵심 정리]]></title>
      <url>/dev/2020/06/05/spring-framework/</url>
      <content type="text"><![CDATA[  백기선님 강의 스프링프레임워크 핵심 기술 정리 노트강의 내용을 다시한번 복습하기 위하여 정리합니다.IoC 컨테이너스프링 IoC 컨테이너와 빈Inverse of Controll : 의존 관계 주입(Dependency Injection)이라고 하며 어떤 객체가 사용하는 의존객체를 직접 생성하지 않고외부로부터 주입 받아 사용하는 방법의존 관계 주입에 대한 장점을 더 알아보시려면 Open Close Principal에 대하여 공부해보시는 것을 추천 드립니다.  스프링 IoC 컨테이너          BeanFactory : 스프링 빈 컨테이너에 접근하기 위한 최상위 인터페이스      애플리케이션 컴포넌트의 중앙 저장소      빈 설정소스로 부터 빈 정의, 빈을 구성하고 제공하는 역할을 한다.        Bean이란 ?          스프링 IoC 컨테이너가 관리하는 객체      장점                  의존성 관리          스코프                          싱글톤 : 흔히 알고 있는 싱글톤 패턴과 같이 하나만 생성              프로포토 타입 : 빈이 생성될 때 마다 매번 다른 객체를 생성하는 방법                @Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)                                                                          ApplicationContext          BeanFactory를 상속받고, 스프링에서 제공하는 다양한 기능을 사용할 수 있는 인터페이스        public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,    MessageSource, ApplicationEventPublisher, ResourcePatternResolver                    메시지 소스 처리 (i18n)      이벤트 발생 기능      리소스 로딩 기능      …      ApplicationContext와 다양한 빈 설정 방법  스프링 IOC 컨테이너의 역할          빈 인스턴스 생성      의존 관계 설정      빈 제공        ApplicationContext          ClassPathXmlApplicationContext : Class Path에 정의되어 있는 파일을 읽어 빈을 생성      AnnotationConfigApplicationContext : Annotation 기반 빈 생성        빈 설정          빈 명세서      빈에 대한 정의를 담고 있다.                  이름          클래스          스코프          생성자 (Constructor)          프로퍼트 (Setter)                      컴포넌트 스캔          설정 방법                  XML - context:component-scan          java - @ComponentScan                    특정 패키지 이하의 모든 클래스 중 @Component 애노테이션을 사용한 클래스를 빈으로 등록      @Autowire필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다.  @Autowired          required : 기본값이 true 이기 때문에 어플리케이션 구동 시 주입할 빈을 찾지 못하면 어플리케이션이 실행되지 않는다.        현재는 @Autowired를 통한 빈 주입방식 보다는 생성자를 사용한 빈 주입 방식을 사용해야한다.  사용 할 수 있는 위치          생성자 (스프링 4.3 부터는 생략 가능)      세터, 필드        경우의 수          해당 타입의 빈이 없는 경우 - 실패      해당 타입의 빈이 한 개인 경우      해당 타입의 빈이 여러 개인 경우                  빈 이름으로 시도                          같은 이름의 빈을 찾으면 해당 빈 사용                                  같은 이름을 못 찾으면 실패                                                              @Primary          해당 타입의 빈을 모두 주입          @Qualifier (빈 이름으로 주입)                    동작 원리                  BeanPostProcessor                          빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스              postProcessAfterInitialization, postProcessBeforeInitialization 인터페이스를 제공한다.                                AutowiredAnnotationBeanPostProcessor                          BeanPostProcessor를 구현한 클래스 이며 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기.              that autowires annotated fields, setter methods, and arbitrary config methods                                          @Component와 컴포넌트 스캔  컴포넌트 스캔의 주요 기능          스캔 위치 설정      필터 : 어떤 애노테이션들을 스캔할지 또는 하지 않을지        @Component 종류          @Repository      @Service      @Controller      @Configuration                  tmi : Repository나 Service같은 애노테이션 이름은 에릭 에반스의 DDD에서 유래되었다고 적혀있다.                      동작원리          @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보      실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨.      빈 스코프  Scope          Singleton - 기본      ProtoType - 모든 요청에서 새로운 Bean을 생성한다.                  Request          Sesseion          WebSocket          …                    https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html        프로토 타입 빈이 싱글톤 빈을 참조 하면 ?          정상 실행        싱글톤 빈이 프로토 타입 빈을 참조하면 ?          프로토 타입 빈이 업데이티 되지 않는다.      업데이트 하려면                  scoped-proxy          Object-Provider          Provider (표준)                    https://www.baeldung.com/spring-inject-prototype-bean-into-singleton        싱글톤 객체 사용시 주의할 점          상태값 공유      ApplicationContext 초기 구동시 인스턴스 생성      Environment 1부 - Profile프로파일과 프로퍼티를 다루는 인터페이스  ApplicationContext extends EnvironmentCapable      public interface EnvironmentCapable {      Environment getEnvironment();  }        프로파일          빈들의 그룹      Environment의 역할은 활성화 할 프로파일 확인 및 설정        프로파일 유즈케이스          테스트 환경에서는 A라는 빈 사용, 배포 환경에서는 B라는 빈을 사용하고 싶다.      서비스 환경에만 등록 하기 위한 빈 설정        프로파일 정의하기          Class        @Configuration @Profile(“test”)@Component @Profile(“test”)                    Method        @Bean @Profile(“test”)                      프로파일 설정하기          -Dspring.profiles.avtive=”test,A,B,…”      @ActiveProfiles(“test”)        프로파일 표현식          !, &amp;, | 와 같은 표현식으로 여러가지 경우를 계산할 수 있다.      Environment 2부 - Property  프로퍼티란 ?          다양한 방법으로 정의할 수 있는 설정값      Environment의 역할은 프로퍼티 소스 설정 및 값 가져오기        프로퍼티 우선순위          StandardServletEnvironment의 우선순위                  ServletConfig 매개변수          ServletContext 매개변수          JNDI (java:comp/env/)          JVM 시스템 프로퍼티 (-Dkey=”value”)          JVM 시스템 환경 변수 (운영 체제 환경 변수)                      @PropertySource          Environment를 통해 프로퍼티 추가하는 방법        스프링 부트의 외부 설정 참고          기본 프로퍼티 소스 지원 (application.properties)      프로파일 까지 고려한 계층형 프로퍼티 우선순위 제공      MessageSource다양한 언어 지원기능을 제공하는 인터페이스  ApplicationContext extends MessageSource        public interface MessageSource {      @Nullable        String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);      ...    }        스프링 부트를 사용한다면 별다른 설정 필요없이 message.properties를 사용할 수 있음.          messages.properties      messages_ko_kr.properties        Reloading 기능을 제공하는 MessageSource      @Bean  public MessageSource messageSource() {    var messageSource = new ReloadableResourceBundleMessageSource();    messageSource.setBasename("classpath:/messages");    messageSource.setDefaultEncoding("UTF-8");    messageSource.setCacheSeconds(3);    return messageSource;  }        ApplicationEventPublisher    이벤트 프로그래밍에 필요한 인터페이스 제공 옵저버패턴 구현체    ApplicationContext extends ApplicationEventPublisher      @FunctionalInterface  public interface ApplicationEventPublisher {    default void publishEvent(ApplicationEvent event) {      publishEvent((Object) event);    }    void publishEvent(Object event);  }        이벤트 만들기          ApplicationEvent 상속      스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다.        이벤트 처리하는 방법          ApplicationListener 구현한 클래스 만들어서 빈으로 등록하기.      스프링 4.2 부터는 @EventListener를 사용해서 빈의 메소드에 사용할 수 있다.      기본적으로는 synchronized.      순서를 정하고 싶다면 @Order와 함께 사용.      비동기적으로 실행하고 싶다면 @Async와 함께 사용.        스프링이 제공하는 기본 이벤트          ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.      ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생.      ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생.      ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생.      RequestHandledEvent: HTTP 요청을 처리했을 때 발생.        @Component  public class AppRunner implements ApplicationRunner {      @Autowired      ApplicationEventPublisher eventPublisher; // 이벤트를 넘겨주기 위한 객체      @Override      public void run(ApplicationArguments args) throws Exception {          eventPublisher.publishEvent(new MyEvent(this, 100));      }  }  @Component  public class MyEventHandler {    @EventListener      @Async    public void handle(MyEvent myEvent) {        System.out.println(Thread.currentThread().toString());        System.out.println("event" + myEvent.getData());    }  }사용법ResourceLoader리소스를 읽어오는 기능을 제공하는 인터페이스  ApplicationContext extedns ResoruceLoader      public interface ResourceLoader {      String CLASSPATH_URL_PREFIX = "classpath:";      Resource getResource(String var1);      @Nullable      ClassLoader getClassLoader();  }        리소스 읽어오기          파일 시스템에서 읽어오기      클래스패스에서 읽어오기      URL로 읽어오기      상대/절대 경로로 읽어오기        @Componentpublic class AppRunner implements ApplicationRunner {  @Autowired  ApplicationContext applicationContext;  @Override  public void run(ApplicationArguments args) throws Exception {      System.out.println(applicationContext.getClass());      Resource resource = applicationContext.getResource("classpath:test.txt");      System.out.println(resource.getClass());      System.out.println(resource.exists());      System.out.println(resource.getDescription());      System.out.println(Files.readString(Path.of(resource.getURI())));  }}                    Resource 추상화  특징          java.net.URL을 추상화 한것      스프링 내부에서 많이 사용하는 인터페이스        추상화 한 이유          클래스 패스 기준으로 리소스 읽어오는 기능 부재      ServletContext를 기준으로 상대 경로를 읽어오는 기능 부재      새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수 있지만 구현이 복잡하고 편의성 메소드가 부족하다.        Resource          상속 받은 인터페이스      주요 메소드                  getInputStream()          exitst()          isOpen()          getDescription(): 전체 경로 포함한 파일 이름 또는 실제 URL                      구현체          UrlResource : 기본으로 지원하는 프로토콜 http, https, ftp, file, jar      ClassPathResource : 지원하는 접두어 classpath:      FileSystemResource      ServletContextResource : 웹 어플리케이션 루트에서 상대 경로로 리소스를 찾는다.      …        리소스 읽어오기          Resource의 타입은 locaion 문자열과 ApplicationContext의 타입에 따라 결정 된다.                  ClassPathXmlApplicationContext -&gt; ClassPathResource          FileSystemXmlApplicationContext -&gt; FileSystemResource          WebApplicationContext -&gt; ServletContextResource                    ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL 접두어(+ classpath:)중 하나를 사용할 수 있다.                  classpath:me/whiteship/config.xml -&gt; ClassPathResource          file:///some/resource/path/config.xml -&gt; FileSystemResourc                    Validation 추상화애플리케이션에서 사용하는 객체 검증용 인터페이스  특징          어떠한 계층과도 관계가 없다. -&gt; 모든 계층(웹, 서비스, 데이터)에서 사용할 수 있다.      구현체 중 하나로, JSR-303(Bean Validation 1.0)과 JSR-349(Bean Validation 1.1)을 지원한다.        인터페이스          boolean support(Class clazz) : 어떤 타입의 객체를 검증할 때 사용할 것인지 결정      void validate(Object obj, Errors e) : 실제 검증 로직을 이 안에서 구현                  구현 시 ValidationUtils를 사용하며 편리                      스프링 부트 2.0.5 이상 버전을 사용할 때          LocalValidatorFactoryBean 빈으로 자동 등록      JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용.      https://beanvalidation.org/      public class Event {    Integer id;    @NotEmpty    String title;    @Min(value = 0)    Integer limit;    @Email    String email;}public class EventValidator implements Validator {    @Override    public boolean supports(Class&lt;?&gt; aClass) {        return Event.class.equals(aClass);    }    @Override    public void validate(Object o, Errors errors) {        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "title", "notempty", "Empty title is not allow"); // errorcode는 messagesource에서 가지고 온다.    }}  참고 : 스프링 부트 2.3 버전 부터 spring-boot-starter-web에서 validtaion이 분리됨.spring-boot-starter-validation을 추가해줘야 한다.데이터 바인딩 추상화 : PropertyEditorDataBinder  기술적인 관점          프로퍼티 값을 타겟 객체에 설정하는 기능        사용자 관점          사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능      입력값 대부분은 “문자열”이지만 그 값을 객체가 가지고 있는, int, String, long, Boolean 심지어 사용자 도메인으로 변환하여 넣어준다.        PropertyEditor          스프링 3.0 이전까지 DataBinder가 변환 작업시 사용하던 인터페이스      thread - safe하지 않다.      Object와 String 간의 변환만 할수 있어 사용범위가 제한적.      public class EventPropertyEditor extends PropertyEditorSupport {  @Override  public String getAsText() {    return ((Event)getValue()).getTitle();  }  @Override  public void setAsText(String text) throws IllegalArgumentException {    int id = Integer.parseInt(text);    Event event = new Event();    event.setId(id);    setValue(event);  }}데이터 바인딩 추상화 : Converter와 Formmater  Converter          S 타입을 T 타입으로 변환할 수 있는 일반적인 변환기      상태값이 없다 -&gt; Thread Safe하다      ConverterRegistry에 등록하여 사용        @RestControllerpublic class EventController {    @GetMapping("/event/{event}")    public String getEvent(@PathVariable Event event) {        return event.getId().toString();    }}@Componentpublic static class StringToEventConverter implements Converter&lt;String, Event&gt; {    @Override    public Event convert(String s) {        return new Event(Integer.parseInt(s));    }}@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addConverter(new StringToEventConverter());    }        }                      Formatter          PropertyEditor 대체제      Object와 String 간의 변환을 담당한다.      문자열을 Locale에 따라 다국화하는 기능도 제공한다. (optional)      FormatterRegistry에 등록해서 사용        //thread safe 하여 bean 등록 가능 및 다른 bean 주입 가능//data binding 관련해서 사용할 경우 event formatter를 사용하는것을 추천.@Componentpublic class EventFomatter implements Formatter&lt;Event&gt; {    @Autowired    MessageSource messageSource;    @Override    public Event parse(String s, Locale locale) throws ParseException {        return new Event(Integer.parseInt(s));    }    @Override    public String print(Event event, Locale locale) {        return event.getId().toString();    }}@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addFormatter(new EventFomatter());    }}                      ConversionService          실제 변환 작업은 이 인터페이스를 통해서 thread-safe 하게 사용할 수 있음.      스프링 MVC, 빈 (value) 설정, SpEL에서 사용한다.      DefaultFormattingConversionService                  FormatterRegistry          ConversionService          여러 기본 컴버터와 포매터 등록 해 줌.                      스프링 부트          웹 애플리케이션인 경우에 DefaultFormattingConversionSerivce를 상속하여 만든 WebConversionService를 빈으로 등록해 준다.public class WebConversionService extends DefaultFormattingConversionService      Formatter와 Converter 빈을 찾아 자동으로 등록해 준다.      @Componentpublic class AppRunner implements ApplicationRunner {    @Autowired    ConversionService conversionService;    @Override    public void run(ApplicationArguments args) throws Exception {        System.out.println(conversionService); // 등록된 converter를 확인 하는 방법.        System.out.println(conversionService.getClass().toString());    }}SpEL(Spring Expression Language)  SpEL 이란 ?          객체 그래프를 조회 및 조작하는 기능 제공      메소드 호출 지원, 문자열 템플릿 기능도 제공      SpEL은 모든 스프링 프로젝트 전반에서 사용하기 위한 EL로 만들어졌다.      스프링 3.0 부터 지원        SpEL 구성          ExpressionParser parser = new SpelExpressionParser()      StandardEvaluationContext context = new StandardEvaluationContext(bean)      Expression expression = parser.parseExpression(“SpEL 표현식”)      String value = expression.getValue(context, String class)        문법          #{“표현식”}      ${“프로퍼티”}      표현식은 프로퍼티를 가질 수 있지만 반대는 안된다.                  #{${my.data} + 1}                    레퍼런스        사용처          @Value 애노테이션 참고      @ConditionalOnExpression 애노테이션      Spring Security                  Method Security, @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter          XML 인터셉터 URL 설정          …                    스프링 데이터                  @Query 애노테이션                    …        @Value("#{1 + 1}")int value;@Value("#{'hello ' + 'world'}")String greeting;@Value("#{1 eq 1}")boolean trueOrFalse;@Value("${my.value}")int myValue;@Value("#{${my.value} eq 100}")boolean isMyValue100;@Value("#{sample.data}")int sampleData;                    스프링 AOPAspect - Oriented Programming (AOP)는 OOP를 보완하는 수단으로, 흩어진 Aspect를 모듈화 할 수 있는 프로그래밍 기법  AOP 주요 개념          Aspect : 흩어진 관심사      Target : Ascpect를 적용하는 매체 (class, method)      Advice : 실직적인 부가 기능을 실행하는 구현체      Join Point와 Pointcut : advice를 실행할 위치, 포지션, 실행 전후 처리 등을 설정하는 기능        AOP 구현체          자바                  AspectJ          스프링 AOP                      AOP 적용 방법          컴파일      로드 타임      런타임      프록시 기반 AOP  스프링 AOP 특징          프록시 기반의 AOP구현체      스프링 빈에만 AOP를 적용할 수 있다.      모든 AOP기능을 제공하는 것이 목적이 아니라, 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 제공하는것이 목적.        프록시 패턴          기존 코드의 변경없이 접근제어 또는 부가 기능을 추가할 수 있는 대리자 패턴        문제점          매번 프록시 클래스를 작성해야 하는가 ?      여러 클래스, 여러 메소드에 적용하려면 ?        스프링 AOP          스프링 IoC컨테이너가 제공하는 기반 시설과 Dynamic 프록시를 사용하여 여러 복잡한 문제 해결      동적 프록시 : 동적으로 프록시 객체를 생성하는 방법                  자바가 제공하는 방법은 인터페이스 기반 프록시 생성          CGlib는 클래스 기반 프록시도 지원                    스프링 IoC : 기존 빈을 대체하는 동적 프록시 빈을 만들어 등록 시켜준다.                  클라이언트 코드의 변경이 없다.          public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware                    @AOP애노테이션 기반의 스프링 @AOP  Aspect 정의          @Aspect      빈으로 등록해야 하니깐 @Component 추가        포인트 컷 정의          @Pointcut(표현식)      주요 표현식                  execution          @annotaion          bean                    포인트 컷 조합                  &amp;&amp;, ||, !                      어드바이스 정의          @Before      @AfterReturning      @AfterThrowing      @Around          //Annotation 사용시 Retentionpolicy를 class 이상으로 적용해야 한다.Class파일까지 남아있어야 하기 때문에    // 기본값 class    @Retention(RetentionPolicy.CLASS)    @Target(ElementType.METHOD)    @Documented    public @interface PerfLogging {}    @PerfLogging    public void createEvent() {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("createEvent");    }    @Around("@annotation(PerfLogging)")    public Object logPerf(ProceedingJoinPoint pjp) throws Throwable{        long begin = System.currentTimeMillis();        Object proceed = pjp.proceed();        System.out.println(System.currentTimeMillis() - begin);        return proceed;    }    @Before("bean(simpleEventService)")    public void hello() {        System.out.println("Hello");    }]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[테스트 코드를 작성하는 다양한 방법]]></title>
      <url>/dev/2020/06/02/test-code/</url>
      <content type="text"><![CDATA[  테스트 코드를 작성하는 다양한 방법테스트 코드를 작성하는 다양한 방법Spring Boot 2.2.X 버전 부터 기존에 사용하던 Junit4 가 아닌 Junit5가 기본 디펜던시로 추가 되었습니다.Junit4를 사용하지 못하는건 아니지만 스프링이 Junit5를 완전히 지원한다는 이야기니 왠만하면 Junit5를 사용합시다.테스트 코드를 작성하는 3가지 방법을 소개 하나 각 방법에 대하여 깊은 이해가 있지 않아 맛보기 식으로 공유해드리겠습니다.우선 Junit5 에서는 @RunWith(SpringRunner.class) 라는 애노테이션이 필요 없어졌습니다.대신 Extend 기능을 활용해서 필요한 디펜던시를 추가할 수 있습니다.BeforeAll, BeforeEach 등의 애노테이션을 사용해서 테스트 메소드 실행전 필요한 객체를 생성 하도록 변경되었습니다.주로 사용하는 기능  Setup 기능 :  BeforeEach , BeforeAll 등의 애노테이션으로 테스트 시작 전 필요한 데이터를 설정 할 수 있음. IntelliJ 에서 지원.          BeforeAll 같은 경우 Junit4에서는 지원하지 않던 Static한 데이터 공유가 가능함.        DisplayName  : 테스트의 이름을 표시 할 수 있는 기능.  ParameterizeTest  : 테스트 실행시 필요한 파라미터를 전달하여 @ValueSource사용 실행이 가능함.  ActiveProfile : 테스트 프로퍼티를 별도로 관리할 경우 테스트 프로파일 설정.그 외로 새롭게 사용할 수 있는 기능들은 Docs를 확인해주시길 바랍니다.JUnit 5 User GuideSpringBootTest 를 이용한 컨트롤러 통합 테스트@SpringBootTest 애노테이션을 테스트 환경에서 사용할 시 SpringBoot Application이 구동되어 등록되어 있는 빈을 전부 로드하게 됩니다.이로 인해서 테스트는 등록된 빈을 사용해서 모든 로직등 실제 사용하는 빈을 통하여 실행되게 됩니다.통합 테스트MockMvc 을 사용하기 위해서 @AutoConfigureMockMvc 애노테이션을 등록합니다.MockMvc 객체는 테스트 코드에서 Http요청을 보낼수 있도록 도와주는 객체 입니다.슬라이싱 테스트  @DataJpaTest : JpaRepository 테스트 시 사용  @EnableWebMvc : Controller 테스트…  참고 : 테스트 코드에서 @Transaction애노테이션을 사용할 경우 기본 Rollback정책이 True이므로 Rollback하지 않는 데이터를 확인 하기 위해선 false로 지정 해줘야 합니다.Model 검증@Test@DisplayName("index 페이지 정상 작동")public void indexPage() throws Exception {    ResultActions resultActions = mockMvc.perform(get("/index"))            .andDo(print())            .andExpect(status().isOk());    MvcResult mvcResult = resultActions.andReturn();    Map&lt;String, Object&gt; model = 	mvcResult.getModelAndView().getModel();    assertThat(model.get("facebookAppId")).isNotNull();    assertThat(model.get("kakaoAppId")).isNotNull();    assertThat(model.get("s3Uri")).isNotNull();    assertThat(model.get("tagManagerCode")).isNotNull();    assertThat(model.get("host")).isNotNull();}API 검증@Test@DisplayName("상품 정상 생성")void create() throws Exception {    String productName = "간장치킨";    BigDecimal price = BigDecimal.valueOf(17000);    Product product = createProduct(productName, price);    mockMvc.perform(post("/api/products")            .contentType(MediaType.APPLICATION_JSON)            .content(objectMapper.writeValueAsString(product)))            .andDo(print())            .andExpect(status().isCreated())            .andExpect(header().exists(HttpHeaders.LOCATION))            .andExpect(jsonPath("id").exists())            .andExpect(jsonPath("name").value(productName))            .andExpect(jsonPath("price").value("17000.0"))            ;}Mockito 를 이용한 단위 테스트특정 객체를 Mocking하여 단위 테스트를 하기 위해선 일반적으로 Mockito를 활용하여 테스트 합니다.Mocking을 하는 이유는 개인적으로는 단위 테스트를 정확하게 하고자 함에 있다고 생각합니다.여기서 말하는 정확한 단위 테스트는 예를 들면 Service Layer를 테스트 할때 Dao (Repository) 에서 발생하는 이슈가 테스트에 영향을 끼치지 않게 함에 있습니다.Service Logic 을 정확히 테스트 하고 Repository는 따로 Repository 테스트를 만들어서 테스트 함을 권장하고 있습니다.Mocking을 통한 테스트를 작성하려면 @ExtendWith(MockitoExtension.class) 애노테이션을 사용하면 됩니다.@Mock // 객체 Mockingprivate MenuGroupDao menuGroupDao;@InjectMocks // Mock 객체 주입private MenuGroupBo menuGroupBo;위 코드와 같이 Mock객체를 주입 받아 테스트를 실행할 객체를 설정합니다.Mocking 된 객체는 Stubbing을 통하여 객체의 행동을 조작할 수 있습니다.given(menuGroupDao.findAll()).willReturn(menuGroups); // BDD stylewhen(menuGroupDao.findAll()).thenReturn(menuGroups);given또는 when ~ 메서드를 사용하여 객체의 행동을 조작합니다.조작한 행동을 통하여 원하는 결과가 나오는지 확인을 할 수 있습니다.샘플코드@DisplayName("테이블 착석 상태를 비움으로 변경")@Testvoid changeEmpty() {    OrderTable requestOrderTable = new OrderTableBuilder()            .setEmpty(true)            .build()            ;    OrderTable orderTable = new OrderTableBuilder()            .setEmpty(false)            .setId(1L)            .build()            ;    when(orderTableDao.findById(orderTable.getId())).thenReturn(Optional.of(orderTable));    when(orderDao.existsByOrderTableIdAndOrderStatusIn(orderTable.getId(),            Arrays.asList(OrderStatus.COOKING.name(), OrderStatus.MEAL.name()))).thenReturn(false);    when(orderTableDao.save(orderTable)).thenReturn(orderTable);    OrderTable changedOrderTable = tableBo.changeEmpty(orderTable.getId(), requestOrderTable);    assertThat(changedOrderTable.isEmpty()).isTrue();}많은 기능이 존재함으로 역시나 문서를 확인 합니다.Mockito (Mockito 3.2.4 API)Fake Object 를 이용한 단위 테스트Fake Object 라는 개념이 혼란 스러울수 있습니다.이 개념은 Mocking 과 비슷하면서도 다른 개념이라 아직 제대로 이해하지 못하였습니다.Fake Object 를 사용하는 이유에 대하여 설명드리자면 Mocking을 통한 테스트는 실제 로직이 어떻게 돌아가는지 다 알고 있는 상태여야 합니다. 그래서 원하는 결과값을 (행위에 대한 결과)를 받을수 있도록 Stubbing 합니다. 일명 Whitelist Test 라고 할 수 있습니다.반면에 Fake Object를 사용하면 어떤 로직이 실행되는지 전혀 알 필요가 없고 가짜 객체를 통한 실행 결과만 받을 수 	있으면 테스트를 작성 할 수 있게 됩니다.샘플코드private ProductDao productDao = new FakeProductDao();private ProductBo productBo;@BeforeEachvoid setUp() {    productBo = new ProductBo(productDao);}@DisplayName("상품을 등록 할 수 있다")@Testvoid create() {    //given    Product expected = new Product();    expected.setId(1L);    expected.setName("치킨");    expected.setPrice(BigDecimal.valueOf(16_000L));    //when    Product actual = productBo.create(expected);    //then    assertThat(actual).isNotNull();    assertThat(actual.getName()).isEqualTo(expected.getName());    assertThat(actual.getPrice()).isEqualTo(expected.getPrice());}public class FakeProductDao implements ProductDao {    private Map&lt;Long, Product&gt; entities = new HashMap&lt;&gt;();    @Override    public Product save(Product entity) {        entities.put(entity.getId(), entity);        return null;    }    @Override    public Optional&lt;Product&gt; findById(Long id) {        return Optional.ofNullable(entities.get(id));    }    @Override    public List&lt;Product&gt; findAll() {        return new ArrayList&lt;&gt;(entities.values());    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Test </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringSecurity-WithSecurityContextFactory 소개]]></title>
      <url>/dev/2020/05/23/spring-security-with-security-context-factory/</url>
      <content type="text"><![CDATA[  스프링 시큐리티를 사용하여 테스트 코드를 작성하는 경우 Authentication 정보를 자동으로 담아주지 못하여 테스트 코드 작성이 힘들어지는 경우가 있다. 이런경우에 테스트코드 작성을 편하게 할 수 있는 방법을 소개 합니다.SpringSecurity-WithSecurityContextFactory 소개  해당 기능은 백기선님의 강의(스프링과 JPA기반 웹 애플리케이션 개발)를 참고 하였습니다.샘플 프로젝트는 Spring Boot + JPA + Spring Security 로 구성되어 있습니다.샘플 코드테스트는 서비스 및 도메인의 단위 테스트가 아닌 통합 테스트를 진행한다고 가정합니다.@Transactionalpublic CreateResponse create(CreateRequest createRequest) {    Board board = createRequest.toEntity();    Board savedBoard = boardRepository.save(board);    return new CreateResponse(savedBoard);}단순히 Board Entity를 저장하는 기능을 제공하는 서비스 코드 입니다.위 코드를 검증하기 위하여 Test 를 작성할 경우 일반적인 환경에서는 정상적으로 동작하겠지만, Security가 포함된다면 예기치 못한 이슈가 발생할 수 있습니다.@Overrideprotected void configure(HttpSecurity http) throws Exception {    http.csrf()            .disable()        .authorizeRequests()            .mvcMatchers("/sign-up").permitAll()        .anyRequest()            .authenticated()        .and()        .formLogin()        .and()        .httpBasic();}Security 설정입니다.  /sign-up 을 제외한 모든 api는 인증된 사용자만 접근이 가능하도록 설정 해둔 경우 위 코드를 검증하기 위해선 몇가지 방법이 존재할 수 있습니다. Spring Security Reference를 보면 아래와 같은 기능들을 제공해주고 있습니다.https://docs.spring.io/spring-security/site/docs/current/reference/html5  @WithMockUser 사용  @WithUserDetails 사용  @WithSecurityContext 사용하나씩 살펴보면 내용이 길어지므로 레퍼런스를 확인해주시면 될것 같습니다. 간단하게 요약하자면 Security Filter를 통과 하기 위해선 위 2가지 기능만 사용하면 통과 할 수 있지만 지금 살펴볼 기능은 3번째 기능을 사용해야 편하고 간단하게 테스트 코드를 작성할 수 있습니다.@MappedSuperclass@Getterpublic class BaseEntity extends BaseTimeEntity {    @Column(updatable = false)    private Long createdBy;    private Long lastUpdatedBy;    @PrePersist    public void prePersist() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        createdBy = userAccount.getAccount().getId();        lastUpdatedBy = userAccount.getAccount().getId();    }    @PreUpdate    public void preUpdate() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        lastUpdatedBy = userAccount.getAccount().getId();    }}위 코드와 같이 Entity가 저장되거나 수정되는 경우 자동으로 Authentication에서 값 저장하는 코드가 존재한다면, 테스트코드가 동작할 때 Authentication객체가 필요하게 됩니다.간단하게 생각하자면, 테스트를 실행하기전 Authentication객체를 만들고, SecurityContextHolder에 담아 테스트를 실행하면 되지만, 모든 테스트 클래스에서 중복된 코드가 발생하게 될것이므로 정신건강에 좋지 않을것 같습니다.이러한 기능을 간편하게 애노테이션으로 정의하여 사용하는 WithSecurityContextFactory 를 사용해 봅시다.@Retention(RetentionPolicy.RUNTIME)@WithSecurityContext(factory = WithAccountSecurityContextFactory.class, setupBefore = TestExecutionEvent.TEST_EXECUTION)public @interface WithAccount {    String value();}우선 WithSecurityContext를 정의한 애노테이션을 작성합니다.@RequiredArgsConstructorpublic class WithAccountSecurityContextFactory implements WithSecurityContextFactory&lt;WithAccount&gt; {    private final AccountService accountService;    @Override    public SecurityContext createSecurityContext(WithAccount withAccount) {        String username = withAccount.value();        String email = username + "@gmail.com";        String password = "password";        AccountCreateRequest accountCreateRequest = new AccountCreateRequest();        accountCreateRequest.setEmail(email);        accountCreateRequest.setPassword(password);        accountCreateRequest.setNickname(username);        accountService.saveAccount(accountCreateRequest);        UserDetails userDetails = accountService.loadUserByUsername(email);        Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails,                userDetails.getPassword(), userDetails.getAuthorities());        SecurityContext context = SecurityContextHolder.createEmptyContext();        context.setAuthentication(authentication);        return context;    }}그후 WithSecurityContextFactory을 구현한 클래스를 만든 뒤, Authentication객체를 생성, SecurityContext에 담아주는것으로 구현이 끝납니다.사용하는 방법도 간단합니다.@DisplayName("보드 조회 - 단건")@WithAccount("dongchul")@Testvoid findBoard() throws Exception {    CreateRequest createRequest = new CreateRequest();    createRequest.setTitle("title");    boardService.create(createRequest);    mockMvc.perform(get(BoardApiController.BOARD_URI + "/1"))            .andDo(print())            .andExpect(status().isOk())            .andExpect(jsonPath("title").exists());}위와 같이 테스트 코드 실행시 만들어둔 애노테이션을 사용하기만 하면 테스트가 정상적으로 실행됩니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Security </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[책임 주도 설계 정리]]></title>
      <url>/dev/2020/05/15/grasp/</url>
      <content type="text"><![CDATA[  책임 주도 설계 정리, 작성중입니다.책임 주도 설계 흐름  시스템이 사용제에게 제공해야하는 기능인 시스템 책임을 파악한다.  시스템 책임을 더 작은 책임으로 분할한다.  분할한 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.  객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.  해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.디미터 법칙  객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 방법.  오직 하나의 도트(.)만 사용해라.  디미터 법칙에 따르면 훌륭한 메시지는 객체의 상태에 관해 묻지 말고, 원하는 것을 시켜야 한다라는 사실을 강요한다.          묻지말고 시켜라(Tell. Don’t Ask)        디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.          객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 경우이다. (Stream)      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[This 와 Super에 대한 오해]]></title>
      <url>/dev/2020/05/10/java-this-and-super/</url>
      <content type="text"><![CDATA[  오브젝트(조영호님)책을 보며 정리한 내용, 작성중입니다.Java에서 This 란 ? this는 인스턴스의 자기 자신을 의미한다. this.은 주로 필드(전역변수)와 메소드 또는 생성자의 매개변수가 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용한다.자기 자신을 의미한다 -&gt; Self 참조값을 가진다.[image:691E34BC-B312-4128-986B-E438E22D6657-313-00013C90DB2EC097/C225693B-BF77-4EA2-8E73-BE2039800B75.png]  Java에서 Super란 ?super는 자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다. 클래스 내의 멤버변수와 지역변수의 이름이 같을 경우 구분을 위해 this를 사용하듯이 부모 클래스와 자식 클래스의 멤버의 이름이 같을 경우 super를 사용합니다. this와 super는 인스턴스의 주소값을 저장하는데 static 메서드(클래스 메서드)와는 무관하게 사용됩니다.출처: https://freestrokes.tistory.com/72 [FREESTROKES DEVLOG]상속받은 멤버를 참조할 때 사용하는 참조 변수 -&gt; 참조값을 변경한다.[image:670EA140-164A-491D-BD46-2C3720574555-313-00013C953E7391ED/45933790-F795-4A95-BA5D-CD0536292A53.png]간단한 예시 코드를 통하여 This와 Super에 대한 오해를 풀어봅시다.public class Main {    public static void main(String[] args) {        Weapon weapon = new Knife();        weapon.use();    }}public class Weapon {    private int damage = 0;    public void use() {        System.out.println("Use Weapon");        attack();    }    public void attack() {        System.out.println("Weapon : " + damage);    }}public class Sword extends Weapon{    @Override    public void attack() {        attack();    }}public class Knife extends Sword {    private int dagame = 4;    @Override    public void attack() {        System.out.println("knife : " + dagame);    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Enum Class 정리]]></title>
      <url>/dev/2020/05/03/java-enum/</url>
      <content type="text"><![CDATA[  Enum 사용법에 대하여 정리 및 사내 공유를 위해 작성      해당 글의 용어 및 내용은 Java Enum 활용기 - 우아한형제들 기술 블로그를 많이 참고 하였습니다.    Enum이란 ?          Enumeration은 프로그래밍언어에서 상수의 그룹을 나타낼 때 사용한다.Enum은 컴파일 당시 우리가 모든 가능한 값을 알고있는 경우 사용된다. 항상 enum안의 상수는 타입이 정해져 있어야 되는 것은 아니다.Java 1.5버전 부터, enum은 enum 데이터 타입이라고 표시되었다. 자바 enum은 C/C++ enum보다 더 강력한 기능을 제공한다. 자바에서 변수, 메소드 그리고 생성자를 추가할 수 있다. enum의 주된 목적은 우리만의 데이터 타입을 가지기 위해서이다. (Enumberated Data Type)참고 자바의 enum            위 정의를 보더라도 Enum은 상수의 그룹을 나타내기 위하여 사용한다. 라고 선언 되어 있습니다. 과연 상수만을 위하여 Enum을 쓰는것 보다 Enum을 더욱 강력히 사용할 수 없을까? 라는 생각을 가지고 이 글을 보시면 더욱 좋을것 같습니다.    들어가기 앞서 객체는 상태와 행위를 가진다. 라는 개념에 대해 알고 계시는것이 좋을 것 같습니다.Enum - 상수의 집합 ?  사칙연산을 위한 프로그램을 만든다 할때 연산자를 아래와 같은 Enum으로 구분하여 사용할 수 있을것 같습니다.  OperatorType은 사칙연산을 위한 연산자를 가지고 있고 여러 클래스에 선언되어 사용하지 않고 연산자를 Enum으로 관리하여 응집도를 높였다고 볼수 있겠네요.    public enum OperatorType {  PLUS_OPERATOR("+"),  MINUS_OPERATOR("-"),  MULTIPLY_OPERATOR("*"),  DIVIDE_OPERATOR("/");  private String operator;  OperatorType(String operator) {      this.operator = operator;  }  public boolean isEqual(String operator) {      return this.operator.equals(operator);  }}        OperatorType은 과연 상태와 행위를 가지는 객체 인가요 ?          코드를 보시고 상태만 가지고 있다. 라고 생각이 든다면 정답입니다.        과연 행위는 어디에 있을까 ?          어디선가 아래와 같은 코드를 가지고 있는 클래스를 만들어서 사용해야 할것 입니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    if (PLUS_OPERATOR.isEqual(operator)) {        return plus();    }    if (MINUS_OPERATOR.isEqual(operator)) {        return minus();    }    if (MULTIPLY_OPERATOR.isEqual(operator)) {        return multiply();    }    if (DIVIDE_OPERATOR.isEqual(operator)) {        return divide();    }    throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");}  다시 처음 이야기한 객체의 정의에 대해서 생각해봅시다.          객체는 상태와, 행위를 가진다.      OperatorType은 행위를 가지고 있지 않으니 위 코드에 포함된 행위를 OperatorType 으로 옮겨 보겠습니다.        위 코드에서의 문제점은 무엇일까요 ?          곰곰히 생각을 해봅시다 : )      Enum - 상태와 행위를 한곳에  상태와 행위를 한곳에 모아둔 OperatorType을 먼저 보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+") {        @Override        public double calculate(double sum, double nextNumber) {            return sum + nextNumber;        }    },    MINUS_OPERATOR("-") {        @Override        public double calculate(double sum, double nextNumber) {            return sum - nextNumber;        }    },    MULTIPLY_OPERATOR("*") {        @Override        public double calculate(double sum, double nextNumber) {            return sum * nextNumber;        }    },    DIVIDE_OPERATOR("/") {        @Override        public double calculate(double sum, double nextNumber) {            if (nextNumber == 0) {                throw new IllegalArgumentException("0 으로 나눌수 없습니다.");            }            return sum / nextNumber;        }    };    private String operator;    OperatorType(String operator) {        this.operator = operator;    }    public static OperatorType createOperator(String operator) {        if(operator.equals(PLUS_OPERATOR.operator)) {            return PLUS_OPERATOR;        }        if(operator.equals(MINUS_OPERATOR.operator)) {            return MINUS_OPERATOR;        }        if(operator.equals(MULTIPLY_OPERATOR.operator)) {            return MULTIPLY_OPERATOR;        }        if(operator.equals(DIVIDE_OPERATOR.operator)) {            return DIVIDE_OPERATOR;        }        throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");    }    public abstract double calculate(double sum, double nextNumber);}  이제 OperatorType 내부에 선언되어있는 객체들은  calculate라는 행위를 가지게 되었습니다. 이로 인해서 처음에 이야기 했던 객체의 정의를 만족 하게 되었네요 !  이전에 행위를 구현했던 코드는 어떻게 변했을까요 ?          참고Java7 부터 Enum 상수에 추상 메소드를 구현할 수 있습니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    OperatorType operatorType = createOperator(operator);    return operatorType.calculate(sum, nextNumber());}  이전엔 Operator 별로 분기를 타며 계산을 하던 메소드가 실제 계산 하라  라는 메시지를 OperatorType에 던지는 단순하고 깔끔한 메소드로 변경 되었습니다.  여기까지만 보더라도 연산자를 가지고 있는 OperatorType은 자신이 가지고 있는 책임인 계산한다 라는것을 완벽하게 이행 함으로서 외부에선 모든 사칙연산에 관한 계산을 OperatorType을 사용할 수 있게 되었습니다.  이전에 상태와 행위를 한곳에서 관리 하지 않은 코드를 생각해보시면, 계산 하라라는 메시지를 누구에게도 던지지 않고 전혀 의미 없는 클래스에서 행위를 구현하여, 다른 클래스에서의 중복이 발생할 가능성이 컸습니다.  아직 남아 있는 문제점.  보시다 시피 Enum 내부 정적 메소드에 파라미터로 전달 받은 Operator에 맞는 상수를 찾아 전달 하고 있습니다. 위와 같은 분기문이 나열되어 있는 것이 좋은 패턴일까요 ?Enum 리팩토링 - 분기문을 없애보자.  분기문을 없애면서 저희는 Java 8 이상을 사용하는 개발자들로  추상메소드를 사용한 방식보다 Lambda를 사용한 OperatorType으로 리팩토링 해보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+", (sum, nextNumber) -&gt; sum + nextNumber),    MINUS_OPERATOR("-", (sum, nextNumber) -&gt; sum - nextNumber),    MULTIPLY_OPERATOR("*", (sum, nextNumber) -&gt; sum * nextNumber),    DIVIDE_OPERATOR("/", (sum, nextNumber) -&gt; {        if (nextNumber == 0) {            throw new IllegalArgumentException("0 으로 나눌수 없습니다.");        }        return sum / nextNumber;    });    private String operator;    private Calculation calculation;    OperatorType(String operator, Calculation calculation) {        this.operator = operator;        this.calculation = calculation;    }    public static OperatorType findOperator(String operator) {        if (Objects.isNull(operator)) {            throw new IllegalArgumentException("연산자는 null 이 될 수 없습니다.");        }        return Arrays.asList(values()).stream()                .filter(operatorType -&gt; operatorType.operator.equals(operator))                .findFirst()                .orElseThrow(() -&gt; new IllegalArgumentException("사칙연산 기호가 아닙니다."));    }    public double calculate(double sum, double nextNumber) {        return calculation.calculate(sum, nextNumber);    }}@FunctionalInterfacepublic interface Calculation {    double calculate(double sum, double nextNumber);}  뭔가 더욱 깔끔하게 리팩토링된것이 느껴진다면 성공입니다 : )  추상메소드를 사용한 방식 대신 Lambda로 calculate를 구현 하였습니다.          Lambda를 사용하기 위하여 @FunctionalInterface를 만들었습니다.                  @FunctionalInterface는 메소드 1개를 가진 인터페이스 입니다.                    Java가 제공하는 함수형 인터페이스도 사용할 수 있습니다.   Function&lt;T, R&gt; 은 매개변수 1개를 지원하고 2개는 BiFunction을 사용하셔도 됩니다.        분기문이 없어진 것을 확인 할 수 있습니다.          Stream 을 사용하여 분기문을 제거하고 코드의 가독성을 높혀 다른 개발자들이 보더라도 어떤 기능을 하는지 쉽게 알수 있게 되었습니다. : )        이처럼 리팩토링을 하게 되어 얻을수 있는 가장 큰 이점은 재사용성과 확장성을 얻을 수 있게 되었다는 것 입니다.      다른 클래스에서 사칙연산을 하기 위해선 OperatorType만 사용하면 될 것이고 새로운 연산자가 추가 되더라도 복잡한 분기문들을 제거 하였기 때문에 상수 정의만 해준다면 어디서든 정상적으로 동작하겠죠 :)    예제를 사칙연산으로 들었지만 Enum을 사용하는 어느 곳이라도 비슷하게 적용할 수 있을것이라 생각하여 공유드렸습니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 5주차 정리]]></title>
      <url>/dev/2020/04/25/tdd-clean-code-5w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 5주차 정리사다리 타기 tdd 구현  Out - in 접근 방식 vs in.- out 접근 방식  TDD 로 구현하기에는 in.- out 방식이 더 적합하다.          가장 작은 단위의.객체부터 기능을 추가하면서 개발한다.      도메인 설계에서 가장 마지막 객체(의존관계가 없는)      가장 작은 단위의 객체가 구현되었으면, 객체를 더 작게 나눌수 없을까 고민      가장 작은 단위의 객체가 새롭게 만들어 졌으면 다시 고민                  위와 같은 사이클을 계속하여 진행                      책임주도설계로 사다리타기 재설계          책임주도설계 == 인터페이스 주도 설계                  사다리 초기화(생성)          사다리 실행          사다리 결과 구하기                    메시지를 먼저 결정하면 내부 상태가 어떻게 도출될지는 자연스럽게 정해진다.      책임 (객체가 해야할 행동, 메시지)를 먼저 정해보는것.        패키지들 간의 의존성은 단방향으로 만들어야 한다.          추후에 큰변화 (분리) 할때 편리하다.      sonarqube와 같은 정적 분석 도구를 활용해 cyclic dependency를 찾아준다.        서비스 로직은 어디에 구현하는것이좋을까 ?          일급 콜렉션을 쓴다.      3개 이상의 인스턴스 변수를 사용하지 않는다.      묻지 말고 시켜라. (데이터를 꺼내지말고 메시지를 던져라)      상태 변경의 주도권은 외부에 있지 않고 도메인이 가지고 있어야 한다.        도메인 설계, 구현 반복          요구사항을 분석후 도메인 설계.      한번에 완벽한 설계를 하겠다는 욕심을 버려라.                  반복적인 설계와 구현을 통해 도메인에 대한 이해도를 높여야 한다.          도메인에 대한 이해도가 높아야 추상화 수준도 높아진다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 4주차 정리]]></title>
      <url>/dev/2020/04/18/tdd-clean-code-4w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 4주차 정리4주차  점진적 리팩토링          기존의 테스트가 깨지지 않는 선에서 리팩토링 하기      컴파일 에러가 발생하면 안된다.        일반적 상황          메소드에 인자가 추가되었다.      인스턴스 변수 타입이 변경되었다.                  -&gt; 컴파일 에러가 발생 , 에러 해결                          위 방식 대로 리팩토링 하면 긍정적인 측면 보다. 부정적인 측면이 생길 수 있다.    우리가 연습해야할 리팩토링은 ?          메소드에 인자가 추가 되는 경우                  메소드를 그대로 복사하여 메소드 이름을 임시로 변경          임시 메소드를 하나씩 실제 사용한 메소드와 변경          더이상 이전 메소드가 존재하지 않으면, 이전 메소드를 제거 후 이름 변경                    인스턴스 변수의 타입이 변경되는 경우                  새로운 인스턴스 변수 추가          String to Integer로 변경 시 일시적으로 두개 타입을 도시에 사용          두개 변수에 동시에 데이터를 넣고 리팩토링                      점진적 리팩토링 - TDD 에 대한 감이 생길때 시작          1단계 - 메소드를 다른 클래스로 이동      2단계 - 메소드에 인자 타입이나, 반환 타입이 변경 시      3단계 - 인스턴스 변수 타입이 변경되는 경우                  데이터의 중복을 만든다. (임시 변수를 만들고, 메소드에 인자가 추가되는 경우와 같이 점차 변경해나간다.)                          리팩토링은 시간 날때마다 진행하는것이다.    객체지향 설계 및 구현 접근 방식은 ?          Bottom Up 설계 및 구현                  구현에 초점을 맞추어 일단 구현 후 지속적 리팩토링을 통해 역할,책임,협력을 찾아 나간다.                    Top Down 구현 및 설계                  책임에 초점을 맞추어 전체적인 설계 후 구현                      책임 주도 설계          책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계                  클래스를 먼저 설계하는것이 아니다.                      책임이란 ?          책임이란 객체가 유지해야할 정보와 수행해야할 행동      즉 객체가 무엇을 알고있는가 와 무엇을 할 수 있는가로 구성된다.        역할을 다른것으로 교체할 수있는 책임의 집합이다.  테스트 하기 쉬운 코드가 유연한 코드는 아니지만 연습하다 보면 유연한 코드가 될 수 있다.  유연한 설계를 지향한다면 컴파일타임 의존성을 런타임 의존성으로 대체한다.          의존성을 주입 한다.        런타임 의존성으로 대체하다보면 테스트하기 쉬운 설계가 가능해진다.      테스트하기 쉬운 설계를 지향하다보면 유연한 설계가 가능해지는 경험을 종종 할 수 있다.    책임 주도 설계가 진정한 대안인가 ?          책임 주도 설계에 익숙해지기 위해선, 부단한 노력과 시간이 필요.      책임 관점에서 사고하기 위해선 부단한 노력과 학습이 필요하다.      빠르게 구현 후 지속적 리팩토링      TDD 사이클을 반복해 설계의 품질을 높힌다.                  리팩토링 시 객체지향 설계 체조원친, 클린코드 설계 원칙을 지키면서..                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 3주차 정리]]></title>
      <url>/dev/2020/04/11/tdd-clean-code-3w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 3주차 정리  tdd 사이클이 익숙해질때 까지 반복적으로 연습해야 한다.          가장 자신있는 언어로 반복 연습하는것을 추천.      힘들고 지칠땐 주제를 바꿔서 해보는것이 좋다.      시작하기  요구사항 분석을 통한 기능 목록 작성      객체설계를 통해 어느 부분 부터 구현할 지 생각하는것이 우선이다.    기능목록          주제에 대해서 가장 일반적인 기능들을 다 적어보자.      점차 작은 단위의 기능들도 정의        TDD로 구현할 기능 찾기          큰 부분을 작게 자르는 연습을 해야한다.        인풋과 아웃풋이 있는 케이스가 테스트 하기 쉽다.      메서드 하나에 모든 로직이 들어가 있으면 객체지향적인 구조보다 절차지향적 구조로 변질되게 된다.    리팩토링, 어디서 부터 시작할까 ?          첫밴쨰는 메소드 분리부터 시작. (Naming Rename도 해야한다.)                  메소드가 한가지 일만 잘하도록 구현한다.                          한가지 일만 하기 위해 메소드 라인을 제약하는것도 좋은 방법이다.                                          Indent를 줄이자.                  Else 예약어를 쓰지 않는다.                    클래스를 분리하자.                  원시값과 문자열을 포장          일급 콜렉션을 사용한다.          3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않기.          메소드 인자수를 제한한다. 2개까지만 허용한다.                          3개는 고민을 많이 하고, 4개는 절대 안된다.              비슷한 속성을 가진 인자수를 클래스로 만들어 보자.                                  속성과 라이프 사이클이 동일하면 쉽게 판단할 수 있다.                                                                          private method를 분리해서 단위테스트 해야하는 것이 아닌가 ? 라는 의구심          private method를 다른 클래스로 만들어 public으로 open하는게 더 나은 구조는 아닐까 생각해보자.            새로운 클래스가 생성될때 테스트부터 만들어 보자.    상속(is-a) 조합(has-a)          일급 collection을 구현할 때 접근 방법으로 상속과 조합 방법으로 구현 가능      객체의 중복(Lotto와 WinningLotto)를 제거 할 때 상속과 조합 방법으로 구현 가능            상속은 의도하지 않은 인터페이스가 외부에 노출될 수 있다.반면 조합을 사용하면 외부에 오픈할 인터페이스를 정의할 수 있다.    상속과 조합 중 어떤것이 좋을까 ?          상속 보단 객체 조합을 사용해라.      코드의 재사용성 측면에선 상속이 유리. 유연성 측면에선 조합이 유리.                  변화에 빠르게 대응하는 것이 점점 더 중요, 현재는 재사용성 보다 유연성이 훨씬 더 중요하다.          확실하게 경험을 하는것이 좋다 !                      생성자 대신 정적 팩토리 메소드 사용.          생성자의 수가 늘어날수록 클래스를 사용하기 위한 유연성은 높아진다.        가변객체보단 불변 객체를 사용해라.  불변 객체 만들기          객체의 상태를 변경하는 메소드를 제공하지 않는다.      클래스를 확장 할 수 없도록 한다. (Public final class)      모든 필드를 final로 선언한다.                  내부에 collection이 있다면 collection도 불변인지 확인해야 한다.                    모든 필드를 private으로 선언한다.        immutable object 가 좋은것은 알겠는데, 인스턴스가 많이 생성되어 성능이 떨어지지 않을까 ?          캐싱을 적용해 인스턴스 생성을 최소화 할 수 있는 방법이 있는지 검토                  캐싱은 일반적으로 Map(key - value) 형식을 가장 많이 사용된다.                    성능외에도유지보수하기 좋은 코드, 읽기 좋은 코드, 유연한 코드, 버그 발생 가능성이 낮은 코드 와 같이 다양한 측면을 고려하면서  프로그래밍 하는습관을 가지자경험해야할 학습 목표 - 사다리 타기* TDD, 객체 지향 프로그래밍 연습* 인터페이스를 추출하여 프로그래밍 하는 연습을 한다.* stream, lambda를 사용해 프로그래밍하는 것을 연습.경험할 객체 지향 생활 체조 원칙  한줄에 점 하나만  찍는다.          Clean Code 가이드의 디미터 법칙을 지키는 것을 의미.        모든 엔티티는 작게  3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.  getter / setter / property를 쓰지 않는다.함수형 프로그래밍      함수형 프로그래밍은 input과 output이 항상 존재 하기 때문에 test하기 쉽다.    클래스 기반 함수를 모으로 메소드 레벨에서 함수형 프로그래밍에 맞게 설계 ?  람다를 쓰는게 중요한게 아니고 변경 가능성이 높은 부분을 인터페이스로 추출 할 수 있는지가 중요하다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 2주차 정리]]></title>
      <url>/dev/2020/04/04/tdd-clean-code-2w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 2주차 정리코드 컨벤션을 지켜라다른 개발자와 협업이나 미래의 나를 위해서라도.공백 라인을 의미있게 사용해라.공백 라인이 메소드의 기능을 나누게 되는 기준이 된다. 추후 리펙토링 시 메소드 기준으로 기능이 나뉜다는것을 알고 공백기준으로 메소드 리펙토링이 가능하다.네이밍객체지향 생활 체조 규칙 5 : 축약하지 말라.적당한 길이의 이름을 찾는데 집중해라.인스턴스 변수의 중복을 줄이고, 개수를 최소화 해라.데이터를 꺼내려고 하지않고 메시지를 던져라비지니스 로직과 ui로직의 분리.테스트 가능한 코드와 불가능한 코드가 섞여 있으면 분리를 해야 한다.어느 부분을 테스트 할 것인가 ?경계값을 기준으로 테스트해야 한다.Test Fixture를 위해서 생성자를 추가하는것이 옳은 일인가 ? 도메인이 DTO역할을 하는 경우라면 생성자를 추가하는것이 허용된다. 해당 경우에는 허용하는 것으로 .. 역할이 여러개이면 클래스 분리.private메소드가 많아지면 테스트를 해야 하는것인가 ? Private 메소드가 중요한 비지니스 역할을 한다면 새로운 클래스로 분리 되어야 한다. 분리 된다면 다른 클래스에서 접근 가능한 메소드가 되기때문에 테스트가 가능하다.TDD이번주 부터는 메소드 분리가 아닌 클래스 분리를 연습 하자모든 원시값과 문자열을 포장한다. 일급 콜렉션을 쓴다.생성자를 중복해 정의할 때는 정적 팩토리 메소드를 사용한다.tdd는 리팩토링이 가장 중요하다.테스트와 production code를 추가할 때 마다 리팩토링을 해야한다.한번에 리팩토링을 하지 않고 테스트 케이스가 추가 될 때 마다 리팩토링을 하는 연습을 해야 한다.todo리스트를 제대로 만드는것이 tdd를 잘하는 방법이다.설게를 안하는것이 아니고 초반에 대략적인 설계가 필요하다.초반 설계시 테스트 가능한 부분과 힘든 부분까지 설계를 한다면 설계를 잘한 것이다.tdd 시작시 인풋과 아웃풋을 결정해야 한다.Getter 를 쓰는순간 없애려고 노력해라 (상태를 가진 데이터를 꺼내는것보다 객체에 메시지를 보내서 일을 시켜라)접근 제어자를 잘 사용해서 클래스 및 메소드의 접근 범위를 한정하는것도 도메인을 지키는 방법이다.   특히 default 접근 제어자는 도메인을 지키는 좋은 방법중 하나이다.토이 프로젝트에선 최대한 조건을 강제해라인덴트 1, 인스턴스 변수 2개 등의 극한의 조건을 걸어라.Q&amp;AVoid method 는 검증하는것만으로도 의미가 존재 하는지 ?-&gt; 존재한다.Void method 내부에서도 인풋과 아웃풋이 있는 부분을 분리할 수 있을것이다. 그부분을 메소드로 분리해서 테스트 가능하다.유효성 검사도메인은 반드시 유효성 검사를 해야 하는것이 맞다. 그렇다고 controller나 다른 레이어에서 유효성검사를 안해도 된다는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Checked Exception과 UnCheckedException의 차이]]></title>
      <url>/dev/2020/04/02/checked-exception-unchecked-exception/</url>
      <content type="text"><![CDATA[  Checked Exception과 UnCheckedException의 차이점 정리 및 실험Checked Exception 과 UnCheckedException의 차이  Checked Exeption          어플리케이션에서 반드시 예외 처리를 해야 한다. 하지 않을시 Runtime Error 가 발생      Transaction Rollback이 되지 않는다.      대표적으로 IO,SQLException이 있다.      try-catch 로 예외를 처리 하거나 상위 메소드로 예외 처리로직을 위임 할 수 있다.        UnCheckedException          어플리케이션에서 예외처리를 강제 하지 않는 에러.      Transaction Rollback 처리      대표적으로 Runtime Exception, NullPointer, IllegalArgumentException 등이 존재 한다.      명시적 예외 처리 로직이 필요하지 않는 에러        두가지 Exception을 나누는 기준은 위 표와 같이 Runtime Exception의 상속 여부 이다.          RuntimeException 을 상속받는 Exception 모두가 Unchecked Exception이라고 할 수 있다.        간단한 예시를 통하여 Unchecked Exception 의 Rollback을 확인해보자.@Transactionalpublic void insertWithUnCheckedException() {    User user = new User("name");    userRepository.save(user);    throw new RuntimeException();}위와 같이 Service 로직에서 데이터를 저장 후 Unchecked Exception 을 던지게 되면 어떤 일이 일어날지 간단한 테스트 실행.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void uncheckedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithUnCheckedException());    }}결과 로그2020-03-24 18:39:02.118  INFO 83948 --- [           main] p6spy                                    : #1585042742118 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdb2020-03-24 18:39:02.134  INFO 83948 --- [           main] p6spy                                    : #1585042742134 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb      위 로그를 보시면 UncheckedException 이 발생하면 rollback 이 정상적으로 일어난 것을 확인 할 수 있습니다.        CheckedException이 발생 하였을때 정말 Rollback이 되지 않을까 ?  마찬가지로 간단한 테스트를 실행해보자.@Transactionalpublic User insertWithCheckedException() {    User user = new User("name");    User save = userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");    }    return save;}User를 저장하고 강제로 Exception을 던져보았습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        User user = userService.insertWithCheckedException();        assertThat(user.getId()).isNotNull();    }}결과 로그2020-03-24 18:41:41.851 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     call next value for hibernate_sequence2020-03-24 18:41:41.861  INFO 83958 --- [           main] p6spy                                    : #1585042901861 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdbcall next value for hibernate_sequencecall next value for hibernate_sequence;2020-03-24 18:41:41.876 ERROR 83958 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:41:41.885 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     /* insert me.study.exceptiontest.domain.User        */ insert         into            user            (name, id)         values            (?, ?)2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [name]2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [BIGINT] - [1]2020-03-24 18:41:41.890  INFO 83958 --- [           main] p6spy                                    : #1585042901890 | took 0ms | statement | connection 4| url jdbc:h2:mem:testdb/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values (?, ?)/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values ('name', 1);2020-03-24 18:41:41.893  INFO 83958 --- [           main] p6spy                                    : #1585042901893 | took 0ms | commit | connection 4| url jdbc:h2:mem:testdb;  위 로그를 보시면 정상적으로 CheckedException이 발생 하였지만 m.s.q.exceptiontest.service.UserService  : throw exception  User 데이터가 저장되는것을 확인 할 수 있습니다.  CheckedException 이 발생 될 때 정상적으로 Rollback을 하기 위한 여러가지 방법이 있지만 저는 명시적인 UncheckedExecption을 던져주는 방식으로 Rollback이 되는지 실행 해보겠습니다.@Transactionalpublic void insertWithCheckedException() {    User user = new User("name");    userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");        throw new RuntimeException();    }}위 코드와 같이 CheckedException 이 던져질 경우 catch에서 명시적인 예외를 다시 던져주는 방식으로 실행 해 보겠습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithCheckedException());    }}결과 로그2020-03-24 18:48:18.409 ERROR 83989 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:48:18.409  INFO 83989 --- [           main] p6spy                                    : #1585043298409 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb;위 로그와 같이 명시적인 에러를 던져줌으로서 정상적으로 Rollback이 되는것을 확인 할 수 있습니다.  Exception의 종류에 따라 트랜젝션 여부가 다르다는것을 알고 있었지만 실제로 어떻게 처리하는지, 정말 Rollback이 안되는지 등에 대한 실행을 통한 결과 검증 과정을 정리 하였습니다. 지금까지 Exception 처리시 별다른 처리를 하지 않고 단순 로그만 남기는 경우가 많이 있었는데 이번 테스트를 통하여 정확한 예외 처리 방법에 대한 학습을 할 수 있었습니다. :)참고  https://cheese10yun.github.io/checked-exception/  https://1.bp.blogspot.com/]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 1주차 정리]]></title>
      <url>/dev/2020/03/29/tdd-clean-code-1w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 1주차 정리TDD - 프로그래밍 의사결정과 피드백 사이의 간극을 의식. 제어하는 기술TDD는 분석기술이며 설계 기술이기도 하다.TDD는 분석과 설계를 잘 해야 한다.  TDD = Test First Development + Refactoring  TDD는 테스트를 먼저 개발하는것이 주된 목적이 아니고 리팩토링이 주된 목적이다.  짧고 작은 단위의 설계를 지속하여 개발하는 방법.      한번에 모든걸 만들지 않고 작은 단위를 만들어 간다.    TDD는 한번에 한가지 만 고민하여 기능을 우선 개발한다.  이후 개발된 기능을 바탕으로 refactoring을 진행한다.      이때 테스트 코드나 테스트 케이스는 추가되거나 수정되지 않아야 한다.    큰단위를 작은 단위로 나눠 빠르게 실패.  피드백을 통해 지속적 개선  달성하기 힘들 것으로 생각하는 일에 도전할 수 있는 용기  의식적인 연습이 필요하다.          학습테스트      단위테스트      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Clean Code 작성법]]></title>
      <url>/dev/2020/03/27/java-clean-code/</url>
      <content type="text"><![CDATA[  해당 포스트는 DDD 세레나데의 강의를 정리하며 작성하였습니다.Java Code 작성 팁  불변객체(Value Object)를 사용하자.          불변객체란 ?  위키 백과 - 컴퓨터 과학에서 가치 객체는 동일성을 기반으로하지 않는 단순 개체를 나타내는 작은 객체입니다.   즉, 두 객체가 동일한 값을 가질 때 동일하며 반드시 동일한 객체 일 필요는 없습니다. 가치 개체의 예는 금액 또는 날짜 범위를 나타내는 개체입니다.      동일한 값을 가질때 동일한 객체임을 보장해주며 객체의 상태를 변경할 될 수 없는 객체이다.      의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용      시스템이 성숙함에 따라 데이터 값을 객체로 대체      밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.      정말 String으로 우편 번호를 표현할 수 있는가?      항상 equals() 메서드를 오버라이드할 것을 권고한다.                  equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java                      일급 컬렉션을 사용하자.          참고 일급 컬렉션 (First Class Collection)의 소개와 써야할 이유      일급 컬렉션 이란 ?                  콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.필터가 이 새 클래스의 일부가 됨을 알 수 있다.필터는 또한 스스로 함수 객체가 될 수 있다.또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.                    public class LottoNumbers {	  private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public LottoNumbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = numbers;    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || number.size() != LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  항상 방어적 복사를 생각하자.          Java 에서는 값을 참조하는 방법이 크게 두가지가 존재                  Call by Reference          Call by Value                    일반적으로 객체간의 값 복사는 Call by Reference 방식으로 통하여 값이 복사 된다.  이 방식으로 값을 복사 하면 위에서 말한 일급 컬렉션이 불변하지 않게 되는 문제점이 있다. 그래서 항상 방어적 복사(DeepCopy)를 생각하는 방식	을 권장한다.      List&lt;Integer&gt; lottoNumbers = new ArrayList&lt;&gt;();lottoNumbers.add(4);lottoNumbers.add(5);lottoNumbers.add(6);lottoNumbers.add(8);lottoNumbers.add(13);lottoNumbers.add(45);Numbers numbers = new Numbers(lottoNumbers);System.out.println(numbers.totalValue());// 81lottoNumbers.add(2);System.out.println(numbers.totalValue());// 83public class Numbers {    private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public Numbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = new ArrayList&lt;&gt;(numbers);        this.numbers = Collections.unmodifiableList(numbers);    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || numbers.size() == LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  setter 보다 의미있는 이름의 메소드를 사용해보자.          객체에 getter 메서드와 setter 메서드를 무조건 추가하는 것은 좋지 않은 버릇      특히 setter 메서드는 객체의 핵심 개념이나 의도를 코드에서 사라지게 한다.      setter 메서드의 또 다른 문제는 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.      도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.      changeShippingInfo() vs setShippingInfo()completePayment() vs setOrderState()  주/부 생성자를 활용해보자.          주 생성자                  모든 상태를 가진 완전한 객체를 생성하는 생성자                    부 생성자                  상태가 완전하지 않은 객체를 생성하는 생성자                    객체를 생성할 때 상태가 완전하지 않은 객체를 생성하는 경우가 있다.  이런 객체들을 생성할 때 마다 객체의 상태를 검사하는 로직을 남발하는 경우가 존재한다.   해당 로직들을 주 생성자에 위임하여 항상 동일한 로직을 타도록 설정 할 수 있다.      public class Menu {    private String name;    private BigDecimal price;    private Long menuGroupId;    private List&lt;MenuProduct&gt; menuProducts;    public Menu(String name, BigDecimal price, List&lt;MenuProduct&gt; menuProducts) {        this(name, price, null, menuProducts);    }    public Menu(String name, BigDecimal price, Long menuGroupId, List&lt;MenuProduct&gt; menuProducts) {        validName(name);        validPrice(price);        validMenuProducts(menuProducts);        this.name = name;        this.price = price;        this.menuGroupId = menuGroupId;        this.menuProducts = menuProducts;    }    private void validMenuProducts(List&lt;MenuProduct&gt; menuProducts) {        if (Objects.isNull(menuProducts) || menuProducts.size() == 0) {            throw new IllegalArgumentException();        }    }    private void validPrice(BigDecimal price) {        if (Objects.isNull(price) || price.compareTo(BigDecimal.ZERO) &lt; 0) {            throw new IllegalArgumentException();        }    }    private void validName(String name) {        if(Objects.isNull(name) || StringUtils.isEmptyOrWhitespace(name)) {            throw new IllegalArgumentException();        }    }}  생성자 보다는 정적 팩토리 메소드를 사용하자.          정적 팩토리 메서드(static factory method) - 기계인간 John Grib        Package By Feature, Not Layer          패키지를 생성하는 전략 크게 두가지로 나뉘어 생성이 가능하다.                  Package by Layer                          Spring에서 일반적으로 사용하는 Controller / Service / Repository 등의 패키지를 최상단 패키지로 설정하여 프로젝트를 구성하는 방식                                Package by Feature                          도메인 중심으로 패키지를 생성하는 방식.                                  각 도메인이 최 상단 패키지가 되어 하위에 api / application / infrastructure / domain 등을 가지게 된다.                  정답은 없다.                                                                        프로젝트의 규모가 커질수록 Package By Layer 의 구조는 복잡성이 증가하게 된다.              반면 Feature중심의 패키지 구조로 되어 있으면 연관성이 있는 패키지들이 새롭게 추가 되기 때문에 기존 패키지에 영향을 미치지 않게 되며  필요한 기능들이 군집해 있기 때문에 다른 패키지들간의 영향을 줄일수 있게 된다.            참고 자료를 보시는것이 더욱 좋습니다 : )      http://www.javapractices.com/topic/TopicAction.do?Id=205      https://medium.com/@ssowonny/package-by-feature-in-clean-architecture-projects-e14d25e3905e      #JAVA/Code]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> Java </tag>
        
          <tag> Clean Code </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 5주차 강의 정리]]></title>
      <url>/dev/2020/03/20/ddd-serenade-5w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 5주차4주차 복습  비즈니스 로직 수행은 어느 곳에 하는 것이 좋을까 ?          도메인 레이어에서 기능을 수행하고 다른 응용 및 표현 레이어에서 해당 기능을 사용한다.        응용 서비스          사용자의 요청에 맞는 도메인 모델을 찾아오고 그 모델의 로직을 위임하는 처리를 한다.        도메인 서비스          응용 서비스와 도메인 서비스를 판단 하는 기준                  두개 이상의 애그리거트가 사용될때          다루고 있는 로직이 위키나 지라에 정리를 해야할 필요성이 있는 경우          두가지 조건을 한줄로 요약하면 도메인 지식이 다른곳으로 흘러가는것을 막아주는 역할을 한다.          도메인 서비스는 어플리케이션 레이어와 도메인 레이어 사이에 위치한다.                      응용 서비스의 구현  vo가 dto로 돌아다녀 외부에 노출된다면 캡슐화가 깨지는것이 아닌가 ?          vo가 dto로 돌아다니는 것은 일종의 trade-off이다.      vo의 접근 제어자를 default로 두어 도메인 패키지 내부에서만 사용할수 있도록 만드는것도 하나의 방법이다.        항상 DTO를 만드는것은 실용적이지 않아 DTO를 대신 할 수 있는 VO를 찾는것도 방법이다.  고수준 모듈 저수준 모듈          고수준 모듈이 저수준 모듈에 의존하는것이 아니고 저수준 모듈이 고수준 모듈에 의존하도록 dip를 적용해야 한다.        클린 아키텍처          안에선 밖을 모르고 밖에선 안을 알수 있는 아키텍처      도메인 모델을 외부로 부터 지키는 것이 중요하다.        anticorruption layer          anticorruption layer 하는 역할이 크다면 별도의 레이어로 만들수도 있고 클래스로도 만들 수 있다.      많은 mapper class assemblr pattern이 등장 하더라도 나의 도메인 모델을 지킬 수 있다.        도메인 서비스 구현 방법          응용 서비스에서 도메인 서비스를 주입 받고 응용서비스 내부에서 메시지를 전달한다.      해당 도메인 서비스에서는 도메인들을 가지고 와서 실제 로직을 실행하는 과정을 거친다.      repository는 domain service에 담고 있다.      repository에서 실행하는 save와 같은 데이터 추가는 실제로 DB에 값이 저장되지는 하지만 도메인 입장에서는 add와 같은 기능을 한다고 생각하여 repository가 infra영역이 아닌 domain 영역에 있다고 본다.      Domain layer가 필요 없는 상황 (하나의 도메인만 사용한다면) application layer에서 처리      도메인 모델에서 에러 같은 경우는 try - catch하여 상위 레이어에 노출되지 않도록 막아준다.                  상위 레이어에서 알 수 있는 에러를 핸들링 할수 있도록 하는 것.                      DTO 가이드          dto를 도메인으로 전환하고 도메인을 dto로 전환하는건 application service에서 담당하는것이 맞다.      dto가 데이터를 담아서 전달 할 수 있는 영역은 application service까지 이다.        모놀리식 아키텍처는 다른 패키지의 서비스를 주입 받아서 사용하지만 마이크로 서비스로 분리 되는 경우 변경이 힘들다.  외부 컨텍스트에서 발생한 예외 또한 내부 컨텍스트에서 이해할 수 있는 에러로 감싸주어야 한다.  infrastructure layer가 anti corruption layer 역할을 할 수도 있다.  exception은 domain 패키지에 위치  anticorruptionlayer 도메인 내부 에그리게잇 폴더에 위치  order - buyer 예시에선 order 에그리게잇이 root가 되었다. 내부에 order , order item entity를 가지고 있고 vo 도 가지고 있다.전술적 설계 - Domain Event  이벤트란 도메인 전문가가 관심을 가질 법한 것들 (단순 조회 제외)  강한 결합  이벤트          이벤트는 어떤 상태가 변경되었다는것이다.      도메인 모델에서 이벤트를 관리 하는 주체는 에그리게잇이 될 수 있다.      이벤트 핸들러는 이벤트에 담긴 주체를 가지고 부가적인 행동을 하게 된다.      스프링에선 application event publisher 가 트랜잭션이 종료될때 이벤트를 발행 해 준다.                  테스트 코드에선 이벤트가 발행되었는지 안되었는지만 확인 하면 된다.                    스프링 이벤트는 기본적으로 한 트랜젝션 내부에선 묶여있다.                  하나가 실패하면 롤백되는 구조이다.          TransactionalEventListener 를 사용하면 트랜잭션이 끝난 후 동작하도록 사용할 수 있다.                    스프링 이벤트를 사용하지 않고 이벤트를 발행 하려면 AbstractAggregateRoot 를 상속 받아 registerEvent()으로 이벤트를 발생할 수 있다. 이떄는 save를 강제로 호출 해줘야 한다.      도메인 내부에 이벤트를 가지고 있어야 한다.        이벤트 소싱          도메인 모델에서 발생하는 모든 이벤트를 기록하는 방법        CQRS          상태를 변경하는 명령과 모델의 상태를 조회하는 모델을 분리한 패턴.      커멘트 패키지와 조회 패키지등으로 분리 할 수 있다.      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[인터페이스와 구현에 대한 정리]]></title>
      <url>/dev/2020/03/18/java-interface-and-implement/</url>
      <content type="text"><![CDATA[  객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 사내공유 하고자 만든 자료입니다.인터페이스와 구현객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 사내공유 하고자 만든 자료입니다.객체란 자기 주도적으로 책임, 협력, 역할을 가지고 있는 상태를 의미한다.여기서 책임이란 어떠한 일을 맡아서 하는 것이다.커피 전문점 도메인을 가지고 인터페이스와 구현에 대해 알아 보자.커피 전문점 도메인은 고객, 바리스타, 커피, 메뉴판등의 객체를 가지고 있다고 가정한다.고객이란 어떤 책임을 가지고 있을까 ?일반적으로 생각 하면 ‘주문’이라는 책임을 가지고 있을 것이다.모든 주문은 고객이 주도적으로 생성하게 될것이고 생성된 주문을 통하여 바리스타는 주문에 해당하는 커피를고객에게 전달하게 된다. 따라서 고객은 주문이라는 책임을 가지고 있는 셈이다.협력이란 ? 고객이 ‘주문’이라는 책임을 가지고 다른 객체에게 주문하라 라는 메시지를 전달 한다.여기서 메시지는 객체간의 의사소통을 하기 위한 방법이다. 여기서 고객은 주문하라 라는 메시지를 통해 바리스타에게 커피를 만들어라고 다시 한번 메시지를 전달하게 될것 이다.결론적으로 커피전문점에서 고객이 커피를 주문하기 위해선 고객과 바리스타간의 협력을 통하여 최종적으로 커피가 주문되게 되니 둘 간의 협력 관계가 형성 되는 것이다.역할이란 ? 역할은 메시지를 책임지는 집합으로 볼 수 있다. 여러 커피전문점을 생각해보자. 어떤 커피전문점에서는 들어오는 커피에 따라서 바리스타의 역할이 세분화 될 수 있다.예를 들면 에스프레소를 책임지는 바리스타, 라떼를 책임지는 바리스타 등으로 바리스타의 역할중 세분화 되어 있는 영역에서 똑같이 커피를 만들어라 라는 책임을 다하고 있는것이다.일반적으로 역할은 추상화 과정에서 나타난다.상위 수준에서의 책임을 쉽고 간단하게 표현하고 설계를 유연하게 만들수 있는 장점이 있다.자율적인 객체객체는 상태와 행동을 함께 가지는 복합적인 존재이며 스스로 판단하고 행동하는 자율적인 존재라는 것이다. 대부분의 프로그래밍 언어는 외부에서 접근을 통제 할 수 있는 접근 제어 메커니즘을 제공한다. 접근 제어를 위해  public, private 와 같은 접근 수정자가 존재한다.객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다. 객체지향의 핵심은 스스로 상태를 관리하고 판단하고 행동하는 자율적인 객체들의 공동제를 구성 하는 것이다.캡슐화와 접근제어는 객체를 두 부분으로 나눌수 있다. 외부에서 접근 가능한 퍼블릭 인터페이스(public interface), 내부에서만 접근 가능한 부분인 구현(implementation)이라고 부른다.캡슐화상태와 행동을 하나의 객체안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위함이다.잘 설계된 캡슐화를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고, 외부에는 상대적으로 안정적인 부분만 공개함으로 변경의 여파를 통제 할 수 있다.변경될 가능성이 높은 부분을 구현이라 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.일반적으로 사용하고 있는 getter / setter를 사용한 캡슐화는 진정한 의미의 캡슐화가 아닌것이 중요하다.간단한 예시를 통하여 인터페이스와 구현에 대해서 알아 보자.public class Customer {    public void order(String menuname, Menu menu, Barista barista) {        MenuItem menuItem = menu.choose(menuname);        Coffee coffee = barista.makeCoffee(menuItem);    }}고객은 order라는 메시지를 통하여 주문이라는 책임을 실행한다.여기서 중요한 점은 order라는 메소드가 public으로 공개 되어 있다는것이다.이로서 다른 누군가는 Customer는 order라는 메시지를 전송할 수 있다라는것을 알 수 있다.내부 구현으로 Menu를 통하여 어떤 커피를 만들어야 하는지 받아 오고 바리스타에게 해당하는 커피를 만들라는 메시지를 전달한다.public class Menu {    private List&lt;MenuItem&gt; menuItems;    public Menu(List&lt;MenuItem&gt; menuItems) {        this.menuItems = menuItems;    }    public MenuItem choose(String menuname) {        return menuItems.stream()                .filter(menuItem -&gt; menuItem.name().equals(menuname))                .findAny()                .orElseThrow(IllegalArgumentException::new);    }}Menu 객체를 살펴보자.여기서 중요하게 봐야할 부분은 choose가 아닌 menuItems를 내부에 상태로 가지고 있다는 것이다. Menu는 MenuItem에 의존하고 있는 상태가 된것이다. 코드를 살펴보면 Menu를 생성할 때 MenuItems를 생성자로 받아 생성하고 있습니다.이렇게 구현한 이유는 MenuItem이 추가 되더라도 다른 객체에서는 추가적인 수정이 필요 없고 오직 MenuItem을 의존하고 있는 Menu 클래스만 수정하여 choose라는 책임을 다하면 되는것 이다.public class MenuItem {    private String menuname;    private BigDecimal price;    private MenuType menuType;    public MenuItem(String menuname, BigDecimal price, MenuType menuType) {        this.menuname = menuname;        this.price = price;        this.menuType = menuType;    }    public String name() {        return menuname;    }    public BigDecimal cost() {        return price;    }    public MenuType menuType () {        return menuType;    }}public enum MenuType {    ESPRESSO, COLDBREW, LATTE}public class Barista {    public Coffee makeCoffee(MenuItem menuItem) {        return make(menuItem);    }    private Coffee make(MenuItem menuItem) {        if(menuItem.menuType().equals(MenuType.ESPRESSO)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.COLDBREW)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.LATTE)) {            //Do SomeThing            return new Coffee(menuItem);        }        throw new IllegalArgumentException();    }}이번 내용에서 가장 중요한 바리스타 클래스 입니다. 바리스타 객체는 커피를 만들어라라는 책임을 가지고 있는 클래스 이며 코드를 보시면 makeCoffee라는 메소드가 public 으로 오픈 되어 있습니다. 실제로 커피를 만드는 로직은 private으로 되어 있는 make라는 메소드에서 진행하고 있는데 이렇게 구현한 이유가 캡슐화를 하기 위해서 입니다. 외부에서는 바리스타는 커피를 만들수 있다 라는것을 알고 있지만 커피를 어떻게, 어떤 방식으로 만드는지는 모르도록 내부에 구현 로직을 private 으로 감싸서 숨긴 예시라고 할 수 있습니다.여기서 public 으로 오픈되어 있는 메소드는 인터페이스이며 private 으로 숨겨둔 메소드가 구현이라고 생각 하시면 될 것 같습니다.이러한 방식의 장점은 마찬가지로 커피를 만드는 방법이 추가 되더라도 커피는 바리스타 객체가 자율적으로 만들 수 있기 때문에 다른 클래스의 코드는 수정을 하지 않아도 된다는 것입니다.public abstract class BaristaI {    public Coffee makeCoffee(MenuItem menuItem) {        //doSomeThing        Coffee make = make(menuItem);        //dosomeThing        return make;    }    protected abstract Coffee make(MenuItem menuItem);}바리스타 클래스를 Template Method 패턴으로 구현하여 깔끔한 코드로 확인 할 수 있다.참조Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> 객체지향의 사실과 오해 </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 4주차 강의 정리]]></title>
      <url>/dev/2020/03/13/ddd-serenade-4w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 4주차3주차 복습  전술적 설계 - ddd lite , building block          특정 디자인 패턴이 필요하다면 building block에 포함되는 것이다.        좋은 객체는 불변한 객체          도메인 주도 설계 빌딩 블록중 불변인 것들을 vo 라고 부른다.      vo는 equals와 hashcode를 재정의 하는것을 권장한다.      생성자 보다는 정적 팩토리 메소드를 사용해라.        Entity          내부에 상태값이 변하는 객체들은 entity로 만들 수 있다.      entity는 식별자를 갖는다.      도메인 모델에 set 메서드 넣지 않기      Aggregate  한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.      공통적으로 사용하는 애그리거트는 baseAggregate과 같이 trade-off할 수 있다.    수많은 aggregate중 root 로 만드는 방법은 외부에서 바라보는지를 확인 하면 된다.  애그리거트 루트는 일관성이 깨지지 않도록 해야한다.          생성자로 엔티티를 만들때 모든 속성을 가지고 있어야 한다.            클라이언트는 애그리거트의 내부 구현이 어떻게 되어 있는지 몰라야 한다.    Aggregate 참조          subentity를 외부에 노출시키면 안된다.              Root entity를 기준으로 repository를 제공해줘야 한다.            두개의 aggregate가 필요하다면 domain service가 도출되어야 한다.      하나의  aggregate에서도 domain service가 발생할 수 있다.        Factory          데이터를 가지고 있는 객체가 일을 하도록 메시지를 던져야 한다.      4주차  계층형 아키텍처          표현영역                  httprequest, response, session을 관리                    응용 서비스                  로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임.          도메인 영역에서 발생시킨 이벤트를 처리.                    도메인 서비스                  로직에 대한 버전 관리를 해야할 필요가 있는 경우 도메인 서비스가 될 수 있다.          두개 이상의 aggregate를 사용하면 반드시 도메인 서비스가 되어야 한다.                          같은 aggregate라도 두개 이상을 사용한다면 도메인 서비스.                                          메서드 파라미터와 값 리턴                  응용 서비스에 데이터로 전달할 파라미터가 두개 이상이면 데이터전달을 위한 별도 클래스를 사용하는것이 편리.          응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법.                    값 검증                  값 검증은 표현영역과 응용 서비스 두 곳에서 모두 수행 할 수 있다.          표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 아이디 중복 여부와 같은 논리적 오류만 검사하면 된다.                    인터페이스는 어느 시점에 생성하는것이 적절한가                  외부와 연동할 가능성이 크거나 연동하고 있는 것은 인터페이스를 만드는 것이 좋다.                      DTO          DTO는 프로세스 간에 데이터를 전달하는 객체가 아니고 구조체 라고 보는것이 맞다.      value object는 dto가 아니다.      value object는 어플리케이션 내부의 요구사항으로 만들어지고 dto는 어플리케이션 외부의 요구사항을 반영한다.      dto에서 entity를 만드는것은 괜찮으나 entity 에서 dto를 만드는것은 불가하다.      domain model everywhere      pure domain model                  항상 dto를 만드는 것은 실용적이지 않다.                          -&gt; vo로 해결 가능한 것은 vo로 해결 해도 된다.              vo는 영역과 관계없이 사용가능하기 때문이다.                                            의존 역전 원칙          고수준 모듈의 의존 문제                  저수준 모듈의 변경에 따라 고수준 모듈의 변경이 불가피 해진다.                    DIP 주의 사항                  추상화 한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치 해야 한다.          실제 구현은 infrastructure에서 구현(저수준)                    육각형, 양파, 클린 아키텍처                  공통된 목적은 내부에 있는 domain layerr를 외부로 부터 숨기고 지키는것이다.          내부는 외부를 모르고 외부는 내부를 몰라야 한다.                      anti corruption layer          외부로부터 내부 도메인 레이어를 지키기 위한 계층        주 생성자 -&gt; 모든 상태를 가지고 있는 생성자  부 생성자 -&gt; 부생성자가 주 생성자를 호출하는 방법  최상단 패키지는 Bounded Context로 나누고 Aggregate은 domain package에서 나누는 방  menu product가 price를 가지도록  infra - product 와 관련된 클래스를 만들고 productservice를 주입 받아 price를 얻는다 ? -&gt; anti corruption layer 만든다]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 3주차 강의 정리]]></title>
      <url>/dev/2020/02/21/ddd-serenade-3w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 3주차2주차 복습  유비쿼터스 언어          유비쿼터스 언어는 회의록, 회의, 코드 등에서 나타난다.      유비쿼터스 언어는 Bounded Context에서만 존재 해야 한다.      코드레벨에서는 유비쿼터스 언어가 검증이 되어야 한다.      검증이 되지 않으면 실패할 가능성이 크다.        용어사전          도메인 주도 설계가 성공하기 위해선 용어 사전을 개발자만 참여하는것이 아닌 프로젝트에 참여하는 모두가 관리 해야 한다.      프로젝트가 커질 시 컨텍스트 별로 용어 사전을 정리 해야 한다. (동일한 용어가 다른 의미를 가질 수 있다.)        모델링          모델링은 소리 내어 읽었을때 어색하지 않아야 한다.        Bounded Context          BC는 서로 다른 관점을 찾는 것이다.      우발적인 중복은 충분한 고민을 해봐야 한다.      하나의 BC는 하나의 팀에서만 관리하는것이 베스트이다.        OOP vs DDD          oop 에서의 상속으로 풀수 있는 문제 라고 하더라도 ddd 에선 context 간 분리가 더 중요하다.     그로 인해 context 내부에 중복이 발생 할 수도 있다.        이벤트 스토밍          단순한 조회 같은 행위는 이벤트가 아닐 수도 있다.      조회를 하여 조회 카운트가 상승했다 와 같은 행위가 이벤트이다.      개발자들은 이벤트 스토밍 도중 기획자나 도메인 전문가 들이 설계를 어렵게 하는 부분에 대해 문제를 제기 할 줄 알아야 한다.        Aggregate          독립된 라이프 사이클을 가지는 무언가        공통된 단어가 나오면 반드시 context를 나눠야 한다.  (최소 context 수)최대 context 개수는 는 aggregate 개수  도메인 주도 설계는 설게 후 구축이 아닌 설계와 구축이 병렬적으로 진행 되어야 한다.전술적 설계 - ENTITY 와 VALUE OBJECT  Entity는 지속적으로 상태를 관찰해야할 필요가 있을때 만든다.  내부적인 상태가 변하더라도 동일한 객체라고 인식을 해야 할 때 식별자를 만들고 Entity로 만든다.  도메인 모델에 setter 가 있으면 해당 도메인 모델은 완전한 상태가 아니게 된다.          버릇처럼 쓰는 setter 는 남발하면 안된다.        모든 객체는 불변 객체가 가장 좋다.          새로운 타입의 객체를 만들어서 유효성 검사 로직을 옮긴다.      객체 끼리의 책임을 나누는 방법.      분리 된 객체는 만들어지거나 실패하거나 원자성을 보장한다.      값 객체 (value object- 불변 객체)는 동일성과 동등성을 보장해야 한다.                  가변 객체는 값이 바뀜에 따라 의미가 달라 질 수 있다.          불변 객체는 값이 바뀜에 따라 새로운 불변 객체를 만들어 내야 한다.          불변 객체는 계속 생성이 되면 메모리 부하가 일어나지 않나 ?                          -&gt; 컴퓨팅 파워와 GC를 믿어야 한다.                                          불변 객체                  포함 되고 있는 모든 값들을 final 로 만든다.          1 + 1 = 2 가 아닌 new int(2)          리스트 같은 멤버 변수는 final을 사용해도 값이 바뀔수 있어서 의식적인 방어적 복사가 필요하다.                    AGGREGATE  엔티티와 ValueObject (관련 객체)가 모여있는 군집.  반장이라는 개념이 있다 (루트 엔티티)  Bounded Context &gt; Context &gt; AGGREATE  동일한라이프 사이클을 가진것을 하나의 AGGREGATE로 묶는다.          ex) 자동차 인스턴스가 사라지면 내부에 속한 핸들 및 바퀴와 같은 인스턴스도 같이 사라져야 한다.        하나의 Aggregate에 속하면 다른 Aggregate에는 속하지 못한다.  정리 하면 많은 엔티티들을 동일한 라이프 사이클로 묶어둔 군집  Aggregate Root          외부에선 해당 aggregate와 대화 하기 위해선 Root에게 요청을 해야 한다.      Aggregate Root 도 하나의 엔티티 이기 때문에 내부에 상태를 가지고 있다.      서로 다른 Aggregate와 대화 하기 위해선 반드시 Aggregate Root를 거쳐야 한다.      내부에 어떤 상태를 가지고 있는지 외부에서는 알지 못한다 (캡슐화)        두개 이상의 엔티티가 하나의 Aggretate에 있으면 어떤걸 Root로 할까 ?          Aggregate Root 가 될 수 있는 기준은 Global 식별자(외부에서 참조 하고 있는 식별자) 를 가지고 있는것. 따라서 Order가 Root      로컬 식별자 를 가지고 있으면 루트가 될 수 없다.        정리 하면 글로벌 식별자를 가지고 있어야 루트 에그리게잇이 될 수 있다.  Aggregate 참조          직접 참조를 허용하면 편리함을 오용한다.      ID를 이용한 간접 참조를 권장한다.                  복잡도를 낮출 수 있다.                    같은 Aggregate 에선 직접 참조 해야 한다.      Repository  Repository 는 구현을 위한 도메인 모델.  Aggregate 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.  리포지토리는 Aggregate(Root)단위로 존재하며 테이블 단위로 존재하는 것이 아니다.          리포지토리는 Aggregate을 위한 컬렉션으로 생각하면 된다.      Service  어플리케이션 서비스와 도메인 서비스는 다르다.  여러 도메인이 가진 로직들을 하나의 서비스에서 처리 하기 위한 레이어.  도메인 서비스라는 것은 엔티티, vo, repository를 만든 상태에서 정책 또는 로직을 특정 애그리게잇의 행위로 지정하기 어려운것들.  객체 지향이 아닌 절차 지향적인 로직들을 도메인 서비스로 분리해서 특별하게 관리 할 수 있다.  도메인 서비스와 어플리케이션 서비스는 상태값을 가지고 있지 않다는것에선 유사하지만 서로 다루는 서비스 영역이 다르다.Factory  연관된 Aggregate에서 생성 해보자.          ex) 좋은 모델링 - LadderGame 이 종료되야 GameResult 생성                  사다리게임이 끝나야 게임 결과를 생성한다 라는것은 게임 결과는 게임을 통해서 알수 있다는 비즈니스 로직을 한눈에 알수 있는것이다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 2주차 강의 정리]]></title>
      <url>/dev/2020/02/14/ddd-serenade-2w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 2주차전략적 설계유비쿼터스 언어 - 개발자와 도메인 전문가가 공통적으로 이해 할수 있는 영역의 언어.  모든 상황(회의, 코드, 도메인…)에서 사용하는 언어 (언제, 어디에서나)  기획자나 개발자는 모두 동일하게 이해할 수 있는 언어를 사용해야 한다.  용어사전을 정의 하고 항상 유지 해야 한다.          용어 사전은 죽은 문서가 될 가능성이 많다.        유비쿼터스 언어를 가장 잘 검증해주는 곳은 코드레벨 이다.          개발자의 입장에선 코드레벨에 유비쿼터스 언어가 존재하는것은 좋다.      기획자와 디자이너도 볼 수 있도록 용어가 추가 될 시 용어 사전을 업데이트 해야한다.        용어 사전이란 유비쿼터스 언어를 정리 해둔 사전이다.          프로젝트에 참여하는 모두가 알고 관리 해야한다.      효과적인 모델링  RouteService 는 RouteSecification 만족하는 plan을 찾는다.          개발자는 RouteService 에 RouteSecification 전달하면 plan return 이라고 해석이 된다. Ex ) 환불은 환불정책을 통해서 환불금액이 결정된다.      한팀, 한 언어  사업팀도 모델링을 이해하지 못한다면 모델링이 잘못된 것이다.Bounded Context (문맥 경계)  도메인 별로 용어사전이 다르기때문에 동일한 용어를 다른 도메인에서 사용하면 안된다.  모델은 특정한 문장(문맥)에서 완전한 의미를 가지게 된다.  동일한 단어가 발생하면 Bounded Context 나누기 가장 좋은 상태이다  Ex) 피자가게있는 피자, 쓰레기통에 있는 피자          피자라는 언어를 사용하지만 문맥에 따라서 피자의 의미가 다르다.      좋은 Bounded Context  하나의 Bounded Context는 하나의 팀만 관리 해야 한다.          의견 마찰 및 도메인 영역의 마찰을 줄이기 위해.      하나의 팀이 여러 Bounded Context는 관리 할 수 있다.        각각의 Bounded Context는 각각의 개발 환경을 가질 수 있다.          명확히 구분되는 경계를 그엇기 때문이다.      MSA로 가는 기초.      어떻게 경계를 나눌것인지를 먼저 생각 해야 한다.      Context Map  컨텍스트 맵은 상호 교류하는 시스템의 목록 제공 및 의사소통의 촉매 역할을 한다.  Upstream : 데이터 제공. (Api, Event)  DownStream : 데이터 수신.프로젝트와 조직 관계  파트너십 : 두 context가 하나의 트랜잭션으로 묶여있다.  공유 커널 : 상호 의존하는 공유 모델을 관리한다.  고객 - 공급자(costomer - surpplier) : 업스트림(서버 : 공급자) : 다운스트림(클라이언트 : 고객)으로 단방향 의존한다.  순응주의자(Ex_Open API) : 업스트림(서버)가 모든것을 제어한다.  오픈 호스트 서비스 : REST/API, RPC, Socket  분리된 방법 : 의존 없음  큰 진흙공 : 안티 패턴DDD vs OOP  Context 마다 서로 유비쿼터스 언어를 다른 도메인으로 인식한다.  OOP는 상속이나 재활용성을 위해서 공통된 데이터를 공유하는 것을 중요시  DDD는 도메인 분리를 중시DDD가 성공할 수 있는 전제 조건  DDD는 현업의 절대적인 도움이 필요하다.  이해관계자의 스폰서십이 적극 필요.이벤트 스토밍  정의          도메인 전문가와 개발자를 학습 과정에 참여시키기 위한 빠른 설계기술      비즈니스 및 비즈니스 프로세스에 중점을 둔다.                  클래스와 데이터베이스가 아닌 이벤트와 비즈니스 프로세스에 중점을 둔다.                    코드를 없애고 모든 사람을 동일한 수준으로 만드는 시각적 접근      Aggregate  이벤트 스토밍 중 같은 단어가 중복적으로 발생하면 집합으로 만든다.  Aggreate 하나의 하나의 엔티티를 가지는것이 좋지만 항상 지켜야 하는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring JPA DB Master / Slave 적용시 주의할 점]]></title>
      <url>/dev/2020/01/24/jpa-replication-issue/</url>
      <content type="text"><![CDATA[스프링 JPA를 사용하면서 데이터 베이스 이중화를 하는 경우에 크게 두가지 방법으로 구현한다. 첫번째는 AOP 를 이용하여 쿼리 타이밍에 특정한 Datasource를 불러오는 방법. 두번째는 Transaction의 Readonly 속성을 감지하여 이중화. 지금 진행중인 프로젝트에서 두번째 방법으로 데이터베이스 이중화를 설정하였지만 생각하지 못한 문제점이 발생. 원인파악 및 최소한의 해결 방법을 정리.  문제점          DataSource를 여러개를 사용하기 때문에 일반적으로 스프링 JPA 설정으로 데이터소스를 만들수 없다. 커스텀한 데이터 소스들을 서버가 실행될때 등록하여 실행한다.      위 방법을 사용시 스프링에서 제공해주는 기본 설정을 사용하지 못하여 @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 와 같이 기본설정을 제거 하는 코드가 필요.      기본설정을 제거 하여 Entity Manager룰 새롭게 등록 해주어야 했다.      LocalContainerEntityManagerFactoryBean 를 사용하여 EntityManager를 등록 하니 아무런 설정들이 없는상태.      스프링 JPA를 사용하면 hibernate naming 전략이 snake case로 설정된다. 하지만 자동설정을 못하니 naming 전략이 camel case로 설정 되어 실행되고 있었다.      문제점을 해결하기 위해 property에 naming 전략을 정의 해봤지만 정상적으로 실행되지 않았다. 구글링 결과 아래 코드를 사용하여 해결할 수 있었다.            entityManagerFactoryBean.setDataSource(dataSource());    entityManagerFactoryBean.setPackagesToScan("com.my.pakage");    entityManagerFactoryBean.setJpaVendorAdapter(vendorAdapter);    HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;();    properties.put("hibernate.physical_naming_strategy", "org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy");    entityManagerFactoryBean.setJpaPropertyMap(properties);                      남은 문제          스프링 자동 설정이 정확히 어떤것들을 설정해 주는지 모르니 기본적으로 사용하던 설정들중 어떤것들이 빠져 있는지 확인이 필요하다.      가능하다면 스프링에서 제동해주는 자동설정을 그대로 사용하고 싶기 때문에 방법을 조금더 찾아 볼 예정.        문제 해결 추가.          스프링 자동 설정중 테이블 네이밍 설정이 빠져 있는것을 확인. hibernate.implicit_naming_strategy / org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy 추가.      스프링에서 제공하는 자동 설정이 어떤것들이 있는지 라이브러리에서 확인. org.springframework.boot.autoconfigure.orm.jpa 해당 패키지 아래 jpa, hibernate autoconfiguration을 확인할 수 있다.      개발환경  스프링 부트 2.2.2  스프링 데이터 JPA 2.2.2]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> JPA </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
