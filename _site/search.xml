<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[스프링 프레임워크 핵심 정리]]></title>
      <url>/dev/2020/06/05/spring-framework/</url>
      <content type="text"><![CDATA[  백기선님 강의 스프링프레임워크 핵심 기술 정리 노트작성중인 문서입니다.IoC 컨테이너스프링 IoC 컨테이너와 빈Inverse of Controll : 의존 관계 주입(Dependency Injection)이라고 하며 어떤 객체가 사용하는 의존객체를 직접 생성하지 않고외부로부터 주입 받아 사용하는 방법의존 관계 주입에 대한 장점을 더 알아보시려면 Open Close Principal에 대하여 공부해보시는 것을 추천 드립니다.  스프링 IoC 컨테이너          BeanFactory : 스프링 빈 컨테이너에 접근하기 위한 최상위 인터페이스      애플리케이션 컴포넌트의 중앙 저장소      빈 설정소스로 부터 빈 정의, 빈을 구성하고 제공하는 역할을 한다.        Bean이란 ?          스프링 IoC 컨테이너가 관리하는 객체      장점                  의존성 관리          스코프                          싱글톤 : 흔히 알고 있는 싱글톤 패턴과 같이 하나만 생성              프로포토 타입 : 빈이 생성될 때 마다 매번 다른 객체를 생성하는 방법                @Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)                                                                          ApplicationContext          BeanFactory를 상속받고, 스프링에서 제공하는 다양한 기능을 사용할 수 있는 인터페이스        public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,    MessageSource, ApplicationEventPublisher, ResourcePatternResolver                    메시지 소스 처리 (i18n)      이벤트 발생 기능      리소스 로딩 기능      …      ApplicationContext와 다양한 빈 설정 방법  스프링 IOC 컨테이너의 역할          빈 인스턴스 생성      의존 관계 설정      빈 제공        ApplicationContext          ClassPathXmlApplicationContext : Class Path에 정의되어 있는 파일을 읽어 빈을 생성      AnnotationConfigApplicationContext : Annotation 기반 빈 생성        빈 설정          빈 명세서      빈에 대한 정의를 담고 있다.                  이름          클래스          스코프          생성자 (Constructor)          프로퍼트 (Setter)                      컴포넌트 스캔          설정 방법                  XML - context:component-scan          java - @ComponentScan                    특정 패키지 이하의 모든 클래스 중 @Component 애노테이션을 사용한 클래스를 빈으로 등록      @Autowire필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다.  @Autowired          required : 기본값이 true 이기 때문에 어플리케이션 구동 시 주입할 빈을 찾지 못하면 어플리케이션이 실행되지 않는다.        현재는 @Autowired를 통한 빈 주입방식 보다는 생성자를 사용한 빈 주입 방식을 사용해야한다.  사용 할 수 있는 위치          생성자 (스프링 4.3 부터는 생략 가능)      세터, 필드        경우의 수          해당 타입의 빈이 없는 경우 - 실패      해당 타입의 빈이 한 개인 경우      해당 타입의 빈이 여러 개인 경우                  빈 이름으로 시도                          같은 이름의 빈을 찾으면 해당 빈 사용                                  같은 이름을 못 찾으면 실패                                                              @Primary          해당 타입의 빈을 모두 주입          @Qualifier (빈 이름으로 주입)                    동작 원리                  BeanPostProcessor                          빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스              postProcessAfterInitialization, postProcessBeforeInitialization 인터페이스를 제공한다.                                AutowiredAnnotationBeanPostProcessor                          BeanPostProcessor를 구현한 클래스 이며 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기.              that autowires annotated fields, setter methods, and arbitrary config methods                                          @Component와 컴포넌트 스캔  컴포넌트 스캔의 주요 기능          스캔 위치 설정      필터 : 어떤 애노테이션들을 스캔할지 또는 하지 않을지        @Component 종류          @Repository      @Service      @Controller      @Configuration                  tmi : Repository나 Service같은 애노테이션 이름은 에릭 에반스의 DDD에서 유래되었다고 적혀있다.                      동작원리          @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보      실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨.      빈 스코프  Scope          Singleton - 기본      ProtoType - 모든 요청에서 새로운 Bean을 생성한다.                  Request          Sesseion          WebSocket          …                    https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html        프로토 타입 빈이 싱글톤 빈을 참조 하면 ?          정상 실행        싱글톤 빈이 프로토 타입 빈을 참조하면 ?          프로토 타입 빈이 업데이티 되지 않는다.      업데이트 하려면                  scoped-proxy          Object-Provider          Provider (표준)                    https://www.baeldung.com/spring-inject-prototype-bean-into-singleton        싱글톤 객체 사용시 주의할 점          상태값 공유      ApplicationContext 초기 구동시 인스턴스 생성      Environment 1부 - Profile프로파일과 프로퍼티를 다루는 인터페이스  ApplicationContext extends EnvironmentCapable      public interface EnvironmentCapable {      Environment getEnvironment();  }        프로파일          빈들의 그룹      Environment의 역할은 활성화 할 프로파일 확인 및 설정        프로파일 유즈케이스          테스트 환경에서는 A라는 빈 사용, 배포 환경에서는 B라는 빈을 사용하고 싶다.      서비스 환경에만 등록 하기 위한 빈 설정        프로파일 정의하기          Class        @Configuration @Profile(“test”)@Component @Profile(“test”)                    Method        @Bean @Profile(“test”)                      프로파일 설정하기          -Dspring.profiles.avtive=”test,A,B,…”      @ActiveProfiles(“test”)        프로파일 표현식          !, &amp;, | 와 같은 표현식으로 여러가지 경우를 계산할 수 있다.      Environment 2부 - Property  프로퍼티란 ?          다양한 방법으로 정의할 수 있는 설정값      Environment의 역할은 프로퍼티 소스 설정 및 값 가져오기        프로퍼티 우선순위          StandardServletEnvironment의 우선순위                  ServletConfig 매개변수          ServletContext 매개변수          JNDI (java:comp/env/)          JVM 시스템 프로퍼티 (-Dkey=”value”)          JVM 시스템 환경 변수 (운영 체제 환경 변수)                      @PropertySource          Environment를 통해 프로퍼티 추가하는 방법        스프링 부트의 외부 설정 참고          기본 프로퍼티 소스 지원 (application.properties)      프로파일 까지 고려한 계층형 프로퍼티 우선순위 제공      MessageSource다양한 언어 지원기능을 제공하는 인터페이스  ApplicationContext extends MessageSource        public interface MessageSource {      @Nullable        String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);      ...    }        스프링 부트를 사용한다면 별다른 설정 필요없이 message.properties를 사용할 수 있음.          messages.properties      messages_ko_kr.properties        Reloading 기능을 제공하는 MessageSource      @Bean  public MessageSource messageSource() {    var messageSource = new ReloadableResourceBundleMessageSource();    messageSource.setBasename("classpath:/messages");    messageSource.setDefaultEncoding("UTF-8");    messageSource.setCacheSeconds(3);    return messageSource;  }      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[테스트 코드를 작성하는 다양한 방법]]></title>
      <url>/dev/2020/06/02/test-code/</url>
      <content type="text"><![CDATA[  테스트 코드를 작성하는 다양한 방법테스트 코드를 작성하는 다양한 방법Spring Boot 2.2.X 버전 부터 기존에 사용하던 Junit4 가 아닌 Junit5가 기본 디펜던시로 추가 되었습니다.Junit4를 사용하지 못하는건 아니지만 스프링이 Junit5를 완전히 지원한다는 이야기니 왠만하면 Junit5를 사용합시다.테스트 코드를 작성하는 3가지 방법을 소개 하나 각 방법에 대하여 깊은 이해가 있지 않아 맛보기 식으로 공유해드리겠습니다.우선 Junit5 에서는 @RunWith(SpringRunner.class) 라는 애노테이션이 필요 없어졌습니다.대신 Extend 기능을 활용해서 필요한 디펜던시를 추가할 수 있습니다.BeforeAll, BeforeEach 등의 애노테이션을 사용해서 테스트 메소드 실행전 필요한 객체를 생성 하도록 변경되었습니다.주로 사용하는 기능  Setup 기능 :  BeforeEach , BeforeAll 등의 애노테이션으로 테스트 시작 전 필요한 데이터를 설정 할 수 있음. IntelliJ 에서 지원.          BeforeAll 같은 경우 Junit4에서는 지원하지 않던 Static한 데이터 공유가 가능함.        DisplayName  : 테스트의 이름을 표시 할 수 있는 기능.  ParameterizeTest  : 테스트 실행시 필요한 파라미터를 전달하여 @ValueSource사용 실행이 가능함.  ActiveProfile : 테스트 프로퍼티를 별도로 관리할 경우 테스트 프로파일 설정.그 외로 새롭게 사용할 수 있는 기능들은 Docs를 확인해주시길 바랍니다.JUnit 5 User GuideSpringBootTest 를 이용한 컨트롤러 통합 테스트@SpringBootTest 애노테이션을 테스트 환경에서 사용할 시 SpringBoot Application이 구동되어 등록되어 있는 빈을 전부 로드하게 됩니다.이로 인해서 테스트는 등록된 빈을 사용해서 모든 로직등 실제 사용하는 빈을 통하여 실행되게 됩니다.통합 테스트MockMvc 을 사용하기 위해서 @AutoConfigureMockMvc 애노테이션을 등록합니다.MockMvc 객체는 테스트 코드에서 Http요청을 보낼수 있도록 도와주는 객체 입니다.슬라이싱 테스트  @DataJpaTest : JpaRepository 테스트 시 사용  @EnableWebMvc : Controller 테스트…  참고 : 테스트 코드에서 @Transaction애노테이션을 사용할 경우 기본 Rollback정책이 True이므로 Rollback하지 않는 데이터를 확인 하기 위해선 false로 지정 해줘야 합니다.Model 검증@Test@DisplayName("index 페이지 정상 작동")public void indexPage() throws Exception {    ResultActions resultActions = mockMvc.perform(get("/index"))            .andDo(print())            .andExpect(status().isOk());    MvcResult mvcResult = resultActions.andReturn();    Map&lt;String, Object&gt; model = 	mvcResult.getModelAndView().getModel();    assertThat(model.get("facebookAppId")).isNotNull();    assertThat(model.get("kakaoAppId")).isNotNull();    assertThat(model.get("s3Uri")).isNotNull();    assertThat(model.get("tagManagerCode")).isNotNull();    assertThat(model.get("host")).isNotNull();}API 검증@Test@DisplayName("상품 정상 생성")void create() throws Exception {    String productName = "간장치킨";    BigDecimal price = BigDecimal.valueOf(17000);    Product product = createProduct(productName, price);    mockMvc.perform(post("/api/products")            .contentType(MediaType.APPLICATION_JSON)            .content(objectMapper.writeValueAsString(product)))            .andDo(print())            .andExpect(status().isCreated())            .andExpect(header().exists(HttpHeaders.LOCATION))            .andExpect(jsonPath("id").exists())            .andExpect(jsonPath("name").value(productName))            .andExpect(jsonPath("price").value("17000.0"))            ;}Mockito 를 이용한 단위 테스트특정 객체를 Mocking하여 단위 테스트를 하기 위해선 일반적으로 Mockito를 활용하여 테스트 합니다.Mocking을 하는 이유는 개인적으로는 단위 테스트를 정확하게 하고자 함에 있다고 생각합니다.여기서 말하는 정확한 단위 테스트는 예를 들면 Service Layer를 테스트 할때 Dao (Repository) 에서 발생하는 이슈가 테스트에 영향을 끼치지 않게 함에 있습니다.Service Logic 을 정확히 테스트 하고 Repository는 따로 Repository 테스트를 만들어서 테스트 함을 권장하고 있습니다.Mocking을 통한 테스트를 작성하려면 @ExtendWith(MockitoExtension.class) 애노테이션을 사용하면 됩니다.@Mock // 객체 Mockingprivate MenuGroupDao menuGroupDao;@InjectMocks // Mock 객체 주입private MenuGroupBo menuGroupBo;위 코드와 같이 Mock객체를 주입 받아 테스트를 실행할 객체를 설정합니다.Mocking 된 객체는 Stubbing을 통하여 객체의 행동을 조작할 수 있습니다.given(menuGroupDao.findAll()).willReturn(menuGroups); // BDD stylewhen(menuGroupDao.findAll()).thenReturn(menuGroups);given또는 when ~ 메서드를 사용하여 객체의 행동을 조작합니다.조작한 행동을 통하여 원하는 결과가 나오는지 확인을 할 수 있습니다.샘플코드@DisplayName("테이블 착석 상태를 비움으로 변경")@Testvoid changeEmpty() {    OrderTable requestOrderTable = new OrderTableBuilder()            .setEmpty(true)            .build()            ;    OrderTable orderTable = new OrderTableBuilder()            .setEmpty(false)            .setId(1L)            .build()            ;    when(orderTableDao.findById(orderTable.getId())).thenReturn(Optional.of(orderTable));    when(orderDao.existsByOrderTableIdAndOrderStatusIn(orderTable.getId(),            Arrays.asList(OrderStatus.COOKING.name(), OrderStatus.MEAL.name()))).thenReturn(false);    when(orderTableDao.save(orderTable)).thenReturn(orderTable);    OrderTable changedOrderTable = tableBo.changeEmpty(orderTable.getId(), requestOrderTable);    assertThat(changedOrderTable.isEmpty()).isTrue();}많은 기능이 존재함으로 역시나 문서를 확인 합니다.Mockito (Mockito 3.2.4 API)Fake Object 를 이용한 단위 테스트Fake Object 라는 개념이 혼란 스러울수 있습니다.이 개념은 Mocking 과 비슷하면서도 다른 개념이라 아직 제대로 이해하지 못하였습니다.Fake Object 를 사용하는 이유에 대하여 설명드리자면 Mocking을 통한 테스트는 실제 로직이 어떻게 돌아가는지 다 알고 있는 상태여야 합니다. 그래서 원하는 결과값을 (행위에 대한 결과)를 받을수 있도록 Stubbing 합니다. 일명 Whitelist Test 라고 할 수 있습니다.반면에 Fake Object를 사용하면 어떤 로직이 실행되는지 전혀 알 필요가 없고 가짜 객체를 통한 실행 결과만 받을 수 	있으면 테스트를 작성 할 수 있게 됩니다.샘플코드private ProductDao productDao = new FakeProductDao();private ProductBo productBo;@BeforeEachvoid setUp() {    productBo = new ProductBo(productDao);}@DisplayName("상품을 등록 할 수 있다")@Testvoid create() {    //given    Product expected = new Product();    expected.setId(1L);    expected.setName("치킨");    expected.setPrice(BigDecimal.valueOf(16_000L));    //when    Product actual = productBo.create(expected);    //then    assertThat(actual).isNotNull();    assertThat(actual.getName()).isEqualTo(expected.getName());    assertThat(actual.getPrice()).isEqualTo(expected.getPrice());}public class FakeProductDao implements ProductDao {    private Map&lt;Long, Product&gt; entities = new HashMap&lt;&gt;();    @Override    public Product save(Product entity) {        entities.put(entity.getId(), entity);        return null;    }    @Override    public Optional&lt;Product&gt; findById(Long id) {        return Optional.ofNullable(entities.get(id));    }    @Override    public List&lt;Product&gt; findAll() {        return new ArrayList&lt;&gt;(entities.values());    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Test </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringSecurity-WithSecurityContextFactory 소개]]></title>
      <url>/dev/2020/05/23/spring-security-with-security-context-factory/</url>
      <content type="text"><![CDATA[  스프링 시큐리티를 사용하여 테스트 코드를 작성하는 경우 Authentication 정보를 자동으로 담아주지 못하여 테스트 코드 작성이 힘들어지는 경우가 있다. 이런경우에 테스트코드 작성을 편하게 할 수 있는 방법을 소개 합니다.SpringSecurity-WithSecurityContextFactory 소개  해당 기능은 백기선님의 강의(스프링과 JPA기반 웹 애플리케이션 개발)를 참고 하였습니다.샘플 프로젝트는 Spring Boot + JPA + Spring Security 로 구성되어 있습니다.샘플 코드테스트는 서비스 및 도메인의 단위 테스트가 아닌 통합 테스트를 진행한다고 가정합니다.@Transactionalpublic CreateResponse create(CreateRequest createRequest) {    Board board = createRequest.toEntity();    Board savedBoard = boardRepository.save(board);    return new CreateResponse(savedBoard);}단순히 Board Entity를 저장하는 기능을 제공하는 서비스 코드 입니다.위 코드를 검증하기 위하여 Test 를 작성할 경우 일반적인 환경에서는 정상적으로 동작하겠지만, Security가 포함된다면 예기치 못한 이슈가 발생할 수 있습니다.@Overrideprotected void configure(HttpSecurity http) throws Exception {    http.csrf()            .disable()        .authorizeRequests()            .mvcMatchers("/sign-up").permitAll()        .anyRequest()            .authenticated()        .and()        .formLogin()        .and()        .httpBasic();}Security 설정입니다.  /sign-up 을 제외한 모든 api는 인증된 사용자만 접근이 가능하도록 설정 해둔 경우 위 코드를 검증하기 위해선 몇가지 방법이 존재할 수 있습니다. Spring Security Reference를 보면 아래와 같은 기능들을 제공해주고 있습니다.https://docs.spring.io/spring-security/site/docs/current/reference/html5  @WithMockUser 사용  @WithUserDetails 사용  @WithSecurityContext 사용하나씩 살펴보면 내용이 길어지므로 레퍼런스를 확인해주시면 될것 같습니다. 간단하게 요약하자면 Security Filter를 통과 하기 위해선 위 2가지 기능만 사용하면 통과 할 수 있지만 지금 살펴볼 기능은 3번째 기능을 사용해야 편하고 간단하게 테스트 코드를 작성할 수 있습니다.@MappedSuperclass@Getterpublic class BaseEntity extends BaseTimeEntity {    @Column(updatable = false)    private Long createdBy;    private Long lastUpdatedBy;    @PrePersist    public void prePersist() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        createdBy = userAccount.getAccount().getId();        lastUpdatedBy = userAccount.getAccount().getId();    }    @PreUpdate    public void preUpdate() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        lastUpdatedBy = userAccount.getAccount().getId();    }}위 코드와 같이 Entity가 저장되거나 수정되는 경우 자동으로 Authentication에서 값 저장하는 코드가 존재한다면, 테스트코드가 동작할 때 Authentication객체가 필요하게 됩니다.간단하게 생각하자면, 테스트를 실행하기전 Authentication객체를 만들고, SecurityContextHolder에 담아 테스트를 실행하면 되지만, 모든 테스트 클래스에서 중복된 코드가 발생하게 될것이므로 정신건강에 좋지 않을것 같습니다.이러한 기능을 간편하게 애노테이션으로 정의하여 사용하는 WithSecurityContextFactory 를 사용해 봅시다.@Retention(RetentionPolicy.RUNTIME)@WithSecurityContext(factory = WithAccountSecurityContextFactory.class, setupBefore = TestExecutionEvent.TEST_EXECUTION)public @interface WithAccount {    String value();}우선 WithSecurityContext를 정의한 애노테이션을 작성합니다.@RequiredArgsConstructorpublic class WithAccountSecurityContextFactory implements WithSecurityContextFactory&lt;WithAccount&gt; {    private final AccountService accountService;    @Override    public SecurityContext createSecurityContext(WithAccount withAccount) {        String username = withAccount.value();        String email = username + "@gmail.com";        String password = "password";        AccountCreateRequest accountCreateRequest = new AccountCreateRequest();        accountCreateRequest.setEmail(email);        accountCreateRequest.setPassword(password);        accountCreateRequest.setNickname(username);        accountService.saveAccount(accountCreateRequest);        UserDetails userDetails = accountService.loadUserByUsername(email);        Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails,                userDetails.getPassword(), userDetails.getAuthorities());        SecurityContext context = SecurityContextHolder.createEmptyContext();        context.setAuthentication(authentication);        return context;    }}그후 WithSecurityContextFactory을 구현한 클래스를 만든 뒤, Authentication객체를 생성, SecurityContext에 담아주는것으로 구현이 끝납니다.사용하는 방법도 간단합니다.@DisplayName("보드 조회 - 단건")@WithAccount("dongchul")@Testvoid findBoard() throws Exception {    CreateRequest createRequest = new CreateRequest();    createRequest.setTitle("title");    boardService.create(createRequest);    mockMvc.perform(get(BoardApiController.BOARD_URI + "/1"))            .andDo(print())            .andExpect(status().isOk())            .andExpect(jsonPath("title").exists());}위와 같이 테스트 코드 실행시 만들어둔 애노테이션을 사용하기만 하면 테스트가 정상적으로 실행됩니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Security </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[책임 주도 설계 정리]]></title>
      <url>/dev/2020/05/15/grasp/</url>
      <content type="text"><![CDATA[  책임 주도 설계 정리, 작성중입니다.책임 주도 설계 흐름  시스템이 사용제에게 제공해야하는 기능인 시스템 책임을 파악한다.  시스템 책임을 더 작은 책임으로 분할한다.  분할한 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.  객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.  해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.디미터 법칙  객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 방법.  오직 하나의 도트(.)만 사용해라.  디미터 법칙에 따르면 훌륭한 메시지는 객체의 상태에 관해 묻지 말고, 원하는 것을 시켜야 한다라는 사실을 강요한다.          묻지말고 시켜라(Tell. Don’t Ask)        디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.          객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 경우이다. (Stream)      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[This 와 Super에 대한 오해]]></title>
      <url>/dev/2020/05/10/java-this-and-super/</url>
      <content type="text"><![CDATA[  오브젝트(조영호님)책을 보며 정리한 내용, 작성중입니다.Java에서 This 란 ? this는 인스턴스의 자기 자신을 의미한다. this.은 주로 필드(전역변수)와 메소드 또는 생성자의 매개변수가 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용한다.자기 자신을 의미한다 -&gt; Self 참조값을 가진다.[image:691E34BC-B312-4128-986B-E438E22D6657-313-00013C90DB2EC097/C225693B-BF77-4EA2-8E73-BE2039800B75.png]  Java에서 Super란 ?super는 자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다. 클래스 내의 멤버변수와 지역변수의 이름이 같을 경우 구분을 위해 this를 사용하듯이 부모 클래스와 자식 클래스의 멤버의 이름이 같을 경우 super를 사용합니다. this와 super는 인스턴스의 주소값을 저장하는데 static 메서드(클래스 메서드)와는 무관하게 사용됩니다.출처: https://freestrokes.tistory.com/72 [FREESTROKES DEVLOG]상속받은 멤버를 참조할 때 사용하는 참조 변수 -&gt; 참조값을 변경한다.[image:670EA140-164A-491D-BD46-2C3720574555-313-00013C953E7391ED/45933790-F795-4A95-BA5D-CD0536292A53.png]간단한 예시 코드를 통하여 This와 Super에 대한 오해를 풀어봅시다.public class Main {    public static void main(String[] args) {        Weapon weapon = new Knife();        weapon.use();    }}public class Weapon {    private int damage = 0;    public void use() {        System.out.println("Use Weapon");        attack();    }    public void attack() {        System.out.println("Weapon : " + damage);    }}public class Sword extends Weapon{    @Override    public void attack() {        attack();    }}public class Knife extends Sword {    private int dagame = 4;    @Override    public void attack() {        System.out.println("knife : " + dagame);    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Enum Class 정리]]></title>
      <url>/dev/2020/05/03/java-enum/</url>
      <content type="text"><![CDATA[  Enum 사용법에 대하여 정리 및 사내 공유를 위해 작성      해당 글의 용어 및 내용은 Java Enum 활용기 - 우아한형제들 기술 블로그를 많이 참고 하였습니다.    Enum이란 ?          Enumeration은 프로그래밍언어에서 상수의 그룹을 나타낼 때 사용한다.Enum은 컴파일 당시 우리가 모든 가능한 값을 알고있는 경우 사용된다. 항상 enum안의 상수는 타입이 정해져 있어야 되는 것은 아니다.Java 1.5버전 부터, enum은 enum 데이터 타입이라고 표시되었다. 자바 enum은 C/C++ enum보다 더 강력한 기능을 제공한다. 자바에서 변수, 메소드 그리고 생성자를 추가할 수 있다. enum의 주된 목적은 우리만의 데이터 타입을 가지기 위해서이다. (Enumberated Data Type)참고 자바의 enum            위 정의를 보더라도 Enum은 상수의 그룹을 나타내기 위하여 사용한다. 라고 선언 되어 있습니다. 과연 상수만을 위하여 Enum을 쓰는것 보다 Enum을 더욱 강력히 사용할 수 없을까? 라는 생각을 가지고 이 글을 보시면 더욱 좋을것 같습니다.    들어가기 앞서 객체는 상태와 행위를 가진다. 라는 개념에 대해 알고 계시는것이 좋을 것 같습니다.Enum - 상수의 집합 ?  사칙연산을 위한 프로그램을 만든다 할때 연산자를 아래와 같은 Enum으로 구분하여 사용할 수 있을것 같습니다.  OperatorType은 사칙연산을 위한 연산자를 가지고 있고 여러 클래스에 선언되어 사용하지 않고 연산자를 Enum으로 관리하여 응집도를 높였다고 볼수 있겠네요.    public enum OperatorType {  PLUS_OPERATOR("+"),  MINUS_OPERATOR("-"),  MULTIPLY_OPERATOR("*"),  DIVIDE_OPERATOR("/");  private String operator;  OperatorType(String operator) {      this.operator = operator;  }  public boolean isEqual(String operator) {      return this.operator.equals(operator);  }}        OperatorType은 과연 상태와 행위를 가지는 객체 인가요 ?          코드를 보시고 상태만 가지고 있다. 라고 생각이 든다면 정답입니다.        과연 행위는 어디에 있을까 ?          어디선가 아래와 같은 코드를 가지고 있는 클래스를 만들어서 사용해야 할것 입니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    if (PLUS_OPERATOR.isEqual(operator)) {        return plus();    }    if (MINUS_OPERATOR.isEqual(operator)) {        return minus();    }    if (MULTIPLY_OPERATOR.isEqual(operator)) {        return multiply();    }    if (DIVIDE_OPERATOR.isEqual(operator)) {        return divide();    }    throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");}  다시 처음 이야기한 객체의 정의에 대해서 생각해봅시다.          객체는 상태와, 행위를 가진다.      OperatorType은 행위를 가지고 있지 않으니 위 코드에 포함된 행위를 OperatorType 으로 옮겨 보겠습니다.        위 코드에서의 문제점은 무엇일까요 ?          곰곰히 생각을 해봅시다 : )      Enum - 상태와 행위를 한곳에  상태와 행위를 한곳에 모아둔 OperatorType을 먼저 보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+") {        @Override        public double calculate(double sum, double nextNumber) {            return sum + nextNumber;        }    },    MINUS_OPERATOR("-") {        @Override        public double calculate(double sum, double nextNumber) {            return sum - nextNumber;        }    },    MULTIPLY_OPERATOR("*") {        @Override        public double calculate(double sum, double nextNumber) {            return sum * nextNumber;        }    },    DIVIDE_OPERATOR("/") {        @Override        public double calculate(double sum, double nextNumber) {            if (nextNumber == 0) {                throw new IllegalArgumentException("0 으로 나눌수 없습니다.");            }            return sum / nextNumber;        }    };    private String operator;    OperatorType(String operator) {        this.operator = operator;    }    public static OperatorType createOperator(String operator) {        if(operator.equals(PLUS_OPERATOR.operator)) {            return PLUS_OPERATOR;        }        if(operator.equals(MINUS_OPERATOR.operator)) {            return MINUS_OPERATOR;        }        if(operator.equals(MULTIPLY_OPERATOR.operator)) {            return MULTIPLY_OPERATOR;        }        if(operator.equals(DIVIDE_OPERATOR.operator)) {            return DIVIDE_OPERATOR;        }        throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");    }    public abstract double calculate(double sum, double nextNumber);}  이제 OperatorType 내부에 선언되어있는 객체들은  calculate라는 행위를 가지게 되었습니다. 이로 인해서 처음에 이야기 했던 객체의 정의를 만족 하게 되었네요 !  이전에 행위를 구현했던 코드는 어떻게 변했을까요 ?          참고Java7 부터 Enum 상수에 추상 메소드를 구현할 수 있습니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    OperatorType operatorType = createOperator(operator);    return operatorType.calculate(sum, nextNumber());}  이전엔 Operator 별로 분기를 타며 계산을 하던 메소드가 실제 계산 하라  라는 메시지를 OperatorType에 던지는 단순하고 깔끔한 메소드로 변경 되었습니다.  여기까지만 보더라도 연산자를 가지고 있는 OperatorType은 자신이 가지고 있는 책임인 계산한다 라는것을 완벽하게 이행 함으로서 외부에선 모든 사칙연산에 관한 계산을 OperatorType을 사용할 수 있게 되었습니다.  이전에 상태와 행위를 한곳에서 관리 하지 않은 코드를 생각해보시면, 계산 하라라는 메시지를 누구에게도 던지지 않고 전혀 의미 없는 클래스에서 행위를 구현하여, 다른 클래스에서의 중복이 발생할 가능성이 컸습니다.  아직 남아 있는 문제점.  보시다 시피 Enum 내부 정적 메소드에 파라미터로 전달 받은 Operator에 맞는 상수를 찾아 전달 하고 있습니다. 위와 같은 분기문이 나열되어 있는 것이 좋은 패턴일까요 ?Enum 리팩토링 - 분기문을 없애보자.  분기문을 없애면서 저희는 Java 8 이상을 사용하는 개발자들로  추상메소드를 사용한 방식보다 Lambda를 사용한 OperatorType으로 리팩토링 해보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+", (sum, nextNumber) -&gt; sum + nextNumber),    MINUS_OPERATOR("-", (sum, nextNumber) -&gt; sum - nextNumber),    MULTIPLY_OPERATOR("*", (sum, nextNumber) -&gt; sum * nextNumber),    DIVIDE_OPERATOR("/", (sum, nextNumber) -&gt; {        if (nextNumber == 0) {            throw new IllegalArgumentException("0 으로 나눌수 없습니다.");        }        return sum / nextNumber;    });    private String operator;    private Calculation calculation;    OperatorType(String operator, Calculation calculation) {        this.operator = operator;        this.calculation = calculation;    }    public static OperatorType findOperator(String operator) {        if (Objects.isNull(operator)) {            throw new IllegalArgumentException("연산자는 null 이 될 수 없습니다.");        }        return Arrays.asList(values()).stream()                .filter(operatorType -&gt; operatorType.operator.equals(operator))                .findFirst()                .orElseThrow(() -&gt; new IllegalArgumentException("사칙연산 기호가 아닙니다."));    }    public double calculate(double sum, double nextNumber) {        return calculation.calculate(sum, nextNumber);    }}@FunctionalInterfacepublic interface Calculation {    double calculate(double sum, double nextNumber);}  뭔가 더욱 깔끔하게 리팩토링된것이 느껴진다면 성공입니다 : )  추상메소드를 사용한 방식 대신 Lambda로 calculate를 구현 하였습니다.          Lambda를 사용하기 위하여 @FunctionalInterface를 만들었습니다.                  @FunctionalInterface는 메소드 1개를 가진 인터페이스 입니다.                    Java가 제공하는 함수형 인터페이스도 사용할 수 있습니다.   Function&lt;T, R&gt; 은 매개변수 1개를 지원하고 2개는 BiFunction을 사용하셔도 됩니다.        분기문이 없어진 것을 확인 할 수 있습니다.          Stream 을 사용하여 분기문을 제거하고 코드의 가독성을 높혀 다른 개발자들이 보더라도 어떤 기능을 하는지 쉽게 알수 있게 되었습니다. : )        이처럼 리팩토링을 하게 되어 얻을수 있는 가장 큰 이점은 재사용성과 확장성을 얻을 수 있게 되었다는 것 입니다.      다른 클래스에서 사칙연산을 하기 위해선 OperatorType만 사용하면 될 것이고 새로운 연산자가 추가 되더라도 복잡한 분기문들을 제거 하였기 때문에 상수 정의만 해준다면 어디서든 정상적으로 동작하겠죠 :)    예제를 사칙연산으로 들었지만 Enum을 사용하는 어느 곳이라도 비슷하게 적용할 수 있을것이라 생각하여 공유드렸습니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 5주차 정리]]></title>
      <url>/dev/2020/04/25/tdd-clean-code-5w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 5주차 정리사다리 타기 tdd 구현  Out - in 접근 방식 vs in.- out 접근 방식  TDD 로 구현하기에는 in.- out 방식이 더 적합하다.          가장 작은 단위의.객체부터 기능을 추가하면서 개발한다.      도메인 설계에서 가장 마지막 객체(의존관계가 없는)      가장 작은 단위의 객체가 구현되었으면, 객체를 더 작게 나눌수 없을까 고민      가장 작은 단위의 객체가 새롭게 만들어 졌으면 다시 고민                  위와 같은 사이클을 계속하여 진행                      책임주도설계로 사다리타기 재설계          책임주도설계 == 인터페이스 주도 설계                  사다리 초기화(생성)          사다리 실행          사다리 결과 구하기                    메시지를 먼저 결정하면 내부 상태가 어떻게 도출될지는 자연스럽게 정해진다.      책임 (객체가 해야할 행동, 메시지)를 먼저 정해보는것.        패키지들 간의 의존성은 단방향으로 만들어야 한다.          추후에 큰변화 (분리) 할때 편리하다.      sonarqube와 같은 정적 분석 도구를 활용해 cyclic dependency를 찾아준다.        서비스 로직은 어디에 구현하는것이좋을까 ?          일급 콜렉션을 쓴다.      3개 이상의 인스턴스 변수를 사용하지 않는다.      묻지 말고 시켜라. (데이터를 꺼내지말고 메시지를 던져라)      상태 변경의 주도권은 외부에 있지 않고 도메인이 가지고 있어야 한다.        도메인 설계, 구현 반복          요구사항을 분석후 도메인 설계.      한번에 완벽한 설계를 하겠다는 욕심을 버려라.                  반복적인 설계와 구현을 통해 도메인에 대한 이해도를 높여야 한다.          도메인에 대한 이해도가 높아야 추상화 수준도 높아진다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 4주차 정리]]></title>
      <url>/dev/2020/04/18/tdd-clean-code-4w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 4주차 정리4주차  점진적 리팩토링          기존의 테스트가 깨지지 않는 선에서 리팩토링 하기      컴파일 에러가 발생하면 안된다.        일반적 상황          메소드에 인자가 추가되었다.      인스턴스 변수 타입이 변경되었다.                  -&gt; 컴파일 에러가 발생 , 에러 해결                          위 방식 대로 리팩토링 하면 긍정적인 측면 보다. 부정적인 측면이 생길 수 있다.    우리가 연습해야할 리팩토링은 ?          메소드에 인자가 추가 되는 경우                  메소드를 그대로 복사하여 메소드 이름을 임시로 변경          임시 메소드를 하나씩 실제 사용한 메소드와 변경          더이상 이전 메소드가 존재하지 않으면, 이전 메소드를 제거 후 이름 변경                    인스턴스 변수의 타입이 변경되는 경우                  새로운 인스턴스 변수 추가          String to Integer로 변경 시 일시적으로 두개 타입을 도시에 사용          두개 변수에 동시에 데이터를 넣고 리팩토링                      점진적 리팩토링 - TDD 에 대한 감이 생길때 시작          1단계 - 메소드를 다른 클래스로 이동      2단계 - 메소드에 인자 타입이나, 반환 타입이 변경 시      3단계 - 인스턴스 변수 타입이 변경되는 경우                  데이터의 중복을 만든다. (임시 변수를 만들고, 메소드에 인자가 추가되는 경우와 같이 점차 변경해나간다.)                          리팩토링은 시간 날때마다 진행하는것이다.    객체지향 설계 및 구현 접근 방식은 ?          Bottom Up 설계 및 구현                  구현에 초점을 맞추어 일단 구현 후 지속적 리팩토링을 통해 역할,책임,협력을 찾아 나간다.                    Top Down 구현 및 설계                  책임에 초점을 맞추어 전체적인 설계 후 구현                      책임 주도 설계          책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계                  클래스를 먼저 설계하는것이 아니다.                      책임이란 ?          책임이란 객체가 유지해야할 정보와 수행해야할 행동      즉 객체가 무엇을 알고있는가 와 무엇을 할 수 있는가로 구성된다.        역할을 다른것으로 교체할 수있는 책임의 집합이다.  테스트 하기 쉬운 코드가 유연한 코드는 아니지만 연습하다 보면 유연한 코드가 될 수 있다.  유연한 설계를 지향한다면 컴파일타임 의존성을 런타임 의존성으로 대체한다.          의존성을 주입 한다.        런타임 의존성으로 대체하다보면 테스트하기 쉬운 설계가 가능해진다.      테스트하기 쉬운 설계를 지향하다보면 유연한 설계가 가능해지는 경험을 종종 할 수 있다.    책임 주도 설계가 진정한 대안인가 ?          책임 주도 설계에 익숙해지기 위해선, 부단한 노력과 시간이 필요.      책임 관점에서 사고하기 위해선 부단한 노력과 학습이 필요하다.      빠르게 구현 후 지속적 리팩토링      TDD 사이클을 반복해 설계의 품질을 높힌다.                  리팩토링 시 객체지향 설계 체조원친, 클린코드 설계 원칙을 지키면서..                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 3주차 정리]]></title>
      <url>/dev/2020/04/11/tdd-clean-code-3w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 3주차 정리  tdd 사이클이 익숙해질때 까지 반복적으로 연습해야 한다.          가장 자신있는 언어로 반복 연습하는것을 추천.      힘들고 지칠땐 주제를 바꿔서 해보는것이 좋다.      시작하기  요구사항 분석을 통한 기능 목록 작성      객체설계를 통해 어느 부분 부터 구현할 지 생각하는것이 우선이다.    기능목록          주제에 대해서 가장 일반적인 기능들을 다 적어보자.      점차 작은 단위의 기능들도 정의        TDD로 구현할 기능 찾기          큰 부분을 작게 자르는 연습을 해야한다.        인풋과 아웃풋이 있는 케이스가 테스트 하기 쉽다.      메서드 하나에 모든 로직이 들어가 있으면 객체지향적인 구조보다 절차지향적 구조로 변질되게 된다.    리팩토링, 어디서 부터 시작할까 ?          첫밴쨰는 메소드 분리부터 시작. (Naming Rename도 해야한다.)                  메소드가 한가지 일만 잘하도록 구현한다.                          한가지 일만 하기 위해 메소드 라인을 제약하는것도 좋은 방법이다.                                          Indent를 줄이자.                  Else 예약어를 쓰지 않는다.                    클래스를 분리하자.                  원시값과 문자열을 포장          일급 콜렉션을 사용한다.          3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않기.          메소드 인자수를 제한한다. 2개까지만 허용한다.                          3개는 고민을 많이 하고, 4개는 절대 안된다.              비슷한 속성을 가진 인자수를 클래스로 만들어 보자.                                  속성과 라이프 사이클이 동일하면 쉽게 판단할 수 있다.                                                                          private method를 분리해서 단위테스트 해야하는 것이 아닌가 ? 라는 의구심          private method를 다른 클래스로 만들어 public으로 open하는게 더 나은 구조는 아닐까 생각해보자.            새로운 클래스가 생성될때 테스트부터 만들어 보자.    상속(is-a) 조합(has-a)          일급 collection을 구현할 때 접근 방법으로 상속과 조합 방법으로 구현 가능      객체의 중복(Lotto와 WinningLotto)를 제거 할 때 상속과 조합 방법으로 구현 가능            상속은 의도하지 않은 인터페이스가 외부에 노출될 수 있다.반면 조합을 사용하면 외부에 오픈할 인터페이스를 정의할 수 있다.    상속과 조합 중 어떤것이 좋을까 ?          상속 보단 객체 조합을 사용해라.      코드의 재사용성 측면에선 상속이 유리. 유연성 측면에선 조합이 유리.                  변화에 빠르게 대응하는 것이 점점 더 중요, 현재는 재사용성 보다 유연성이 훨씬 더 중요하다.          확실하게 경험을 하는것이 좋다 !                      생성자 대신 정적 팩토리 메소드 사용.          생성자의 수가 늘어날수록 클래스를 사용하기 위한 유연성은 높아진다.        가변객체보단 불변 객체를 사용해라.  불변 객체 만들기          객체의 상태를 변경하는 메소드를 제공하지 않는다.      클래스를 확장 할 수 없도록 한다. (Public final class)      모든 필드를 final로 선언한다.                  내부에 collection이 있다면 collection도 불변인지 확인해야 한다.                    모든 필드를 private으로 선언한다.        immutable object 가 좋은것은 알겠는데, 인스턴스가 많이 생성되어 성능이 떨어지지 않을까 ?          캐싱을 적용해 인스턴스 생성을 최소화 할 수 있는 방법이 있는지 검토                  캐싱은 일반적으로 Map(key - value) 형식을 가장 많이 사용된다.                    성능외에도유지보수하기 좋은 코드, 읽기 좋은 코드, 유연한 코드, 버그 발생 가능성이 낮은 코드 와 같이 다양한 측면을 고려하면서  프로그래밍 하는습관을 가지자경험해야할 학습 목표 - 사다리 타기* TDD, 객체 지향 프로그래밍 연습* 인터페이스를 추출하여 프로그래밍 하는 연습을 한다.* stream, lambda를 사용해 프로그래밍하는 것을 연습.경험할 객체 지향 생활 체조 원칙  한줄에 점 하나만  찍는다.          Clean Code 가이드의 디미터 법칙을 지키는 것을 의미.        모든 엔티티는 작게  3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.  getter / setter / property를 쓰지 않는다.함수형 프로그래밍      함수형 프로그래밍은 input과 output이 항상 존재 하기 때문에 test하기 쉽다.    클래스 기반 함수를 모으로 메소드 레벨에서 함수형 프로그래밍에 맞게 설계 ?  람다를 쓰는게 중요한게 아니고 변경 가능성이 높은 부분을 인터페이스로 추출 할 수 있는지가 중요하다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 2주차 정리]]></title>
      <url>/dev/2020/04/04/tdd-clean-code-2w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 2주차 정리코드 컨벤션을 지켜라다른 개발자와 협업이나 미래의 나를 위해서라도.공백 라인을 의미있게 사용해라.공백 라인이 메소드의 기능을 나누게 되는 기준이 된다. 추후 리펙토링 시 메소드 기준으로 기능이 나뉜다는것을 알고 공백기준으로 메소드 리펙토링이 가능하다.네이밍객체지향 생활 체조 규칙 5 : 축약하지 말라.적당한 길이의 이름을 찾는데 집중해라.인스턴스 변수의 중복을 줄이고, 개수를 최소화 해라.데이터를 꺼내려고 하지않고 메시지를 던져라비지니스 로직과 ui로직의 분리.테스트 가능한 코드와 불가능한 코드가 섞여 있으면 분리를 해야 한다.어느 부분을 테스트 할 것인가 ?경계값을 기준으로 테스트해야 한다.Test Fixture를 위해서 생성자를 추가하는것이 옳은 일인가 ? 도메인이 DTO역할을 하는 경우라면 생성자를 추가하는것이 허용된다. 해당 경우에는 허용하는 것으로 .. 역할이 여러개이면 클래스 분리.private메소드가 많아지면 테스트를 해야 하는것인가 ? Private 메소드가 중요한 비지니스 역할을 한다면 새로운 클래스로 분리 되어야 한다. 분리 된다면 다른 클래스에서 접근 가능한 메소드가 되기때문에 테스트가 가능하다.TDD이번주 부터는 메소드 분리가 아닌 클래스 분리를 연습 하자모든 원시값과 문자열을 포장한다. 일급 콜렉션을 쓴다.생성자를 중복해 정의할 때는 정적 팩토리 메소드를 사용한다.tdd는 리팩토링이 가장 중요하다.테스트와 production code를 추가할 때 마다 리팩토링을 해야한다.한번에 리팩토링을 하지 않고 테스트 케이스가 추가 될 때 마다 리팩토링을 하는 연습을 해야 한다.todo리스트를 제대로 만드는것이 tdd를 잘하는 방법이다.설게를 안하는것이 아니고 초반에 대략적인 설계가 필요하다.초반 설계시 테스트 가능한 부분과 힘든 부분까지 설계를 한다면 설계를 잘한 것이다.tdd 시작시 인풋과 아웃풋을 결정해야 한다.Getter 를 쓰는순간 없애려고 노력해라 (상태를 가진 데이터를 꺼내는것보다 객체에 메시지를 보내서 일을 시켜라)접근 제어자를 잘 사용해서 클래스 및 메소드의 접근 범위를 한정하는것도 도메인을 지키는 방법이다.   특히 default 접근 제어자는 도메인을 지키는 좋은 방법중 하나이다.토이 프로젝트에선 최대한 조건을 강제해라인덴트 1, 인스턴스 변수 2개 등의 극한의 조건을 걸어라.Q&amp;AVoid method 는 검증하는것만으로도 의미가 존재 하는지 ?-&gt; 존재한다.Void method 내부에서도 인풋과 아웃풋이 있는 부분을 분리할 수 있을것이다. 그부분을 메소드로 분리해서 테스트 가능하다.유효성 검사도메인은 반드시 유효성 검사를 해야 하는것이 맞다. 그렇다고 controller나 다른 레이어에서 유효성검사를 안해도 된다는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Checked Exception과 UnCheckedException의 차이]]></title>
      <url>/dev/2020/04/02/checked-exception-unchecked-exception/</url>
      <content type="text"><![CDATA[  Checked Exception과 UnCheckedException의 차이점 정리 및 실험Checked Exception 과 UnCheckedException의 차이  Checked Exeption          어플리케이션에서 반드시 예외 처리를 해야 한다. 하지 않을시 Runtime Error 가 발생      Transaction Rollback이 되지 않는다.      대표적으로 IO,SQLException이 있다.      try-catch 로 예외를 처리 하거나 상위 메소드로 예외 처리로직을 위임 할 수 있다.        UnCheckedException          어플리케이션에서 예외처리를 강제 하지 않는 에러.      Transaction Rollback 처리      대표적으로 Runtime Exception, NullPointer, IllegalArgumentException 등이 존재 한다.      명시적 예외 처리 로직이 필요하지 않는 에러        두가지 Exception을 나누는 기준은 위 표와 같이 Runtime Exception의 상속 여부 이다.          RuntimeException 을 상속받는 Exception 모두가 Unchecked Exception이라고 할 수 있다.        간단한 예시를 통하여 Unchecked Exception 의 Rollback을 확인해보자.@Transactionalpublic void insertWithUnCheckedException() {    User user = new User("name");    userRepository.save(user);    throw new RuntimeException();}위와 같이 Service 로직에서 데이터를 저장 후 Unchecked Exception 을 던지게 되면 어떤 일이 일어날지 간단한 테스트 실행.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void uncheckedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithUnCheckedException());    }}결과 로그2020-03-24 18:39:02.118  INFO 83948 --- [           main] p6spy                                    : #1585042742118 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdb2020-03-24 18:39:02.134  INFO 83948 --- [           main] p6spy                                    : #1585042742134 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb      위 로그를 보시면 UncheckedException 이 발생하면 rollback 이 정상적으로 일어난 것을 확인 할 수 있습니다.        CheckedException이 발생 하였을때 정말 Rollback이 되지 않을까 ?  마찬가지로 간단한 테스트를 실행해보자.@Transactionalpublic User insertWithCheckedException() {    User user = new User("name");    User save = userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");    }    return save;}User를 저장하고 강제로 Exception을 던져보았습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        User user = userService.insertWithCheckedException();        assertThat(user.getId()).isNotNull();    }}결과 로그2020-03-24 18:41:41.851 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     call next value for hibernate_sequence2020-03-24 18:41:41.861  INFO 83958 --- [           main] p6spy                                    : #1585042901861 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdbcall next value for hibernate_sequencecall next value for hibernate_sequence;2020-03-24 18:41:41.876 ERROR 83958 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:41:41.885 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     /* insert me.study.exceptiontest.domain.User        */ insert         into            user            (name, id)         values            (?, ?)2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [name]2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [BIGINT] - [1]2020-03-24 18:41:41.890  INFO 83958 --- [           main] p6spy                                    : #1585042901890 | took 0ms | statement | connection 4| url jdbc:h2:mem:testdb/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values (?, ?)/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values ('name', 1);2020-03-24 18:41:41.893  INFO 83958 --- [           main] p6spy                                    : #1585042901893 | took 0ms | commit | connection 4| url jdbc:h2:mem:testdb;  위 로그를 보시면 정상적으로 CheckedException이 발생 하였지만 m.s.q.exceptiontest.service.UserService  : throw exception  User 데이터가 저장되는것을 확인 할 수 있습니다.  CheckedException 이 발생 될 때 정상적으로 Rollback을 하기 위한 여러가지 방법이 있지만 저는 명시적인 UncheckedExecption을 던져주는 방식으로 Rollback이 되는지 실행 해보겠습니다.@Transactionalpublic void insertWithCheckedException() {    User user = new User("name");    userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");        throw new RuntimeException();    }}위 코드와 같이 CheckedException 이 던져질 경우 catch에서 명시적인 예외를 다시 던져주는 방식으로 실행 해 보겠습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithCheckedException());    }}결과 로그2020-03-24 18:48:18.409 ERROR 83989 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:48:18.409  INFO 83989 --- [           main] p6spy                                    : #1585043298409 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb;위 로그와 같이 명시적인 에러를 던져줌으로서 정상적으로 Rollback이 되는것을 확인 할 수 있습니다.  Exception의 종류에 따라 트랜젝션 여부가 다르다는것을 알고 있었지만 실제로 어떻게 처리하는지, 정말 Rollback이 안되는지 등에 대한 실행을 통한 결과 검증 과정을 정리 하였습니다. 지금까지 Exception 처리시 별다른 처리를 하지 않고 단순 로그만 남기는 경우가 많이 있었는데 이번 테스트를 통하여 정확한 예외 처리 방법에 대한 학습을 할 수 있었습니다. :)참고  https://cheese10yun.github.io/checked-exception/  https://1.bp.blogspot.com/]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 1주차 정리]]></title>
      <url>/dev/2020/03/29/tdd-clean-code-1w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 1주차 정리TDD - 프로그래밍 의사결정과 피드백 사이의 간극을 의식. 제어하는 기술TDD는 분석기술이며 설계 기술이기도 하다.TDD는 분석과 설계를 잘 해야 한다.  TDD = Test First Development + Refactoring  TDD는 테스트를 먼저 개발하는것이 주된 목적이 아니고 리팩토링이 주된 목적이다.  짧고 작은 단위의 설계를 지속하여 개발하는 방법.      한번에 모든걸 만들지 않고 작은 단위를 만들어 간다.    TDD는 한번에 한가지 만 고민하여 기능을 우선 개발한다.  이후 개발된 기능을 바탕으로 refactoring을 진행한다.      이때 테스트 코드나 테스트 케이스는 추가되거나 수정되지 않아야 한다.    큰단위를 작은 단위로 나눠 빠르게 실패.  피드백을 통해 지속적 개선  달성하기 힘들 것으로 생각하는 일에 도전할 수 있는 용기  의식적인 연습이 필요하다.          학습테스트      단위테스트      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Clean Code 작성법]]></title>
      <url>/dev/2020/03/27/java-clean-code/</url>
      <content type="text"><![CDATA[  해당 포스트는 DDD 세레나데의 강의를 정리하며 작성하였습니다.Java Code 작성 팁  불변객체(Value Object)를 사용하자.          불변객체란 ?  위키 백과 - 컴퓨터 과학에서 가치 객체는 동일성을 기반으로하지 않는 단순 개체를 나타내는 작은 객체입니다.   즉, 두 객체가 동일한 값을 가질 때 동일하며 반드시 동일한 객체 일 필요는 없습니다. 가치 개체의 예는 금액 또는 날짜 범위를 나타내는 개체입니다.      동일한 값을 가질때 동일한 객체임을 보장해주며 객체의 상태를 변경할 될 수 없는 객체이다.      의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용      시스템이 성숙함에 따라 데이터 값을 객체로 대체      밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.      정말 String으로 우편 번호를 표현할 수 있는가?      항상 equals() 메서드를 오버라이드할 것을 권고한다.                  equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java                      일급 컬렉션을 사용하자.          참고 일급 컬렉션 (First Class Collection)의 소개와 써야할 이유      일급 컬렉션 이란 ?                  콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.필터가 이 새 클래스의 일부가 됨을 알 수 있다.필터는 또한 스스로 함수 객체가 될 수 있다.또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.                    public class LottoNumbers {	  private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public LottoNumbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = numbers;    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || number.size() != LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  항상 방어적 복사를 생각하자.          Java 에서는 값을 참조하는 방법이 크게 두가지가 존재                  Call by Reference          Call by Value                    일반적으로 객체간의 값 복사는 Call by Reference 방식으로 통하여 값이 복사 된다.  이 방식으로 값을 복사 하면 위에서 말한 일급 컬렉션이 불변하지 않게 되는 문제점이 있다. 그래서 항상 방어적 복사(DeepCopy)를 생각하는 방식	을 권장한다.      List&lt;Integer&gt; lottoNumbers = new ArrayList&lt;&gt;();lottoNumbers.add(4);lottoNumbers.add(5);lottoNumbers.add(6);lottoNumbers.add(8);lottoNumbers.add(13);lottoNumbers.add(45);Numbers numbers = new Numbers(lottoNumbers);System.out.println(numbers.totalValue());// 81lottoNumbers.add(2);System.out.println(numbers.totalValue());// 83public class Numbers {    private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public Numbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = new ArrayList&lt;&gt;(numbers);        this.numbers = Collections.unmodifiableList(numbers);    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || numbers.size() == LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  setter 보다 의미있는 이름의 메소드를 사용해보자.          객체에 getter 메서드와 setter 메서드를 무조건 추가하는 것은 좋지 않은 버릇      특히 setter 메서드는 객체의 핵심 개념이나 의도를 코드에서 사라지게 한다.      setter 메서드의 또 다른 문제는 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.      도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.      changeShippingInfo() vs setShippingInfo()completePayment() vs setOrderState()  주/부 생성자를 활용해보자.          주 생성자                  모든 상태를 가진 완전한 객체를 생성하는 생성자                    부 생성자                  상태가 완전하지 않은 객체를 생성하는 생성자                    객체를 생성할 때 상태가 완전하지 않은 객체를 생성하는 경우가 있다.  이런 객체들을 생성할 때 마다 객체의 상태를 검사하는 로직을 남발하는 경우가 존재한다.   해당 로직들을 주 생성자에 위임하여 항상 동일한 로직을 타도록 설정 할 수 있다.      public class Menu {    private String name;    private BigDecimal price;    private Long menuGroupId;    private List&lt;MenuProduct&gt; menuProducts;    public Menu(String name, BigDecimal price, List&lt;MenuProduct&gt; menuProducts) {        this(name, price, null, menuProducts);    }    public Menu(String name, BigDecimal price, Long menuGroupId, List&lt;MenuProduct&gt; menuProducts) {        validName(name);        validPrice(price);        validMenuProducts(menuProducts);        this.name = name;        this.price = price;        this.menuGroupId = menuGroupId;        this.menuProducts = menuProducts;    }    private void validMenuProducts(List&lt;MenuProduct&gt; menuProducts) {        if (Objects.isNull(menuProducts) || menuProducts.size() == 0) {            throw new IllegalArgumentException();        }    }    private void validPrice(BigDecimal price) {        if (Objects.isNull(price) || price.compareTo(BigDecimal.ZERO) &lt; 0) {            throw new IllegalArgumentException();        }    }    private void validName(String name) {        if(Objects.isNull(name) || StringUtils.isEmptyOrWhitespace(name)) {            throw new IllegalArgumentException();        }    }}  생성자 보다는 정적 팩토리 메소드를 사용하자.          정적 팩토리 메서드(static factory method) - 기계인간 John Grib        Package By Feature, Not Layer          패키지를 생성하는 전략 크게 두가지로 나뉘어 생성이 가능하다.                  Package by Layer                          Spring에서 일반적으로 사용하는 Controller / Service / Repository 등의 패키지를 최상단 패키지로 설정하여 프로젝트를 구성하는 방식                                Package by Feature                          도메인 중심으로 패키지를 생성하는 방식.                                  각 도메인이 최 상단 패키지가 되어 하위에 api / application / infrastructure / domain 등을 가지게 된다.                  정답은 없다.                                                                        프로젝트의 규모가 커질수록 Package By Layer 의 구조는 복잡성이 증가하게 된다.              반면 Feature중심의 패키지 구조로 되어 있으면 연관성이 있는 패키지들이 새롭게 추가 되기 때문에 기존 패키지에 영향을 미치지 않게 되며  필요한 기능들이 군집해 있기 때문에 다른 패키지들간의 영향을 줄일수 있게 된다.            참고 자료를 보시는것이 더욱 좋습니다 : )      http://www.javapractices.com/topic/TopicAction.do?Id=205      https://medium.com/@ssowonny/package-by-feature-in-clean-architecture-projects-e14d25e3905e      #JAVA/Code]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> Java </tag>
        
          <tag> Clean Code </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 5주차 강의 정리]]></title>
      <url>/dev/2020/03/20/ddd-serenade-5w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 5주차4주차 복습  비즈니스 로직 수행은 어느 곳에 하는 것이 좋을까 ?          도메인 레이어에서 기능을 수행하고 다른 응용 및 표현 레이어에서 해당 기능을 사용한다.        응용 서비스          사용자의 요청에 맞는 도메인 모델을 찾아오고 그 모델의 로직을 위임하는 처리를 한다.        도메인 서비스          응용 서비스와 도메인 서비스를 판단 하는 기준                  두개 이상의 애그리거트가 사용될때          다루고 있는 로직이 위키나 지라에 정리를 해야할 필요성이 있는 경우          두가지 조건을 한줄로 요약하면 도메인 지식이 다른곳으로 흘러가는것을 막아주는 역할을 한다.          도메인 서비스는 어플리케이션 레이어와 도메인 레이어 사이에 위치한다.                      응용 서비스의 구현  vo가 dto로 돌아다녀 외부에 노출된다면 캡슐화가 깨지는것이 아닌가 ?          vo가 dto로 돌아다니는 것은 일종의 trade-off이다.      vo의 접근 제어자를 default로 두어 도메인 패키지 내부에서만 사용할수 있도록 만드는것도 하나의 방법이다.        항상 DTO를 만드는것은 실용적이지 않아 DTO를 대신 할 수 있는 VO를 찾는것도 방법이다.  고수준 모듈 저수준 모듈          고수준 모듈이 저수준 모듈에 의존하는것이 아니고 저수준 모듈이 고수준 모듈에 의존하도록 dip를 적용해야 한다.        클린 아키텍처          안에선 밖을 모르고 밖에선 안을 알수 있는 아키텍처      도메인 모델을 외부로 부터 지키는 것이 중요하다.        anticorruption layer          anticorruption layer 하는 역할이 크다면 별도의 레이어로 만들수도 있고 클래스로도 만들 수 있다.      많은 mapper class assemblr pattern이 등장 하더라도 나의 도메인 모델을 지킬 수 있다.        도메인 서비스 구현 방법          응용 서비스에서 도메인 서비스를 주입 받고 응용서비스 내부에서 메시지를 전달한다.      해당 도메인 서비스에서는 도메인들을 가지고 와서 실제 로직을 실행하는 과정을 거친다.      repository는 domain service에 담고 있다.      repository에서 실행하는 save와 같은 데이터 추가는 실제로 DB에 값이 저장되지는 하지만 도메인 입장에서는 add와 같은 기능을 한다고 생각하여 repository가 infra영역이 아닌 domain 영역에 있다고 본다.      Domain layer가 필요 없는 상황 (하나의 도메인만 사용한다면) application layer에서 처리      도메인 모델에서 에러 같은 경우는 try - catch하여 상위 레이어에 노출되지 않도록 막아준다.                  상위 레이어에서 알 수 있는 에러를 핸들링 할수 있도록 하는 것.                      DTO 가이드          dto를 도메인으로 전환하고 도메인을 dto로 전환하는건 application service에서 담당하는것이 맞다.      dto가 데이터를 담아서 전달 할 수 있는 영역은 application service까지 이다.        모놀리식 아키텍처는 다른 패키지의 서비스를 주입 받아서 사용하지만 마이크로 서비스로 분리 되는 경우 변경이 힘들다.  외부 컨텍스트에서 발생한 예외 또한 내부 컨텍스트에서 이해할 수 있는 에러로 감싸주어야 한다.  infrastructure layer가 anti corruption layer 역할을 할 수도 있다.  exception은 domain 패키지에 위치  anticorruptionlayer 도메인 내부 에그리게잇 폴더에 위치  order - buyer 예시에선 order 에그리게잇이 root가 되었다. 내부에 order , order item entity를 가지고 있고 vo 도 가지고 있다.전술적 설계 - Domain Event  이벤트란 도메인 전문가가 관심을 가질 법한 것들 (단순 조회 제외)  강한 결합  이벤트          이벤트는 어떤 상태가 변경되었다는것이다.      도메인 모델에서 이벤트를 관리 하는 주체는 에그리게잇이 될 수 있다.      이벤트 핸들러는 이벤트에 담긴 주체를 가지고 부가적인 행동을 하게 된다.      스프링에선 application event publisher 가 트랜잭션이 종료될때 이벤트를 발행 해 준다.                  테스트 코드에선 이벤트가 발행되었는지 안되었는지만 확인 하면 된다.                    스프링 이벤트는 기본적으로 한 트랜젝션 내부에선 묶여있다.                  하나가 실패하면 롤백되는 구조이다.          TransactionalEventListener 를 사용하면 트랜잭션이 끝난 후 동작하도록 사용할 수 있다.                    스프링 이벤트를 사용하지 않고 이벤트를 발행 하려면 AbstractAggregateRoot 를 상속 받아 registerEvent()으로 이벤트를 발생할 수 있다. 이떄는 save를 강제로 호출 해줘야 한다.      도메인 내부에 이벤트를 가지고 있어야 한다.        이벤트 소싱          도메인 모델에서 발생하는 모든 이벤트를 기록하는 방법        CQRS          상태를 변경하는 명령과 모델의 상태를 조회하는 모델을 분리한 패턴.      커멘트 패키지와 조회 패키지등으로 분리 할 수 있다.      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[인터페이스와 구현에 대한 정리]]></title>
      <url>/dev/2020/03/18/java-interface-and-implement/</url>
      <content type="text"><![CDATA[  객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 공유 하고자 만든 자료입니다.인터페이스와 구현객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 공유 하고자 만든 자료입니다.객체란 자기 주도적으로 책임, 협력, 역할을 가지고 있는 상태를 의미한다.여기서 책임이란 어떠한 일을 맡아서 하는 것이다.커피 전문점 도메인을 가지고 인터페이스와 구현에 대해 알아 보자.커피 전문점 도메인은 고객, 바리스타, 커피, 메뉴판등의 객체를 가지고 있다고 가정한다.고객이란 어떤 책임을 가지고 있을까 ?일반적으로 생각 하면 ‘주문’이라는 책임을 가지고 있을 것이다.모든 주문은 고객이 주도적으로 생성하게 될것이고 생성된 주문을 통하여 바리스타는 주문에 해당하는 커피를고객에게 전달하게 된다. 따라서 고객은 주문이라는 책임을 가지고 있는 셈이다.협력이란 ? 고객이 ‘주문’이라는 책임을 가지고 다른 객체에게 주문하라 라는 메시지를 전달 한다.여기서 메시지는 객체간의 의사소통을 하기 위한 방법이다. 여기서 고객은 주문하라 라는 메시지를 통해 바리스타에게 커피를 만들어라고 다시 한번 메시지를 전달하게 될것 이다.결론적으로 커피전문점에서 고객이 커피를 주문하기 위해선 고객과 바리스타간의 협력을 통하여 최종적으로 커피가 주문되게 되니 둘 간의 협력 관계가 형성 되는 것이다.역할이란 ? 역할은 메시지를 책임지는 집합으로 볼 수 있다. 여러 커피전문점을 생각해보자. 어떤 커피전문점에서는 들어오는 커피에 따라서 바리스타의 역할이 세분화 될 수 있다.예를 들면 에스프레소를 책임지는 바리스타, 라떼를 책임지는 바리스타 등으로 바리스타의 역할중 세분화 되어 있는 영역에서 똑같이 커피를 만들어라 라는 책임을 다하고 있는것이다.일반적으로 역할은 추상화 과정에서 나타난다.상위 수준에서의 책임을 쉽고 간단하게 표현하고 설계를 유연하게 만들수 있는 장점이 있다.자율적인 객체객체는 상태와 행동을 함께 가지는 복합적인 존재이며 스스로 판단하고 행동하는 자율적인 존재라는 것이다. 대부분의 프로그래밍 언어는 외부에서 접근을 통제 할 수 있는 접근 제어 메커니즘을 제공한다. 접근 제어를 위해  public, private 와 같은 접근 수정자가 존재한다.객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다. 객체지향의 핵심은 스스로 상태를 관리하고 판단하고 행동하는 자율적인 객체들의 공동제를 구성 하는 것이다.캡슐화와 접근제어는 객체를 두 부분으로 나눌수 있다. 외부에서 접근 가능한 퍼블릭 인터페이스(public interface), 내부에서만 접근 가능한 부분인 구현(implementation)이라고 부른다.캡슐화상태와 행동을 하나의 객체안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위함이다.잘 설계된 캡슐화를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고, 외부에는 상대적으로 안정적인 부분만 공개함으로 변경의 여파를 통제 할 수 있다.변경될 가능성이 높은 부분을 구현이라 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.일반적으로 사용하고 있는 getter / setter를 사용한 캡슐화는 진정한 의미의 캡슐화가 아닌것이 중요하다.간단한 예시를 통하여 인터페이스와 구현에 대해서 알아 보자.public class Customer {    public void order(String menuname, Menu menu, Barista barista) {        MenuItem menuItem = menu.choose(menuname);        Coffee coffee = barista.makeCoffee(menuItem);    }}고객은 order라는 메시지를 통하여 주문이라는 책임을 실행한다.여기서 중요한 점은 order라는 메소드가 public으로 공개 되어 있다는것이다.이로서 다른 누군가는 Customer는 order라는 메시지를 전송할 수 있다라는것을 알 수 있다.내부 구현으로 Menu를 통하여 어떤 커피를 만들어야 하는지 받아 오고 바리스타에게 해당하는 커피를 만들라는 메시지를 전달한다.public class Menu {    private List&lt;MenuItem&gt; menuItems;    public Menu(List&lt;MenuItem&gt; menuItems) {        this.menuItems = menuItems;    }    public MenuItem choose(String menuname) {        return menuItems.stream()                .filter(menuItem -&gt; menuItem.name().equals(menuname))                .findAny()                .orElseThrow(IllegalArgumentException::new);    }}Menu 객체를 살펴보자.여기서 중요하게 봐야할 부분은 choose가 아닌 menuItems를 내부에 상태로 가지고 있다는 것이다. Menu는 MenuItem에 의존하고 있는 상태가 된것이다. 코드를 살펴보면 Menu를 생성할 때 MenuItems를 생성자로 받아 생성하고 있습니다.이렇게 구현한 이유는 MenuItem이 추가 되더라도 다른 객체에서는 추가적인 수정이 필요 없고 오직 MenuItem을 의존하고 있는 Menu 클래스만 수정하여 choose라는 책임을 다하면 되는것 이다.public class MenuItem {    private String menuname;    private BigDecimal price;    private MenuType menuType;    public MenuItem(String menuname, BigDecimal price, MenuType menuType) {        this.menuname = menuname;        this.price = price;        this.menuType = menuType;    }    public String name() {        return menuname;    }    public BigDecimal cost() {        return price;    }    public MenuType menuType () {        return menuType;    }}public enum MenuType {    ESPRESSO, COLDBREW, LATTE}public class Barista {    public Coffee makeCoffee(MenuItem menuItem) {        return make(menuItem);    }    private Coffee make(MenuItem menuItem) {        if(menuItem.menuType().equals(MenuType.ESPRESSO)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.COLDBREW)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.LATTE)) {            //Do SomeThing            return new Coffee(menuItem);        }        throw new IllegalArgumentException();    }}이번 내용에서 가장 중요한 바리스타 클래스 입니다. 바리스타 객체는 커피를 만들어라라는 책임을 가지고 있는 클래스 이며 코드를 보시면 makeCoffee라는 메소드가 public 으로 오픈 되어 있습니다. 실제로 커피를 만드는 로직은 private으로 되어 있는 make라는 메소드에서 진행하고 있는데 이렇게 구현한 이유가 캡슐화를 하기 위해서 입니다. 외부에서는 바리스타는 커피를 만들수 있다 라는것을 알고 있지만 커피를 어떻게, 어떤 방식으로 만드는지는 모르도록 내부에 구현 로직을 private 으로 감싸서 숨긴 예시라고 할 수 있습니다.여기서 public 으로 오픈되어 있는 메소드는 인터페이스이며 private 으로 숨겨둔 메소드가 구현이라고 생각 하시면 될 것 같습니다.이러한 방식의 장점은 마찬가지로 커피를 만드는 방법이 추가 되더라도 커피는 바리스타 객체가 자율적으로 만들 수 있기 때문에 다른 클래스의 코드는 수정을 하지 않아도 된다는 것입니다.public abstract class BaristaI {    public Coffee makeCoffee(MenuItem menuItem) {        //doSomeThing        Coffee make = make(menuItem);        //dosomeThing        return make;    }    protected abstract Coffee make(MenuItem menuItem);}바리스타 클래스를 Template Method 패턴으로 구현하여 깔끔한 코드로 확인 할 수 있다.참조Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> 객체지향의 사실과 오해 </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 4주차 강의 정리]]></title>
      <url>/dev/2020/03/13/ddd-serenade-4w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 4주차3주차 복습  전술적 설계 - ddd lite , building block          특정 디자인 패턴이 필요하다면 building block에 포함되는 것이다.        좋은 객체는 불변한 객체          도메인 주도 설계 빌딩 블록중 불변인 것들을 vo 라고 부른다.      vo는 equals와 hashcode를 재정의 하는것을 권장한다.      생성자 보다는 정적 팩토리 메소드를 사용해라.        Entity          내부에 상태값이 변하는 객체들은 entity로 만들 수 있다.      entity는 식별자를 갖는다.      도메인 모델에 set 메서드 넣지 않기      Aggregate  한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.      공통적으로 사용하는 애그리거트는 baseAggregate과 같이 trade-off할 수 있다.    수많은 aggregate중 root 로 만드는 방법은 외부에서 바라보는지를 확인 하면 된다.  애그리거트 루트는 일관성이 깨지지 않도록 해야한다.          생성자로 엔티티를 만들때 모든 속성을 가지고 있어야 한다.            클라이언트는 애그리거트의 내부 구현이 어떻게 되어 있는지 몰라야 한다.    Aggregate 참조          subentity를 외부에 노출시키면 안된다.              Root entity를 기준으로 repository를 제공해줘야 한다.            두개의 aggregate가 필요하다면 domain service가 도출되어야 한다.      하나의  aggregate에서도 domain service가 발생할 수 있다.        Factory          데이터를 가지고 있는 객체가 일을 하도록 메시지를 던져야 한다.      4주차  계층형 아키텍처          표현영역                  httprequest, response, session을 관리                    응용 서비스                  로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임.          도메인 영역에서 발생시킨 이벤트를 처리.                    도메인 서비스                  로직에 대한 버전 관리를 해야할 필요가 있는 경우 도메인 서비스가 될 수 있다.          두개 이상의 aggregate를 사용하면 반드시 도메인 서비스가 되어야 한다.                          같은 aggregate라도 두개 이상을 사용한다면 도메인 서비스.                                          메서드 파라미터와 값 리턴                  응용 서비스에 데이터로 전달할 파라미터가 두개 이상이면 데이터전달을 위한 별도 클래스를 사용하는것이 편리.          응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법.                    값 검증                  값 검증은 표현영역과 응용 서비스 두 곳에서 모두 수행 할 수 있다.          표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 아이디 중복 여부와 같은 논리적 오류만 검사하면 된다.                    인터페이스는 어느 시점에 생성하는것이 적절한가                  외부와 연동할 가능성이 크거나 연동하고 있는 것은 인터페이스를 만드는 것이 좋다.                      DTO          DTO는 프로세스 간에 데이터를 전달하는 객체가 아니고 구조체 라고 보는것이 맞다.      value object는 dto가 아니다.      value object는 어플리케이션 내부의 요구사항으로 만들어지고 dto는 어플리케이션 외부의 요구사항을 반영한다.      dto에서 entity를 만드는것은 괜찮으나 entity 에서 dto를 만드는것은 불가하다.      domain model everywhere      pure domain model                  항상 dto를 만드는 것은 실용적이지 않다.                          -&gt; vo로 해결 가능한 것은 vo로 해결 해도 된다.              vo는 영역과 관계없이 사용가능하기 때문이다.                                            의존 역전 원칙          고수준 모듈의 의존 문제                  저수준 모듈의 변경에 따라 고수준 모듈의 변경이 불가피 해진다.                    DIP 주의 사항                  추상화 한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치 해야 한다.          실제 구현은 infrastructure에서 구현(저수준)                    육각형, 양파, 클린 아키텍처                  공통된 목적은 내부에 있는 domain layerr를 외부로 부터 숨기고 지키는것이다.          내부는 외부를 모르고 외부는 내부를 몰라야 한다.                      anti corruption layer          외부로부터 내부 도메인 레이어를 지키기 위한 계층        주 생성자 -&gt; 모든 상태를 가지고 있는 생성자  부 생성자 -&gt; 부생성자가 주 생성자를 호출하는 방법  최상단 패키지는 Bounded Context로 나누고 Aggregate은 domain package에서 나누는 방  menu product가 price를 가지도록  infra - product 와 관련된 클래스를 만들고 productservice를 주입 받아 price를 얻는다 ? -&gt; anti corruption layer 만든다]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 3주차 강의 정리]]></title>
      <url>/dev/2020/02/21/ddd-serenade-3w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 3주차2주차 복습  유비쿼터스 언어          유비쿼터스 언어는 회의록, 회의, 코드 등에서 나타난다.      유비쿼터스 언어는 Bounded Context에서만 존재 해야 한다.      코드레벨에서는 유비쿼터스 언어가 검증이 되어야 한다.      검증이 되지 않으면 실패할 가능성이 크다.        용어사전          도메인 주도 설계가 성공하기 위해선 용어 사전을 개발자만 참여하는것이 아닌 프로젝트에 참여하는 모두가 관리 해야 한다.      프로젝트가 커질 시 컨텍스트 별로 용어 사전을 정리 해야 한다. (동일한 용어가 다른 의미를 가질 수 있다.)        모델링          모델링은 소리 내어 읽었을때 어색하지 않아야 한다.        Bounded Context          BC는 서로 다른 관점을 찾는 것이다.      우발적인 중복은 충분한 고민을 해봐야 한다.      하나의 BC는 하나의 팀에서만 관리하는것이 베스트이다.        OOP vs DDD          oop 에서의 상속으로 풀수 있는 문제 라고 하더라도 ddd 에선 context 간 분리가 더 중요하다.     그로 인해 context 내부에 중복이 발생 할 수도 있다.        이벤트 스토밍          단순한 조회 같은 행위는 이벤트가 아닐 수도 있다.      조회를 하여 조회 카운트가 상승했다 와 같은 행위가 이벤트이다.      개발자들은 이벤트 스토밍 도중 기획자나 도메인 전문가 들이 설계를 어렵게 하는 부분에 대해 문제를 제기 할 줄 알아야 한다.        Aggregate          독립된 라이프 사이클을 가지는 무언가        공통된 단어가 나오면 반드시 context를 나눠야 한다.  (최소 context 수)최대 context 개수는 는 aggregate 개수  도메인 주도 설계는 설게 후 구축이 아닌 설계와 구축이 병렬적으로 진행 되어야 한다.전술적 설계 - ENTITY 와 VALUE OBJECT  Entity는 지속적으로 상태를 관찰해야할 필요가 있을때 만든다.  내부적인 상태가 변하더라도 동일한 객체라고 인식을 해야 할 때 식별자를 만들고 Entity로 만든다.  도메인 모델에 setter 가 있으면 해당 도메인 모델은 완전한 상태가 아니게 된다.          버릇처럼 쓰는 setter 는 남발하면 안된다.        모든 객체는 불변 객체가 가장 좋다.          새로운 타입의 객체를 만들어서 유효성 검사 로직을 옮긴다.      객체 끼리의 책임을 나누는 방법.      분리 된 객체는 만들어지거나 실패하거나 원자성을 보장한다.      값 객체 (value object- 불변 객체)는 동일성과 동등성을 보장해야 한다.                  가변 객체는 값이 바뀜에 따라 의미가 달라 질 수 있다.          불변 객체는 값이 바뀜에 따라 새로운 불변 객체를 만들어 내야 한다.          불변 객체는 계속 생성이 되면 메모리 부하가 일어나지 않나 ?                          -&gt; 컴퓨팅 파워와 GC를 믿어야 한다.                                          불변 객체                  포함 되고 있는 모든 값들을 final 로 만든다.          1 + 1 = 2 가 아닌 new int(2)          리스트 같은 멤버 변수는 final을 사용해도 값이 바뀔수 있어서 의식적인 방어적 복사가 필요하다.                    AGGREGATE  엔티티와 ValueObject (관련 객체)가 모여있는 군집.  반장이라는 개념이 있다 (루트 엔티티)  Bounded Context &gt; Context &gt; AGGREATE  동일한라이프 사이클을 가진것을 하나의 AGGREGATE로 묶는다.          ex) 자동차 인스턴스가 사라지면 내부에 속한 핸들 및 바퀴와 같은 인스턴스도 같이 사라져야 한다.        하나의 Aggregate에 속하면 다른 Aggregate에는 속하지 못한다.  정리 하면 많은 엔티티들을 동일한 라이프 사이클로 묶어둔 군집  Aggregate Root          외부에선 해당 aggregate와 대화 하기 위해선 Root에게 요청을 해야 한다.      Aggregate Root 도 하나의 엔티티 이기 때문에 내부에 상태를 가지고 있다.      서로 다른 Aggregate와 대화 하기 위해선 반드시 Aggregate Root를 거쳐야 한다.      내부에 어떤 상태를 가지고 있는지 외부에서는 알지 못한다 (캡슐화)        두개 이상의 엔티티가 하나의 Aggretate에 있으면 어떤걸 Root로 할까 ?          Aggregate Root 가 될 수 있는 기준은 Global 식별자(외부에서 참조 하고 있는 식별자) 를 가지고 있는것. 따라서 Order가 Root      로컬 식별자 를 가지고 있으면 루트가 될 수 없다.        정리 하면 글로벌 식별자를 가지고 있어야 루트 에그리게잇이 될 수 있다.  Aggregate 참조          직접 참조를 허용하면 편리함을 오용한다.      ID를 이용한 간접 참조를 권장한다.                  복잡도를 낮출 수 있다.                    같은 Aggregate 에선 직접 참조 해야 한다.      Repository  Repository 는 구현을 위한 도메인 모델.  Aggregate 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.  리포지토리는 Aggregate(Root)단위로 존재하며 테이블 단위로 존재하는 것이 아니다.          리포지토리는 Aggregate을 위한 컬렉션으로 생각하면 된다.      Service  어플리케이션 서비스와 도메인 서비스는 다르다.  여러 도메인이 가진 로직들을 하나의 서비스에서 처리 하기 위한 레이어.  도메인 서비스라는 것은 엔티티, vo, repository를 만든 상태에서 정책 또는 로직을 특정 애그리게잇의 행위로 지정하기 어려운것들.  객체 지향이 아닌 절차 지향적인 로직들을 도메인 서비스로 분리해서 특별하게 관리 할 수 있다.  도메인 서비스와 어플리케이션 서비스는 상태값을 가지고 있지 않다는것에선 유사하지만 서로 다루는 서비스 영역이 다르다.Factory  연관된 Aggregate에서 생성 해보자.          ex) 좋은 모델링 - LadderGame 이 종료되야 GameResult 생성                  사다리게임이 끝나야 게임 결과를 생성한다 라는것은 게임 결과는 게임을 통해서 알수 있다는 비즈니스 로직을 한눈에 알수 있는것이다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 2주차 강의 정리]]></title>
      <url>/dev/2020/02/14/ddd-serenade-2w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 2주차전략적 설계유비쿼터스 언어 - 개발자와 도메인 전문가가 공통적으로 이해 할수 있는 영역의 언어.  모든 상황(회의, 코드, 도메인…)에서 사용하는 언어 (언제, 어디에서나)  기획자나 개발자는 모두 동일하게 이해할 수 있는 언어를 사용해야 한다.  용어사전을 정의 하고 항상 유지 해야 한다.          용어 사전은 죽은 문서가 될 가능성이 많다.        유비쿼터스 언어를 가장 잘 검증해주는 곳은 코드레벨 이다.          개발자의 입장에선 코드레벨에 유비쿼터스 언어가 존재하는것은 좋다.      기획자와 디자이너도 볼 수 있도록 용어가 추가 될 시 용어 사전을 업데이트 해야한다.        용어 사전이란 유비쿼터스 언어를 정리 해둔 사전이다.          프로젝트에 참여하는 모두가 알고 관리 해야한다.      효과적인 모델링  RouteService 는 RouteSecification 만족하는 plan을 찾는다.          개발자는 RouteService 에 RouteSecification 전달하면 plan return 이라고 해석이 된다. Ex ) 환불은 환불정책을 통해서 환불금액이 결정된다.      한팀, 한 언어  사업팀도 모델링을 이해하지 못한다면 모델링이 잘못된 것이다.Bounded Context (문맥 경계)  도메인 별로 용어사전이 다르기때문에 동일한 용어를 다른 도메인에서 사용하면 안된다.  모델은 특정한 문장(문맥)에서 완전한 의미를 가지게 된다.  동일한 단어가 발생하면 Bounded Context 나누기 가장 좋은 상태이다  Ex) 피자가게있는 피자, 쓰레기통에 있는 피자          피자라는 언어를 사용하지만 문맥에 따라서 피자의 의미가 다르다.      좋은 Bounded Context  하나의 Bounded Context는 하나의 팀만 관리 해야 한다.          의견 마찰 및 도메인 영역의 마찰을 줄이기 위해.      하나의 팀이 여러 Bounded Context는 관리 할 수 있다.        각각의 Bounded Context는 각각의 개발 환경을 가질 수 있다.          명확히 구분되는 경계를 그엇기 때문이다.      MSA로 가는 기초.      어떻게 경계를 나눌것인지를 먼저 생각 해야 한다.      Context Map  컨텍스트 맵은 상호 교류하는 시스템의 목록 제공 및 의사소통의 촉매 역할을 한다.  Upstream : 데이터 제공. (Api, Event)  DownStream : 데이터 수신.프로젝트와 조직 관계  파트너십 : 두 context가 하나의 트랜잭션으로 묶여있다.  공유 커널 : 상호 의존하는 공유 모델을 관리한다.  고객 - 공급자(costomer - surpplier) : 업스트림(서버 : 공급자) : 다운스트림(클라이언트 : 고객)으로 단방향 의존한다.  순응주의자(Ex_Open API) : 업스트림(서버)가 모든것을 제어한다.  오픈 호스트 서비스 : REST/API, RPC, Socket  분리된 방법 : 의존 없음  큰 진흙공 : 안티 패턴DDD vs OOP  Context 마다 서로 유비쿼터스 언어를 다른 도메인으로 인식한다.  OOP는 상속이나 재활용성을 위해서 공통된 데이터를 공유하는 것을 중요시  DDD는 도메인 분리를 중시DDD가 성공할 수 있는 전제 조건  DDD는 현업의 절대적인 도움이 필요하다.  이해관계자의 스폰서십이 적극 필요.이벤트 스토밍  정의          도메인 전문가와 개발자를 학습 과정에 참여시키기 위한 빠른 설계기술      비즈니스 및 비즈니스 프로세스에 중점을 둔다.                  클래스와 데이터베이스가 아닌 이벤트와 비즈니스 프로세스에 중점을 둔다.                    코드를 없애고 모든 사람을 동일한 수준으로 만드는 시각적 접근      Aggregate  이벤트 스토밍 중 같은 단어가 중복적으로 발생하면 집합으로 만든다.  Aggreate 하나의 하나의 엔티티를 가지는것이 좋지만 항상 지켜야 하는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring JPA DB Master / Slave 적용시 주의할 점]]></title>
      <url>/dev/2020/01/24/jpa-replication-issue/</url>
      <content type="text"><![CDATA[스프링 JPA를 사용하면서 데이터 베이스 이중화를 하는 경우에 크게 두가지 방법으로 구현한다. 첫번째는 AOP 를 이용하여 쿼리 타이밍에 특정한 Datasource를 불러오는 방법. 두번째는 Transaction의 Readonly 속성을 감지하여 이중화. 지금 진행중인 프로젝트에서 두번째 방법으로 데이터베이스 이중화를 설정하였지만 생각하지 못한 문제점이 발생. 원인파악 및 최소한의 해결 방법을 정리.  문제점          DataSource를 여러개를 사용하기 때문에 일반적으로 스프링 JPA 설정으로 데이터소스를 만들수 없다. 커스텀한 데이터 소스들을 서버가 실행될때 등록하여 실행한다.      위 방법을 사용시 스프링에서 제공해주는 기본 설정을 사용하지 못하여 @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 와 같이 기본설정을 제거 하는 코드가 필요.      기본설정을 제거 하여 Entity Manager룰 새롭게 등록 해주어야 했다.      LocalContainerEntityManagerFactoryBean 를 사용하여 EntityManager를 등록 하니 아무런 설정들이 없는상태.      스프링 JPA를 사용하면 hibernate naming 전략이 snake case로 설정된다. 하지만 자동설정을 못하니 naming 전략이 camel case로 설정 되어 실행되고 있었다.      문제점을 해결하기 위해 property에 naming 전략을 정의 해봤지만 정상적으로 실행되지 않았다. 구글링 결과 아래 코드를 사용하여 해결할 수 있었다.            entityManagerFactoryBean.setDataSource(dataSource());    entityManagerFactoryBean.setPackagesToScan("com.my.pakage");    entityManagerFactoryBean.setJpaVendorAdapter(vendorAdapter);    HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;();    properties.put("hibernate.physical_naming_strategy", "org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy");    entityManagerFactoryBean.setJpaPropertyMap(properties);                      남은 문제          스프링 자동 설정이 정확히 어떤것들을 설정해 주는지 모르니 기본적으로 사용하던 설정들중 어떤것들이 빠져 있는지 확인이 필요하다.      가능하다면 스프링에서 제동해주는 자동설정을 그대로 사용하고 싶기 때문에 방법을 조금더 찾아 볼 예정.        문제 해결 추가.          스프링 자동 설정중 테이블 네이밍 설정이 빠져 있는것을 확인. hibernate.implicit_naming_strategy / org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy 추가.      스프링에서 제공하는 자동 설정이 어떤것들이 있는지 라이브러리에서 확인. org.springframework.boot.autoconfigure.orm.jpa 해당 패키지 아래 jpa, hibernate autoconfiguration을 확인할 수 있다.      개발환경  스프링 부트 2.2.2  스프링 데이터 JPA 2.2.2]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> JPA </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
