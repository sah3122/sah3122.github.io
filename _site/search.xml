<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Azure API Management Service 활용법]]></title>
      <url>/dev/2020/06/17/azure-api-managerment-service/</url>
      <content type="text"><![CDATA[  Azure API Management Service를 사용한 API 응답 캐싱Azure API Management Service 캐싱을 활용한 글로벌 서비스 성능 최적화 방법을 간단하게 공유드립니다. 해당 방식은 정적인 응답을 반환하는 경우에 사용할 수 있으며 실시간으로 응답이 변경되거나 조건에 따라 다른 응답을 반환하는 경우에는 목적에 맞지 않을수 있습니다.API Management Service란 ?APIM(API Management)은 기존 백 엔드 서비스를 위해 일관된 최신 API 게이트웨이를 빠르게 만드는 방법입니다.API Management를 사용하여 조직은 외부, 파트너 및 내부의 개발자에게 API를 게시하여 데이터 및 서비스의 잠재성을 활용할 수 있습니다. 모든 곳의 비즈니스는 디지털 플랫폼으로 운영을 확장함으로써 새로운 채널을 생성하고, 새로운 고객을 찾고, 기존 고객과 더 깊은 관계를 구축하고자 합니다. API Management는 개발자 참여, 비즈니스 통찰력, 분석, 보안과 보호 등을 통해 성공적인 API 프로그램을 보장하는 핵심적인 역량을 제공합니다. Azure API Management를 통해 원하는 백 엔드를 사용하고 해당 백 엔드에 따라 모든 기능을 갖춘 API 프로그램을 시작할 수 있습니다.API 게이트웨이 는 다음 작업을 수행하는 엔드포인트입니다.  API 호출 수락 후 백 엔드로 라우팅합니다.  API 키, JWT 토큰, 인증서 및 기타 자격 증명을 확인합니다.  사용 할당량 및 속도 제한을 적용합니다.  코드 수정 없이 즉석에서 API를 변환합니다.  설정된 위치에 백 엔드 응답을 캐시합니다.  분석용으로 호출 메타데이터를 기록합니다.공식 문서에 따르면 위와 같은 기능들을 제공하는 서비스라고 설명되어 있습니다. 위 기능을 포함하여 많은 기능들을 제공하니 공식 문서를 확인해주시길 바랍니다.API 호출 수락 후 백 엔드로 라우팅, 설정된 위치에 백 엔드 응답을 캐시 두가지 기능을 사용하여 기존에 사용되고 있던 API를 글로벌 환경에서 효율적으로 서비스 하기 위해 테스트를 진행 하였습니다.사용 배경현재 사용하고 있는 API서버는 홍콩 리전에 배포되어 있으며 미국 버지니아 기준 간단한 GET 요청을 보낼 시 약 1초 정도의 응답시간이 소요되고 있었습니다. 트래픽이 많은 서비스는 아니지만 페이지 접근 시 1초 이상의 응답시간이 걸리는 API를 개선하고 준비하고 있는 이벤트 서비스를 사용자 친화적으로 제공하기 위하여 응답시간을 줄이기 위한 작업을 시작하였습니다.설정      API Management 서비스를 생성합니다.이때 주의 할 점은 다수의 Location 설정을 위하여 프리미엄 이상의 서비스를 선택해야 합니다.         API 연동API Management 서비스가 활성화 되면 연동할 API의 정보를 추가해줘야 합니다.OpenAPI 등록서비스를 사용하여 추가할 수 있습니다.  OpenAPI Spec에 맞춘 json파일을 업로드 하여 API Gateway와 연동합니다.json파일은 Swagger2.0 기반 api 문서를 그대로 사용할 수 있게 되어있습니다.정상적으로 API연동을 마치면 위와 같이 API목록을 확인 할 수 있습니다.  캐시 설정 및 지역 추가API 요청시 응답값을 캐싱하여 빠르게 응답을 전달해주기 위하여 적절한 캐시 설정이 필요합니다. 공식 문서에서 제공하고 있는 캐시 설정을 적용해보았습니다.Azure API Management에서 캐싱을 추가하여 성능 향상 | Microsoft Docs 문서를 참고하여 미국 지역에 새로운 API GW를 추가를 끝으로 캐싱을 위한 설정은 끝이 납니다.Azure API Management 서비스를 여러 Azure 지역에 배포 - Azure API Management | Microsoft Docs테스트API GW와 캐싱을 사용하여 어느 정도의 성능 향상이 있었는지 정리한 결과입니다. 테스트는 AWS EC2(버지니아)에서 진행하였습니다.기존 API 요청 응답시간  0.961115  0.929669  0.920897  0.912583  0.921966API GW 요청 응답시간  0.058033  0.059246  0.065591  0.057714  0.057355결과와 같이 대략 15배 이상 응답시간이 단축된것을 확인할 수 있습니다.위 설정만으로 완전한 최적화가 이루어지지는 않겠지만 글로벌 서비스를 운영하는 경우 API GW를 사용한 캐싱은성능 최적화를 위하여 고려해볼 가치가 있는것 같습니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> azure </tag>
        
          <tag> cloud </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[스프링 부트 정리]]></title>
      <url>/dev/2020/06/09/spring-boot/</url>
      <content type="text"><![CDATA[  백기선님 강의 스프링 부트 개념과 활용 정리 노트강의 내용을 다시한번 복습하기 위하여 정리합니다.작성중인 문서입니다.스프링 부트란 독립적이며, 프로덕션 레벨의 스프링 기반 어플리케이션을 간편하게 만들수 있게 도와주는 툴입니다.스프링 부트 원리  의존성 관리 이해          스프링 부트에서는 자동으로 의존성을 관리 해준다.      일반적으로 spring-boot-stater-parent에 정의되어 있는 라이브러리는 버전을 명시하지 않아도 현재 사용하는 스프링 부트 버전에 맞게 자동으로 버전을 찾아 적용한다.      parent에 등록되지 않은 라이브러리를 사용할 때는 버전을 명시해줘야 한다.      특정 버전을 사용하고 싶을땐 버전을 명시한게 우선순위를 가지게 된다.        의존성 관리 응용          의존성 추가                  스프링 부트가 관리 해주지않는 라이브러리는 버전을 명시해주는것이 좋다.                    의존성 변경                  스프링 부트가 관리해주는 버전도 변경 할 수 있다.                      자동 설정 이해          @EnableAutoConfiguration (@SpringBootApplication 안에 포함되어 있다.)                  autoconfiguration 으로 등록된 bean 은 component scan으로 등록하는 bean을 덮어 쓴다.          ConditionalOnMissingBean - 빈이 등록 되어 있지 않을때 빈 등록함.          component scan -&gt; autoConfiguration 순으로                    Spring Bean은 사실 두 단계로 나눠서 생성된다.                  1단계 : @ComponentScan          2단계 : @EnableAutoConfiguration                    @ComponentScan                  @Component          @Configuration @Repository @Service @Controller @RestController                    EnableAutoConfiguration                  spring.factories                          org.springframework.boot.autoconfigure.EnableAutoConfiguration                                @Configuration          @ConditionalOnXxxYyyZzz                    @SpringBootApplication 은 아래 3가지 애노테이션을 포함 하고 있다.                  @SpringBootConfiguration          @EnableAutoConfiguration          @ComponentScan                      내장 서블릿 컨테이너          스프링 부트는 서버가 아니다      포트 설정 가능      톰캣에 컨텍스트 추가      서블릿 만들기      톰캣에 서블릿 추가      컨텍스트에 서블릿 매핑      톰캣 실행 및 대기      이 모든 과정을 보다 상세히, 유연하게 설정하고 실행해주는게 바로 스프링 부트의 자동설정                  Step 1 : ServletWebServerFactoryAutoConfiguration (서블릿 웹 서버 생성)                          TomcatServletWebServerFactoryCustomizer (서버 커스터마이징)                                Step 2 : DispatcherServletAutoConfiguration                          서블릿 만들고 등록                                            내장 웹 서버 응용 1부 : 컨테이너와 서버 포트          다른 서블릿 컨테이너로 변경                  boot-starter에 포함된 tomcat 의존성 제외          undertow, jetty … 의존성 추가                    웹 서버 사용하지 않기                  properties에 application-type 추가                    포트 변경        내장 웹 서버 응용 2부 : https 와 http2          HTTPS 설정하기                  키스토어 만들기                          https://gist.github.com/keesun/f93f0b83d7232137283450e08a53c4fd                                HTTP는 사용못함 ?                          기본적으로 http 커넥터는 1개라 https설정을 하게 되면 http를 사용하지 못한다.              Connector를 따로 등록 해 주어야 한다.```java  /**                                  https와 http를 사용하기 위해 connector 등록.  *  */  @Bean  public ServletWebServerFactory serverFactory() {  TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();  tomcat.addAdditionalTomcatConnectors(createStandardConnector());  return tomcat;  }                                private Connector createStandardConnector() {      Connector connector = new Connector(“org.apache/.coyote.http11.Http11NioProtocol”);      connector.setPort(8080);      return createStandardConnector();  }```                                                        HTTP2                  SSL은 기본적으로 적용되어 있어야 함          undertow는 별다른 설정 없이 properties로 설정 가능          tomcat은 8.5 버전 이하에선 설정할 것들이 많아 권장하지 않음          tomcat 9 &amp; java 9 이상부터 사용 권장                    톰캣 HTTP2                  JDK9와 Tomcat 9+ cncjs          링크 참조                          링크                                          독립적으로 실행 가능한 JAR                  mvn package -&gt; 독립적으로 실행 가능한 JAR 파일 하나가 생성됨          spring-maven-plugin이 해주는 일 (패키징)          과거 “uber” jar 사용                          모든 클래스 (의존성 및 애플리케이션)을 하나로 압축하는 방법              뭐가 어디에서 온건지 알 수 없음                                  무슨 라이브러리를 사용한건지                                            내용은 다르지만 이름이 같은 파일이 또 어떻게 ?                                스프링 부트의 전략                          내장 JAR : 기본적으로 자바에는 내장 JAR를 로딩하는 표준적인 방법이 없음              애플리케이션 클래스와 라이브러리 위치 구분              org.springframework.boot.loader.jar.JarFile을 사용해서 내장 JAR 를 읽는다.              org.springframework.boot.loader.Launcher를 사용해서 실행한다.                                          스프링 부트 활용  스프링 부트 활용 소개          스프링 부트 핵심 기능                  SpringApplication          외부 설정          프로파일          로깅          테스트          Spring-Dev-Tools                    각종 기술 연동                  스프링 웹 MVC          스프링 데이터          스프링 시큐리티          REST API 클라이언트          …                      SpringApplication          기본 로그 레벨 : INFO      FailureAnalyzer      배너                  banner.txt | gif | jpg          classpath 또는 spring.banner.location          ${spring-booot.version} 등의 변수를 사용할 수 있음          Banner 클래스를 구현 후 SpringApplication.setBanner() 등으로 설정 가능                    SpringApplicationBuilder로 빌터 패턴 사용 가능.          //SpringApplication.run(SpringBootGetStartApplication.class, args);  new SpringApplicationBuilder()          .sources(SpringBootGetStartApplication.class)          .run(args);                    ApplicationEvent 등록                  ApplicationContext를 만들기 전에 사용하는 리스너는 Bean을 등록할 수 없다.                          SpringApplication.addListeners()                  // applicationStartingEvent 는 application context 생성 전에 발생하기 때문에 이렇게 등록 해줘야 한다,  SpringApplication app = new SpringApplication(SpringBootGetStartApplication.class);  app.addListeners(new SampleListener());  @Component  public class SampleListener implements ApplicationListener&lt;ApplicationStartedEvent&gt; {      @Override      public void onApplicationEvent(ApplicationStartedEvent ApplicationStartedEvent) {          System.out.println("Application is Startied");      }  }  @Component  public class SampleListener implements ApplicationListener&lt;ApplicationStartingEvent&gt;       @Override      public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) {          System.out.println("Application is Starting");      }  }                                                                        WebApplication Type 설정                  WebApplicationType                          NONE : 서블릿과 Webflux가 없을때              SERVLET : Servlet              REACTIVE : WebFlux                SpringApplication app = new SpringApplication(SpringBootGetStartApplication.class);app.setWebApplicationType(WebApplicationType.NONE);app.run(args);                                                                        애플리케이션 아규먼트 사용하기                  -D는 JVM 옵션          –Application Arguments          ApplicationArguments를 빈으로 등록해주니깐 가져다 사용하면 된다.                    애플리케이션 실행한 뒤 뭔가 다른 작업을 하고 싶을 경우                  ApplicationRunner(추천) 또는 CommandLineRunner          순서 지정 기능 @Order                      외부 설정          properties      yaml      환경 변수      커맨드 라인 아규먼트      프로퍼티 우선순위                  유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties          테스트에 있는 @TestPropertySource                          @TestPropertySource(locations = “classpath:/test.properties”)                                @SpringBootTest 애노테이션의 properties 애트리뷰트                          @SpringBootTest(properties = “dongchul.name=dong2”)                                커맨드 라인 아규먼트          SPRING_APPLICATION_JSON (환경 변수 또는 시스템 프로티) 에 들어있는 프로퍼티          ServletConfig 파라미터          ServletContext 파라미터          java:comp/env JNDI 애트리뷰트          System.getProperties() 자바 시스템 프로퍼티          OS 환경 변수          RandomValuePropertySource          JAR 밖에 있는 특정 프로파일용 application properties          JAR 안에 있는 특정 프로파일용 application properties          JAR 밖에 있는 application properties          JAR 안에 있는 application properties          @PropertySource          기본 프로퍼티 (SpringApplication.setDefaultProperties)                    application.properties 우선순위                  file:./config/          file:./          classpath:/config/          classpath:/                    랜덤 값 설정하기                  ${random.*}                    플레이스 홀더                  name = dongchul          fullName = ${name} lee                    타입 - 세이프 프로퍼티 @ConfigurationProperties          @Component  @ConfigurationProperties("dongchul")  @Validated // 프로퍼티 값을 검증 하기 위해 사용  public class DonghculProperties {      @NotEmpty      private String name;      @Size(min = 0,max = 100)      private int age;      private String fullName;      ...  }                          여러 프로퍼티를 묶어서 읽어올 수 있음.          빈으로 등록해서 다른 빈에 주입 할 수 있음                          @EnableConfigurtionProperties              @Component              @Bean                                융통성 있는 바인딩                          context-path (kebab)              context_path (under score)              contextPath (camel)              CONTEXTPATH                                프로퍼티 타입 컨버전                          @DurationUnit                                프로퍼티 값 검증                          @Validated              JSR-303(@NotNull, …)                                메타 정보 생성          @Value                          SpEL을 사용할수 있지만 위 기능들을 전부 사용하지 못한다.                                            프로파일          @Profile 애노테이션은 어디에서 사용하는가 ?                  @Configuration          @Component                    어떤 프로파일을 활성화 할 것인가 ?                  spring.profiles.active                    어떤 프로파일을 추가할 것인가 ?                  spring.profiles.include                    프로파일용 프로퍼티                  application-{profile}.properties / yml                      로깅          로깅 퍼사드 vs 로거                  Commons Logging, SLF4j          JUL, Log4J2, LogBack                    스프링 5에 로거 관련 변경 사항                  https://docs.spring.io/spring/docs/5.0.0.RC3/spring-framework-reference/overview.html#overview-logging          Spring-JCL                          Commons Logging -&gt; SLF4j or Log4j2                                          스프링 부트 로깅                  기본 포멧          –debug (일부 핵심 라이브러리만 디버깅 모드 설정)          –trace (전부 다 디버깅 모드 설정)          컬러 출력 : spring.output.ansi.enabled          파일 출력 : logging.file 또는 logging.path          로그 레벨 조정 : logging.level.패키지 = 로그레벨                    커스텀 로그 설정 파일 사용하기                  https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html          Logback : logback-spring.xml (추천, logback.xml보다 더 많은 기능을 사용할 수 있다.)              &lt;?xml version="1.0" encoding="UTF-8"?&gt;  &lt;configuration&gt;      &lt;include resource="org/springframework/boot/logging/logback/base.xml"/&gt;      &lt;logger name="me.study" level="DEBUG"/&gt;  &lt;/configuration&gt;                                Log4J2 : log4j2-spring.xml          JUL (비추) : logging.properties          Logback extention                          프로파일 &lt;springProfile name="프로파일"&gt;              Environment 프로퍼티 &lt;springProperty&gt;                                          로거를 Log4j2로 변경하기                  https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html#howto-configure-log4j-for-logging                      테스트          시작은 spring-boot-starter-test를 추가하는것 부터                  test scope로 추가                    @SpringBootTest - 통합 테스트용                  @RunWith(SpringRunner.class)랑 같이 써야함 - (Junit5 부터는 생략 가능하다.)          빈 설정 파일은 설정을 안해주나 ? 알아서 찾는다. (@SpringBootApplication)          WebEnvironment                          MOCK : mock servlet environment : 내장 톰캣 구동 안함.              RANDOM_PORT, DEFINED_PORT : 내장 톰캣 사용 함              NONE : 서블릿 환경 제공 안함                                          @MockBean                  ApplicaionContext에 들어있는 빈을 Mock으로 만든 객체로 교체 함          모든 @Test 마다 자동으로 리셋                    슬라이스 테스트                  레이어 별로 잘라서 테스트하고 싶을떄          @JsonTest          @WebMvcTest          @WebFluxTest          @DataJpaTest          …                    테스트 유틸                  OutputCapture (log 및 stdout 관련 테스트)          TestPropertyValues          TestRestTemplate          ConfigFileApplicationContextInitailizer                        /**  *  * @SpringBootTest  * 통합 테스트용  *  * @WebMvcTest(SampleContorller.class)  * 슬라이싱 테스트용  * 선언한 Controller 관련된 Bean 만 생성 하기 때문에  * Service ,Repository 같은 Bean 들은 모킹 해야 한다.  */  @RunWith(SpringRunner.class)  //@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK) // 기본값  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) // 실제로 서버가 구동됨. rest template 로 확인 해야함.  @AutoConfigureMockMvc // mock mvc를 사용 하기 위함  public class SampleControllerTest {      // async client test for webflux      // webflux의존성을 가지고 있어야 사용 가능.      @Autowired      WebTestClient webTestClient;      @Autowired      MockMvc mockMvc;      @Autowired      TestRestTemplate testRestTemplate;      @MockBean //컨트롤러 테스트를 위해 모킹.      SampleService mockSampleService;      @Test      public void hello() throws Exception {          // sample service 를 mocking          when(mockSampleService.getName()).thenReturn("dongchul");          mockMvc.perform(get("/hello"))                  .andExpect(status().isOk())                  .andExpect(content().string("hello dongchul"))                  .andDo(print());          String result = testRestTemplate.getForObject("/hello", String.class);          assertEquals(result, "hello dongchul");          webTestClient.get().uri("/hello")                  .exchange()                  .expectStatus()                  .isOk()                  .expectBody(String.class)                  .isEqualTo("hello dongchul");      }  }        Spring Boot Devtools          캐시 설정을 개발 환경에 맞게 변경.      클래스패스에 있는 파일이 변경 될 때 마다 자동으로 재시작.                  직접 껐다 켜는것(cold starts) 보다 빠르다.          릴로딩 보다는 느리다. (JRebel같은게 아님)          리스타트 하고 싶지 않은 리소스는 ? spring.devtools.restart.exclude          리스타트 기능 끄려면 ? spring.devtools.restart.enabled = false                    라이브 릴로드 ? 리스타트 했을 때 브라우저 자동 리프레시 하는 기능                  브라우저 플러그인 설치해야 함          라이브 릴로드 서버 끄려면 ? spring.devtools.liveload.enabled = false                    글로벌 설정                  ~/.spring-boot-devtools.properties                    리모트 애플리케이션        스프링 웹 MVC          레퍼런스      스프링 부트 MVC                  자동 설정으로 제공하는 여러 기본 기능(앞으로 살펴볼 예정)                    스프링 MVC 확장                  @Configuration + WebMvcConfigurer                    스프링 MVC 재정의                  @Configuration + @EnableWebMvc                    HttpMessageConverters                  HTTP 요청 본문을 객체로 변경하거나, 객체를 HTTP 응답 본문으로 변경 할 때 사용                          {“username”:”dongchul”, “password”:”123”} &lt;-&gt; User                  @PostMapping("/user")  public User create(@RequestBody User user) {      return user;  }                                                              스프링 부트                          뷰 리졸버 설정 제공              HttpMessageConvertersAutoConfiguration                                          정적 리소스 매핑 “/**”                  기본 리소스 위치                          classpath:/static              classpath:/public              classpath:/resources/              classpath:/META-INF/resources              예) “/hello.html” =&gt; static/hello.html              spring.mvc.static-path-pattern: 매핑 설정 변경 가능              spring.mvc-static-locations: 리소스 찾을 위치 변경 가능                                Last-Modified 헤더를 보고 304 응답을 보냄          ResourceHttpRequestHandler가 처리                          WebMvcConfigurer의 addResourceHandlers로 커스터마이징 가능                                          웹 JAR 맵핑 “/webjars/*”                  버전 생략 하고 사용하려면 webjars-locator-core 의존성 추가                    웰컴 페이지                  index.html 찾아보고 있으면 제공          index.템플릿 찾아보고 있으면 제공          둘다 없으면 에러페이지 노출                    파비콘                  favicon.ico 파일을 static 폴더 하위에 제공          파비콘 만들기 파비콘                    템플릿 엔진                  스프링 부트가 자동설정을 지원하는 템플릿 엔진                          FreeMarker              Groovy              Thymeleaf              Mustache                                JSP를 권장하지 않는 이유                          JAR 패키징 할 때는 동작하지 않고 WAR 패키징 해야함.              Undertow는 JSP를 지원하지 않음.                                Thymeleaf 사용하기                          https://www.thymeleaf.org              https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html              의존성 추가 : spring-boot-starter-thymeleaf              템플릿 파일 위치 : /src/main/resources/template              예제 : https://github.com/thymeleaf/thymeleafexamples-stsm/blob/3.0-master/src/main/webapp/WEB-INF/templates/seedstartermng.html                                          HTML 템블릿 뷰 테스트를 보다 전문적으로 하자.                  http://htmlunit.sourceforge.net/          http://htmlunit.sourceforge.net/gettingStarted.html          의존성 추가          @Autowired WebClient                    ExceptionHandler                  스프링 @MVC 예외 처리 방법                          @ControllerAdvice              @ExceptionHanlder                  @ExceptionHandler(SampleException.class)  public @ResponseBody AppError sampleError(SampleException e) {      AppError appError = new AppError();      appError.setMessage("error.app.key");      appError.setReason("IDK");      return appError;  }                                                              스프링 부트가 제공하는 기본 예외 처리기                          BasicErrorController                                  HTML 과 JSON 응답 지원                                            커스터마이징 방법                                  ErrorController 구현                                                              커스텀 에러 페이지                          상태 코드 값에 따라 에러 페이지 보여주기              src/main/resources/static/error/              404.html              5xx.html              ErrorViewResolver 구현                                          Spring HATEOASHypermedia As The Engine Of Application State                  서버 : 현재 리소스와 연관된 링크 정보를 클라이언트에게 제공한다.          클라이언트 : 연관된 링크 정보를 바탕으로 리소스에 접근한다.          연관된 링크 정보                          Relation              Hypertext Reference                                spring-boot-starter-hateoas 의존성 추가          https://spring.io/understanding/HATEOAS          https://spring.io/guides/gs/rest-hateoas/          https://docs.spring.io/spring-hateoas/docs/current/reference/html/          ObjectMapper 제공                          커스터마이징                                  property에 spring.jackson.* 값 변환하는 방식 추천                                            Jackson2ObjectMapperBuilder                                LinkDiscovers 제공                                          클라이언트 쪽에서 링크 정보를 Rel 이름으로 찾을 때 사용할 수 있는 XPath 확장 클래스```javapublic class Hello extends RepresentationModel {  private String prefix;                private String name;  …}                                      public Hello hello() {    Hello hello = new Hello();    hello.setName(“dongchul”);    hello.setPrefix(“Hey, “);            hello.add(linkTo(SampleController.class).withSelfRel());return hello; } ```                                          CORS                  SOP와 CORS                          Single-Origin Policy              Cross-Origin Resource Sharing              Origin ?                                  URI 스키마 (http, https)                  hostname (localhost…)                  포트 (8080, 18080)                                                              스프링 MVC @CrossOrigin                          https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web.html#mvc-cors              @Controller나 @RequestMapping에 추가 하거나                  @CrossOrigin(origins = "http://localhost:18080")  @GetMapping("/hello")  public Hello hello() {      Hello hello = new Hello();  }                                            WebMvcConfigurer 사용해서 글로벌 설정                  @Override  public void addCorsMappings(CorsRegistry registry) {      registry.addMapping("/**")              .allowedOrigins("htt://localhost:18080");  }                                                                          스프링 데이터          인메모리 데이터베이스                  지원하는 인-메모리 데이터베이스                          H2 (추천, 콘솔때문에)              HSQL              Derby                                Spring-JDBC가 클래스패스에 있으면 자동 설정이 필요한 빈을 설정 해준다.                          DataSource              JdbcTemplate                                인-메모리 데이터베이스 기본 연결 정보 확인 하는 방법                          URL : “testdb”              username : “sa”              password : “”                                H2 콘솔 사용하는 방법                          spring-boot-devtools를 추가 하거나              spring.h2.console.enabled=true 추가              /h2-console로 접속 (path변경 가능)                                          MySQL                  지원하는 DBCP                          HikariCP (기본)                                  https://github.com/brettwooldridge/HikariCP#frequently-used                                            Tomcat CP              Commonc DBCP2                                DBCP 설정                          spring.datasource.hikari.*              spring.datasource.tomcat.*              spring.datasource.dbcp2.*                                MySQL 라이센스 (GPL) 주의                          MySQL 대신 MariaDB 사용 검토              소스 코드 공개 의무 여부 확인                                MySQL 접속시 에러                          MySQL 5.* 최신 버전 사용할 때 문제                                  Sat Jul 21 11:17:59 PDT 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.                                            해결                                  jdbc:mysql:/localhost:3306/springboot?useSSL=false                                            MySQL 8.* 최신 버전 사용할 때 문제                                  com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed                                            해결                                  jdbc:mysql:/localhost:3306/springboot?useSSL=false&amp;allowPublicKeyRetrieval=true                                                                        PostgreSQL                  Mysql 과는 달리 라이센스 문제가 없다. 가장 추천하는 DB                    Spring-Data-JPA                  ORM(Object-Relational Mapping)과 JPA (Java Persistence API)                          객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크              http://hibernate.org/what-is-an-orm              JPA: ORM을 위한 자바(EE) 표준                                스프링 데이터 JPA                          Repository 빈 자동 생성              쿼리 메소드 자동 구현              @EnableJpaRepositories (스프링 부트가 자동으로 설정 해줌.)                                스프링 데이터 JPA 사용하기                          @Entity 클래스 만들기              Repository 만들기                                스프링 데이터 리파지토리 테스트 만들기                          H2 DB를 테스트 의존성에 추가하기              @DataJpaTest (슬라이스 테스트) 작성                                  테스트를 실행할 때는 Inmemory DB를 사용하는것을 추천.                    @RunWith(SpringRunner.class)@DataJpaTest // 슬라이싱 테스트 DataSource, JdbcTemplate, Repository 등을 주입 받는다. 인메모리 데이터 베이스가 반드시 필요함public class AccountRepositoryTest {    @Autowired    DataSource dataSource;    @Autowired    JdbcTemplate jdbcTemplate;    @Autowired    AccountRepository accountRepository;    ...}                                                                                                    JPA를 사용한 데이터베이스 초기화                          spring.jpa.hibernate.dll.auto                                  create                  create-drop                  update                  validate                                            spring.jpa.generate-dll=true로 설정 해줘야 한다.                                SQL 스크립트를 사용한 데이터베이스 초기화                          schema.sql 또는 schema-${platform}.sql              data.sql 또는 data-${platform}.sql              ${platform} 값은 spring.datasource.platform으로 설정 가능.                                데이터베이스 마이그레이션 툴                          Flyway 와 Liquibase가 대표적, Flyway 사용              https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/#howto-execute-flyway-database-migrations-on-startup              의존성 추가                                  org.flywaydb:flyway-core                                            마이그레이션 디렉토리                                  /resource/db/migration 또는 db/migration/{vendor}                  spring.flyway.location으로 변경 가능                                            마이그레이션 파일 이름                                  한번 적용이 된 파일은 절대 수정하면 안되고 새로운 파일을 만들어서 버전을 올려야 한다.                  V숫자__이름.sql                  V는 꼭 대문자                  숫자는 순차적으로 (타임스템프 권장)                  숫자와 이름 사이에 언더바 두개                  이름은 가능한 서술적으로                                                              Redis                          캐시, 메시지 브로커, 키/벨류 스토어 등으로 사용 가능              의존성 추가                                  spring-boot-starter-data-redis                                            스프링 데이터 Redis                                  https://projects.spring.io/spring-data-redis/                  StringRedisTemplate 또는 RedisTemplate                  extends CrudRepository                                            Redis 주요 커맨드                                  https://redis.io/commands                  keys *                  get {key}                  hgetall {key}                  hget {key} {column}                                            커스터마이징                                  spring.redis.*                                                              MongoDB                          스프링 데이터 몽고 DB                                  Mongotemplate                  MongoRepository                  내장형 MongoDB (테스트용)                                          de.flapdoodle.embed:de.flapdoodle.embed.mongo                                                        @DataMongoTest                                                              Neo4J                          Neo4j는 노드간의 연관 관계를 영속화 하는데 유리한 그래프 데이터베이스              스프링 데이터 Neo4J                                  Neo4jTemplate (Deprecated)                  SessionFactory                  Neo4jRepository                                                                        ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[스프링 프레임워크 핵심 정리]]></title>
      <url>/dev/2020/06/05/spring-framework/</url>
      <content type="text"><![CDATA[  백기선님 강의 스프링프레임워크 핵심 기술 정리 노트강의 내용을 다시한번 복습하기 위하여 정리합니다.IoC 컨테이너스프링 IoC 컨테이너와 빈Inverse of Controll : 의존 관계 주입(Dependency Injection)이라고 하며 어떤 객체가 사용하는 의존객체를 직접 생성하지 않고외부로부터 주입 받아 사용하는 방법의존 관계 주입에 대한 장점을 더 알아보시려면 Open Close Principal에 대하여 공부해보시는 것을 추천 드립니다.  스프링 IoC 컨테이너          BeanFactory : 스프링 빈 컨테이너에 접근하기 위한 최상위 인터페이스      애플리케이션 컴포넌트의 중앙 저장소      빈 설정소스로 부터 빈 정의, 빈을 구성하고 제공하는 역할을 한다.        Bean이란 ?          스프링 IoC 컨테이너가 관리하는 객체      장점                  의존성 관리          스코프                          싱글톤 : 흔히 알고 있는 싱글톤 패턴과 같이 하나만 생성              프로포토 타입 : 빈이 생성될 때 마다 매번 다른 객체를 생성하는 방법                @Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)                                                                          ApplicationContext          BeanFactory를 상속받고, 스프링에서 제공하는 다양한 기능을 사용할 수 있는 인터페이스        public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,    MessageSource, ApplicationEventPublisher, ResourcePatternResolver                    메시지 소스 처리 (i18n)      이벤트 발생 기능      리소스 로딩 기능      …      ApplicationContext와 다양한 빈 설정 방법  스프링 IOC 컨테이너의 역할          빈 인스턴스 생성      의존 관계 설정      빈 제공        ApplicationContext          ClassPathXmlApplicationContext : Class Path에 정의되어 있는 파일을 읽어 빈을 생성      AnnotationConfigApplicationContext : Annotation 기반 빈 생성        빈 설정          빈 명세서      빈에 대한 정의를 담고 있다.                  이름          클래스          스코프          생성자 (Constructor)          프로퍼트 (Setter)                      컴포넌트 스캔          설정 방법                  XML - context:component-scan          java - @ComponentScan                    특정 패키지 이하의 모든 클래스 중 @Component 애노테이션을 사용한 클래스를 빈으로 등록      @Autowire필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다.  @Autowired          required : 기본값이 true 이기 때문에 어플리케이션 구동 시 주입할 빈을 찾지 못하면 어플리케이션이 실행되지 않는다.        현재는 @Autowired를 통한 빈 주입방식 보다는 생성자를 사용한 빈 주입 방식을 사용해야한다.  사용 할 수 있는 위치          생성자 (스프링 4.3 부터는 생략 가능)      세터, 필드        경우의 수          해당 타입의 빈이 없는 경우 - 실패      해당 타입의 빈이 한 개인 경우      해당 타입의 빈이 여러 개인 경우                  빈 이름으로 시도                          같은 이름의 빈을 찾으면 해당 빈 사용                                  같은 이름을 못 찾으면 실패                                                              @Primary          해당 타입의 빈을 모두 주입          @Qualifier (빈 이름으로 주입)                    동작 원리                  BeanPostProcessor                          빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스              postProcessAfterInitialization, postProcessBeforeInitialization 인터페이스를 제공한다.                                AutowiredAnnotationBeanPostProcessor                          BeanPostProcessor를 구현한 클래스 이며 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기.              that autowires annotated fields, setter methods, and arbitrary config methods                                          @Component와 컴포넌트 스캔  컴포넌트 스캔의 주요 기능          스캔 위치 설정      필터 : 어떤 애노테이션들을 스캔할지 또는 하지 않을지        @Component 종류          @Repository      @Service      @Controller      @Configuration                  tmi : Repository나 Service같은 애노테이션 이름은 에릭 에반스의 DDD에서 유래되었다고 적혀있다.                      동작원리          @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보      실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨.      빈 스코프  Scope          Singleton - 기본      ProtoType - 모든 요청에서 새로운 Bean을 생성한다.                  Request          Sesseion          WebSocket          …                    https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html        프로토 타입 빈이 싱글톤 빈을 참조 하면 ?          정상 실행        싱글톤 빈이 프로토 타입 빈을 참조하면 ?          프로토 타입 빈이 업데이티 되지 않는다.      업데이트 하려면                  scoped-proxy          Object-Provider          Provider (표준)                    https://www.baeldung.com/spring-inject-prototype-bean-into-singleton        싱글톤 객체 사용시 주의할 점          상태값 공유      ApplicationContext 초기 구동시 인스턴스 생성      Environment 1부 - Profile프로파일과 프로퍼티를 다루는 인터페이스  ApplicationContext extends EnvironmentCapable      public interface EnvironmentCapable {      Environment getEnvironment();  }        프로파일          빈들의 그룹      Environment의 역할은 활성화 할 프로파일 확인 및 설정        프로파일 유즈케이스          테스트 환경에서는 A라는 빈 사용, 배포 환경에서는 B라는 빈을 사용하고 싶다.      서비스 환경에만 등록 하기 위한 빈 설정        프로파일 정의하기          Class        @Configuration @Profile(“test”)@Component @Profile(“test”)                    Method        @Bean @Profile(“test”)                      프로파일 설정하기          -Dspring.profiles.avtive=”test,A,B,…”      @ActiveProfiles(“test”)        프로파일 표현식          !, &amp;, | 와 같은 표현식으로 여러가지 경우를 계산할 수 있다.      Environment 2부 - Property  프로퍼티란 ?          다양한 방법으로 정의할 수 있는 설정값      Environment의 역할은 프로퍼티 소스 설정 및 값 가져오기        프로퍼티 우선순위          StandardServletEnvironment의 우선순위                  ServletConfig 매개변수          ServletContext 매개변수          JNDI (java:comp/env/)          JVM 시스템 프로퍼티 (-Dkey=”value”)          JVM 시스템 환경 변수 (운영 체제 환경 변수)                      @PropertySource          Environment를 통해 프로퍼티 추가하는 방법        스프링 부트의 외부 설정 참고          기본 프로퍼티 소스 지원 (application.properties)      프로파일 까지 고려한 계층형 프로퍼티 우선순위 제공      MessageSource다양한 언어 지원기능을 제공하는 인터페이스  ApplicationContext extends MessageSource        public interface MessageSource {      @Nullable        String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);      ...    }        스프링 부트를 사용한다면 별다른 설정 필요없이 message.properties를 사용할 수 있음.          messages.properties      messages_ko_kr.properties        Reloading 기능을 제공하는 MessageSource      @Bean  public MessageSource messageSource() {    var messageSource = new ReloadableResourceBundleMessageSource();    messageSource.setBasename("classpath:/messages");    messageSource.setDefaultEncoding("UTF-8");    messageSource.setCacheSeconds(3);    return messageSource;  }        ApplicationEventPublisher    이벤트 프로그래밍에 필요한 인터페이스 제공 옵저버패턴 구현체    ApplicationContext extends ApplicationEventPublisher      @FunctionalInterface  public interface ApplicationEventPublisher {    default void publishEvent(ApplicationEvent event) {      publishEvent((Object) event);    }    void publishEvent(Object event);  }        이벤트 만들기          ApplicationEvent 상속      스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다.        이벤트 처리하는 방법          ApplicationListener 구현한 클래스 만들어서 빈으로 등록하기.      스프링 4.2 부터는 @EventListener를 사용해서 빈의 메소드에 사용할 수 있다.      기본적으로는 synchronized.      순서를 정하고 싶다면 @Order와 함께 사용.      비동기적으로 실행하고 싶다면 @Async와 함께 사용.        스프링이 제공하는 기본 이벤트          ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.      ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생.      ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생.      ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생.      RequestHandledEvent: HTTP 요청을 처리했을 때 발생.        @Component  public class AppRunner implements ApplicationRunner {      @Autowired      ApplicationEventPublisher eventPublisher; // 이벤트를 넘겨주기 위한 객체      @Override      public void run(ApplicationArguments args) throws Exception {          eventPublisher.publishEvent(new MyEvent(this, 100));      }  }  @Component  public class MyEventHandler {    @EventListener      @Async    public void handle(MyEvent myEvent) {        System.out.println(Thread.currentThread().toString());        System.out.println("event" + myEvent.getData());    }  }사용법ResourceLoader리소스를 읽어오는 기능을 제공하는 인터페이스  ApplicationContext extedns ResoruceLoader      public interface ResourceLoader {      String CLASSPATH_URL_PREFIX = "classpath:";      Resource getResource(String var1);      @Nullable      ClassLoader getClassLoader();  }        리소스 읽어오기          파일 시스템에서 읽어오기      클래스패스에서 읽어오기      URL로 읽어오기      상대/절대 경로로 읽어오기        @Componentpublic class AppRunner implements ApplicationRunner {  @Autowired  ApplicationContext applicationContext;  @Override  public void run(ApplicationArguments args) throws Exception {      System.out.println(applicationContext.getClass());      Resource resource = applicationContext.getResource("classpath:test.txt");      System.out.println(resource.getClass());      System.out.println(resource.exists());      System.out.println(resource.getDescription());      System.out.println(Files.readString(Path.of(resource.getURI())));  }}                    Resource 추상화  특징          java.net.URL을 추상화 한것      스프링 내부에서 많이 사용하는 인터페이스        추상화 한 이유          클래스 패스 기준으로 리소스 읽어오는 기능 부재      ServletContext를 기준으로 상대 경로를 읽어오는 기능 부재      새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수 있지만 구현이 복잡하고 편의성 메소드가 부족하다.        Resource          상속 받은 인터페이스      주요 메소드                  getInputStream()          exitst()          isOpen()          getDescription(): 전체 경로 포함한 파일 이름 또는 실제 URL                      구현체          UrlResource : 기본으로 지원하는 프로토콜 http, https, ftp, file, jar      ClassPathResource : 지원하는 접두어 classpath:      FileSystemResource      ServletContextResource : 웹 어플리케이션 루트에서 상대 경로로 리소스를 찾는다.      …        리소스 읽어오기          Resource의 타입은 locaion 문자열과 ApplicationContext의 타입에 따라 결정 된다.                  ClassPathXmlApplicationContext -&gt; ClassPathResource          FileSystemXmlApplicationContext -&gt; FileSystemResource          WebApplicationContext -&gt; ServletContextResource                    ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL 접두어(+ classpath:)중 하나를 사용할 수 있다.                  classpath:me/whiteship/config.xml -&gt; ClassPathResource          file:///some/resource/path/config.xml -&gt; FileSystemResourc                    Validation 추상화애플리케이션에서 사용하는 객체 검증용 인터페이스  특징          어떠한 계층과도 관계가 없다. -&gt; 모든 계층(웹, 서비스, 데이터)에서 사용할 수 있다.      구현체 중 하나로, JSR-303(Bean Validation 1.0)과 JSR-349(Bean Validation 1.1)을 지원한다.        인터페이스          boolean support(Class clazz) : 어떤 타입의 객체를 검증할 때 사용할 것인지 결정      void validate(Object obj, Errors e) : 실제 검증 로직을 이 안에서 구현                  구현 시 ValidationUtils를 사용하며 편리                      스프링 부트 2.0.5 이상 버전을 사용할 때          LocalValidatorFactoryBean 빈으로 자동 등록      JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용.      https://beanvalidation.org/      public class Event {    Integer id;    @NotEmpty    String title;    @Min(value = 0)    Integer limit;    @Email    String email;}public class EventValidator implements Validator {    @Override    public boolean supports(Class&lt;?&gt; aClass) {        return Event.class.equals(aClass);    }    @Override    public void validate(Object o, Errors errors) {        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "title", "notempty", "Empty title is not allow"); // errorcode는 messagesource에서 가지고 온다.    }}  참고 : 스프링 부트 2.3 버전 부터 spring-boot-starter-web에서 validtaion이 분리됨.spring-boot-starter-validation을 추가해줘야 한다.데이터 바인딩 추상화 : PropertyEditorDataBinder  기술적인 관점          프로퍼티 값을 타겟 객체에 설정하는 기능        사용자 관점          사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능      입력값 대부분은 “문자열”이지만 그 값을 객체가 가지고 있는, int, String, long, Boolean 심지어 사용자 도메인으로 변환하여 넣어준다.        PropertyEditor          스프링 3.0 이전까지 DataBinder가 변환 작업시 사용하던 인터페이스      thread - safe하지 않다.      Object와 String 간의 변환만 할수 있어 사용범위가 제한적.      public class EventPropertyEditor extends PropertyEditorSupport {  @Override  public String getAsText() {    return ((Event)getValue()).getTitle();  }  @Override  public void setAsText(String text) throws IllegalArgumentException {    int id = Integer.parseInt(text);    Event event = new Event();    event.setId(id);    setValue(event);  }}데이터 바인딩 추상화 : Converter와 Formmater  Converter          S 타입을 T 타입으로 변환할 수 있는 일반적인 변환기      상태값이 없다 -&gt; Thread Safe하다      ConverterRegistry에 등록하여 사용        @RestControllerpublic class EventController {    @GetMapping("/event/{event}")    public String getEvent(@PathVariable Event event) {        return event.getId().toString();    }}@Componentpublic static class StringToEventConverter implements Converter&lt;String, Event&gt; {    @Override    public Event convert(String s) {        return new Event(Integer.parseInt(s));    }}@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addConverter(new StringToEventConverter());    }        }                      Formatter          PropertyEditor 대체제      Object와 String 간의 변환을 담당한다.      문자열을 Locale에 따라 다국화하는 기능도 제공한다. (optional)      FormatterRegistry에 등록해서 사용        //thread safe 하여 bean 등록 가능 및 다른 bean 주입 가능//data binding 관련해서 사용할 경우 event formatter를 사용하는것을 추천.@Componentpublic class EventFomatter implements Formatter&lt;Event&gt; {    @Autowired    MessageSource messageSource;    @Override    public Event parse(String s, Locale locale) throws ParseException {        return new Event(Integer.parseInt(s));    }    @Override    public String print(Event event, Locale locale) {        return event.getId().toString();    }}@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addFormatter(new EventFomatter());    }}                      ConversionService          실제 변환 작업은 이 인터페이스를 통해서 thread-safe 하게 사용할 수 있음.      스프링 MVC, 빈 (value) 설정, SpEL에서 사용한다.      DefaultFormattingConversionService                  FormatterRegistry          ConversionService          여러 기본 컴버터와 포매터 등록 해 줌.                      스프링 부트          웹 애플리케이션인 경우에 DefaultFormattingConversionSerivce를 상속하여 만든 WebConversionService를 빈으로 등록해 준다.public class WebConversionService extends DefaultFormattingConversionService      Formatter와 Converter 빈을 찾아 자동으로 등록해 준다.      @Componentpublic class AppRunner implements ApplicationRunner {    @Autowired    ConversionService conversionService;    @Override    public void run(ApplicationArguments args) throws Exception {        System.out.println(conversionService); // 등록된 converter를 확인 하는 방법.        System.out.println(conversionService.getClass().toString());    }}SpEL(Spring Expression Language)  SpEL 이란 ?          객체 그래프를 조회 및 조작하는 기능 제공      메소드 호출 지원, 문자열 템플릿 기능도 제공      SpEL은 모든 스프링 프로젝트 전반에서 사용하기 위한 EL로 만들어졌다.      스프링 3.0 부터 지원        SpEL 구성          ExpressionParser parser = new SpelExpressionParser()      StandardEvaluationContext context = new StandardEvaluationContext(bean)      Expression expression = parser.parseExpression(“SpEL 표현식”)      String value = expression.getValue(context, String class)        문법          #{“표현식”}      ${“프로퍼티”}      표현식은 프로퍼티를 가질 수 있지만 반대는 안된다.                  #{${my.data} + 1}                    레퍼런스        사용처          @Value 애노테이션 참고      @ConditionalOnExpression 애노테이션      Spring Security                  Method Security, @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter          XML 인터셉터 URL 설정          …                    스프링 데이터                  @Query 애노테이션                    …        @Value("#{1 + 1}")int value;@Value("#{'hello ' + 'world'}")String greeting;@Value("#{1 eq 1}")boolean trueOrFalse;@Value("${my.value}")int myValue;@Value("#{${my.value} eq 100}")boolean isMyValue100;@Value("#{sample.data}")int sampleData;                    스프링 AOPAspect - Oriented Programming (AOP)는 OOP를 보완하는 수단으로, 흩어진 Aspect를 모듈화 할 수 있는 프로그래밍 기법  AOP 주요 개념          Aspect : 흩어진 관심사      Target : Ascpect를 적용하는 매체 (class, method)      Advice : 실직적인 부가 기능을 실행하는 구현체      Join Point와 Pointcut : advice를 실행할 위치, 포지션, 실행 전후 처리 등을 설정하는 기능        AOP 구현체          자바                  AspectJ          스프링 AOP                      AOP 적용 방법          컴파일      로드 타임      런타임      프록시 기반 AOP  스프링 AOP 특징          프록시 기반의 AOP구현체      스프링 빈에만 AOP를 적용할 수 있다.      모든 AOP기능을 제공하는 것이 목적이 아니라, 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 제공하는것이 목적.        프록시 패턴          기존 코드의 변경없이 접근제어 또는 부가 기능을 추가할 수 있는 대리자 패턴        문제점          매번 프록시 클래스를 작성해야 하는가 ?      여러 클래스, 여러 메소드에 적용하려면 ?        스프링 AOP          스프링 IoC컨테이너가 제공하는 기반 시설과 Dynamic 프록시를 사용하여 여러 복잡한 문제 해결      동적 프록시 : 동적으로 프록시 객체를 생성하는 방법                  자바가 제공하는 방법은 인터페이스 기반 프록시 생성          CGlib는 클래스 기반 프록시도 지원                    스프링 IoC : 기존 빈을 대체하는 동적 프록시 빈을 만들어 등록 시켜준다.                  클라이언트 코드의 변경이 없다.          public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware                    @AOP애노테이션 기반의 스프링 @AOP  Aspect 정의          @Aspect      빈으로 등록해야 하니깐 @Component 추가        포인트 컷 정의          @Pointcut(표현식)      주요 표현식                  execution          @annotaion          bean                    포인트 컷 조합                  &amp;&amp;, ||, !                      어드바이스 정의          @Before      @AfterReturning      @AfterThrowing      @Around          //Annotation 사용시 Retentionpolicy를 class 이상으로 적용해야 한다.Class파일까지 남아있어야 하기 때문에    // 기본값 class    @Retention(RetentionPolicy.CLASS)    @Target(ElementType.METHOD)    @Documented    public @interface PerfLogging {}    @PerfLogging    public void createEvent() {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("createEvent");    }    @Around("@annotation(PerfLogging)")    public Object logPerf(ProceedingJoinPoint pjp) throws Throwable{        long begin = System.currentTimeMillis();        Object proceed = pjp.proceed();        System.out.println(System.currentTimeMillis() - begin);        return proceed;    }    @Before("bean(simpleEventService)")    public void hello() {        System.out.println("Hello");    }]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[테스트 코드를 작성하는 다양한 방법]]></title>
      <url>/dev/2020/06/02/test-code/</url>
      <content type="text"><![CDATA[  테스트 코드를 작성하는 다양한 방법테스트 코드를 작성하는 다양한 방법Spring Boot 2.2.X 버전 부터 기존에 사용하던 Junit4 가 아닌 Junit5가 기본 디펜던시로 추가 되었습니다.Junit4를 사용하지 못하는건 아니지만 스프링이 Junit5를 완전히 지원한다는 이야기니 왠만하면 Junit5를 사용합시다.테스트 코드를 작성하는 3가지 방법을 소개 하나 각 방법에 대하여 깊은 이해가 있지 않아 맛보기 식으로 공유해드리겠습니다.우선 Junit5 에서는 @RunWith(SpringRunner.class) 라는 애노테이션이 필요 없어졌습니다.대신 Extend 기능을 활용해서 필요한 디펜던시를 추가할 수 있습니다.BeforeAll, BeforeEach 등의 애노테이션을 사용해서 테스트 메소드 실행전 필요한 객체를 생성 하도록 변경되었습니다.주로 사용하는 기능  Setup 기능 :  BeforeEach , BeforeAll 등의 애노테이션으로 테스트 시작 전 필요한 데이터를 설정 할 수 있음. IntelliJ 에서 지원.          BeforeAll 같은 경우 Junit4에서는 지원하지 않던 Static한 데이터 공유가 가능함.        DisplayName  : 테스트의 이름을 표시 할 수 있는 기능.  ParameterizeTest  : 테스트 실행시 필요한 파라미터를 전달하여 @ValueSource사용 실행이 가능함.  ActiveProfile : 테스트 프로퍼티를 별도로 관리할 경우 테스트 프로파일 설정.그 외로 새롭게 사용할 수 있는 기능들은 Docs를 확인해주시길 바랍니다.JUnit 5 User GuideSpringBootTest 를 이용한 컨트롤러 통합 테스트@SpringBootTest 애노테이션을 테스트 환경에서 사용할 시 SpringBoot Application이 구동되어 등록되어 있는 빈을 전부 로드하게 됩니다.이로 인해서 테스트는 등록된 빈을 사용해서 모든 로직등 실제 사용하는 빈을 통하여 실행되게 됩니다.통합 테스트MockMvc 을 사용하기 위해서 @AutoConfigureMockMvc 애노테이션을 등록합니다.MockMvc 객체는 테스트 코드에서 Http요청을 보낼수 있도록 도와주는 객체 입니다.슬라이싱 테스트  @DataJpaTest : JpaRepository 테스트 시 사용  @EnableWebMvc : Controller 테스트…  참고 : 테스트 코드에서 @Transaction애노테이션을 사용할 경우 기본 Rollback정책이 True이므로 Rollback하지 않는 데이터를 확인 하기 위해선 false로 지정 해줘야 합니다.Model 검증@Test@DisplayName("index 페이지 정상 작동")public void indexPage() throws Exception {    ResultActions resultActions = mockMvc.perform(get("/index"))            .andDo(print())            .andExpect(status().isOk());    MvcResult mvcResult = resultActions.andReturn();    Map&lt;String, Object&gt; model = 	mvcResult.getModelAndView().getModel();    assertThat(model.get("facebookAppId")).isNotNull();    assertThat(model.get("kakaoAppId")).isNotNull();    assertThat(model.get("s3Uri")).isNotNull();    assertThat(model.get("tagManagerCode")).isNotNull();    assertThat(model.get("host")).isNotNull();}API 검증@Test@DisplayName("상품 정상 생성")void create() throws Exception {    String productName = "간장치킨";    BigDecimal price = BigDecimal.valueOf(17000);    Product product = createProduct(productName, price);    mockMvc.perform(post("/api/products")            .contentType(MediaType.APPLICATION_JSON)            .content(objectMapper.writeValueAsString(product)))            .andDo(print())            .andExpect(status().isCreated())            .andExpect(header().exists(HttpHeaders.LOCATION))            .andExpect(jsonPath("id").exists())            .andExpect(jsonPath("name").value(productName))            .andExpect(jsonPath("price").value("17000.0"))            ;}Mockito 를 이용한 단위 테스트특정 객체를 Mocking하여 단위 테스트를 하기 위해선 일반적으로 Mockito를 활용하여 테스트 합니다.Mocking을 하는 이유는 개인적으로는 단위 테스트를 정확하게 하고자 함에 있다고 생각합니다.여기서 말하는 정확한 단위 테스트는 예를 들면 Service Layer를 테스트 할때 Dao (Repository) 에서 발생하는 이슈가 테스트에 영향을 끼치지 않게 함에 있습니다.Service Logic 을 정확히 테스트 하고 Repository는 따로 Repository 테스트를 만들어서 테스트 함을 권장하고 있습니다.Mocking을 통한 테스트를 작성하려면 @ExtendWith(MockitoExtension.class) 애노테이션을 사용하면 됩니다.@Mock // 객체 Mockingprivate MenuGroupDao menuGroupDao;@InjectMocks // Mock 객체 주입private MenuGroupBo menuGroupBo;위 코드와 같이 Mock객체를 주입 받아 테스트를 실행할 객체를 설정합니다.Mocking 된 객체는 Stubbing을 통하여 객체의 행동을 조작할 수 있습니다.given(menuGroupDao.findAll()).willReturn(menuGroups); // BDD stylewhen(menuGroupDao.findAll()).thenReturn(menuGroups);given또는 when ~ 메서드를 사용하여 객체의 행동을 조작합니다.조작한 행동을 통하여 원하는 결과가 나오는지 확인을 할 수 있습니다.샘플코드@DisplayName("테이블 착석 상태를 비움으로 변경")@Testvoid changeEmpty() {    OrderTable requestOrderTable = new OrderTableBuilder()            .setEmpty(true)            .build()            ;    OrderTable orderTable = new OrderTableBuilder()            .setEmpty(false)            .setId(1L)            .build()            ;    when(orderTableDao.findById(orderTable.getId())).thenReturn(Optional.of(orderTable));    when(orderDao.existsByOrderTableIdAndOrderStatusIn(orderTable.getId(),            Arrays.asList(OrderStatus.COOKING.name(), OrderStatus.MEAL.name()))).thenReturn(false);    when(orderTableDao.save(orderTable)).thenReturn(orderTable);    OrderTable changedOrderTable = tableBo.changeEmpty(orderTable.getId(), requestOrderTable);    assertThat(changedOrderTable.isEmpty()).isTrue();}많은 기능이 존재함으로 역시나 문서를 확인 합니다.Mockito (Mockito 3.2.4 API)Fake Object 를 이용한 단위 테스트Fake Object 라는 개념이 혼란 스러울수 있습니다.이 개념은 Mocking 과 비슷하면서도 다른 개념이라 아직 제대로 이해하지 못하였습니다.Fake Object 를 사용하는 이유에 대하여 설명드리자면 Mocking을 통한 테스트는 실제 로직이 어떻게 돌아가는지 다 알고 있는 상태여야 합니다. 그래서 원하는 결과값을 (행위에 대한 결과)를 받을수 있도록 Stubbing 합니다. 일명 Whitelist Test 라고 할 수 있습니다.반면에 Fake Object를 사용하면 어떤 로직이 실행되는지 전혀 알 필요가 없고 가짜 객체를 통한 실행 결과만 받을 수 	있으면 테스트를 작성 할 수 있게 됩니다.샘플코드private ProductDao productDao = new FakeProductDao();private ProductBo productBo;@BeforeEachvoid setUp() {    productBo = new ProductBo(productDao);}@DisplayName("상품을 등록 할 수 있다")@Testvoid create() {    //given    Product expected = new Product();    expected.setId(1L);    expected.setName("치킨");    expected.setPrice(BigDecimal.valueOf(16_000L));    //when    Product actual = productBo.create(expected);    //then    assertThat(actual).isNotNull();    assertThat(actual.getName()).isEqualTo(expected.getName());    assertThat(actual.getPrice()).isEqualTo(expected.getPrice());}public class FakeProductDao implements ProductDao {    private Map&lt;Long, Product&gt; entities = new HashMap&lt;&gt;();    @Override    public Product save(Product entity) {        entities.put(entity.getId(), entity);        return null;    }    @Override    public Optional&lt;Product&gt; findById(Long id) {        return Optional.ofNullable(entities.get(id));    }    @Override    public List&lt;Product&gt; findAll() {        return new ArrayList&lt;&gt;(entities.values());    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Test </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringSecurity-WithSecurityContextFactory 소개]]></title>
      <url>/dev/2020/05/23/spring-security-with-security-context-factory/</url>
      <content type="text"><![CDATA[  스프링 시큐리티를 사용하여 테스트 코드를 작성하는 경우 Authentication 정보를 자동으로 담아주지 못하여 테스트 코드 작성이 힘들어지는 경우가 있다. 이런경우에 테스트코드 작성을 편하게 할 수 있는 방법을 소개 합니다.SpringSecurity-WithSecurityContextFactory 소개  해당 기능은 백기선님의 강의(스프링과 JPA기반 웹 애플리케이션 개발)를 참고 하였습니다.샘플 프로젝트는 Spring Boot + JPA + Spring Security 로 구성되어 있습니다.샘플 코드테스트는 서비스 및 도메인의 단위 테스트가 아닌 통합 테스트를 진행한다고 가정합니다.@Transactionalpublic CreateResponse create(CreateRequest createRequest) {    Board board = createRequest.toEntity();    Board savedBoard = boardRepository.save(board);    return new CreateResponse(savedBoard);}단순히 Board Entity를 저장하는 기능을 제공하는 서비스 코드 입니다.위 코드를 검증하기 위하여 Test 를 작성할 경우 일반적인 환경에서는 정상적으로 동작하겠지만, Security가 포함된다면 예기치 못한 이슈가 발생할 수 있습니다.@Overrideprotected void configure(HttpSecurity http) throws Exception {    http.csrf()            .disable()        .authorizeRequests()            .mvcMatchers("/sign-up").permitAll()        .anyRequest()            .authenticated()        .and()        .formLogin()        .and()        .httpBasic();}Security 설정입니다.  /sign-up 을 제외한 모든 api는 인증된 사용자만 접근이 가능하도록 설정 해둔 경우 위 코드를 검증하기 위해선 몇가지 방법이 존재할 수 있습니다. Spring Security Reference를 보면 아래와 같은 기능들을 제공해주고 있습니다.https://docs.spring.io/spring-security/site/docs/current/reference/html5  @WithMockUser 사용  @WithUserDetails 사용  @WithSecurityContext 사용하나씩 살펴보면 내용이 길어지므로 레퍼런스를 확인해주시면 될것 같습니다. 간단하게 요약하자면 Security Filter를 통과 하기 위해선 위 2가지 기능만 사용하면 통과 할 수 있지만 지금 살펴볼 기능은 3번째 기능을 사용해야 편하고 간단하게 테스트 코드를 작성할 수 있습니다.@MappedSuperclass@Getterpublic class BaseEntity extends BaseTimeEntity {    @Column(updatable = false)    private Long createdBy;    private Long lastUpdatedBy;    @PrePersist    public void prePersist() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        createdBy = userAccount.getAccount().getId();        lastUpdatedBy = userAccount.getAccount().getId();    }    @PreUpdate    public void preUpdate() {        SecurityContext context = SecurityContextHolder.getContext();        UserAccount userAccount = (UserAccount) context.getAuthentication().getPrincipal();        lastUpdatedBy = userAccount.getAccount().getId();    }}위 코드와 같이 Entity가 저장되거나 수정되는 경우 자동으로 Authentication에서 값 저장하는 코드가 존재한다면, 테스트코드가 동작할 때 Authentication객체가 필요하게 됩니다.간단하게 생각하자면, 테스트를 실행하기전 Authentication객체를 만들고, SecurityContextHolder에 담아 테스트를 실행하면 되지만, 모든 테스트 클래스에서 중복된 코드가 발생하게 될것이므로 정신건강에 좋지 않을것 같습니다.이러한 기능을 간편하게 애노테이션으로 정의하여 사용하는 WithSecurityContextFactory 를 사용해 봅시다.@Retention(RetentionPolicy.RUNTIME)@WithSecurityContext(factory = WithAccountSecurityContextFactory.class, setupBefore = TestExecutionEvent.TEST_EXECUTION)public @interface WithAccount {    String value();}우선 WithSecurityContext를 정의한 애노테이션을 작성합니다.@RequiredArgsConstructorpublic class WithAccountSecurityContextFactory implements WithSecurityContextFactory&lt;WithAccount&gt; {    private final AccountService accountService;    @Override    public SecurityContext createSecurityContext(WithAccount withAccount) {        String username = withAccount.value();        String email = username + "@gmail.com";        String password = "password";        AccountCreateRequest accountCreateRequest = new AccountCreateRequest();        accountCreateRequest.setEmail(email);        accountCreateRequest.setPassword(password);        accountCreateRequest.setNickname(username);        accountService.saveAccount(accountCreateRequest);        UserDetails userDetails = accountService.loadUserByUsername(email);        Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails,                userDetails.getPassword(), userDetails.getAuthorities());        SecurityContext context = SecurityContextHolder.createEmptyContext();        context.setAuthentication(authentication);        return context;    }}그후 WithSecurityContextFactory을 구현한 클래스를 만든 뒤, Authentication객체를 생성, SecurityContext에 담아주는것으로 구현이 끝납니다.사용하는 방법도 간단합니다.@DisplayName("보드 조회 - 단건")@WithAccount("dongchul")@Testvoid findBoard() throws Exception {    CreateRequest createRequest = new CreateRequest();    createRequest.setTitle("title");    boardService.create(createRequest);    mockMvc.perform(get(BoardApiController.BOARD_URI + "/1"))            .andDo(print())            .andExpect(status().isOk())            .andExpect(jsonPath("title").exists());}위와 같이 테스트 코드 실행시 만들어둔 애노테이션을 사용하기만 하면 테스트가 정상적으로 실행됩니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Spring </tag>
        
          <tag> Security </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[책임 주도 설계 정리]]></title>
      <url>/dev/2020/05/15/grasp/</url>
      <content type="text"><![CDATA[  책임 주도 설계 정리, 작성중입니다.책임 주도 설계 흐름  시스템이 사용제에게 제공해야하는 기능인 시스템 책임을 파악한다.  시스템 책임을 더 작은 책임으로 분할한다.  분할한 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.  객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.  해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.디미터 법칙  객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 방법.  오직 하나의 도트(.)만 사용해라.  디미터 법칙에 따르면 훌륭한 메시지는 객체의 상태에 관해 묻지 말고, 원하는 것을 시켜야 한다라는 사실을 강요한다.          묻지말고 시켜라(Tell. Don’t Ask)        디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.          객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 경우이다. (Stream)      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[This 와 Super에 대한 오해]]></title>
      <url>/dev/2020/05/10/java-this-and-super/</url>
      <content type="text"><![CDATA[  오브젝트(조영호님)책을 보며 정리한 내용, 작성중입니다.Java에서 This 란 ? this는 인스턴스의 자기 자신을 의미한다. this.은 주로 필드(전역변수)와 메소드 또는 생성자의 매개변수가 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용한다.자기 자신을 의미한다 -&gt; Self 참조값을 가진다.[image:691E34BC-B312-4128-986B-E438E22D6657-313-00013C90DB2EC097/C225693B-BF77-4EA2-8E73-BE2039800B75.png]  Java에서 Super란 ?super는 자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다. 클래스 내의 멤버변수와 지역변수의 이름이 같을 경우 구분을 위해 this를 사용하듯이 부모 클래스와 자식 클래스의 멤버의 이름이 같을 경우 super를 사용합니다. this와 super는 인스턴스의 주소값을 저장하는데 static 메서드(클래스 메서드)와는 무관하게 사용됩니다.출처: https://freestrokes.tistory.com/72 [FREESTROKES DEVLOG]상속받은 멤버를 참조할 때 사용하는 참조 변수 -&gt; 참조값을 변경한다.[image:670EA140-164A-491D-BD46-2C3720574555-313-00013C953E7391ED/45933790-F795-4A95-BA5D-CD0536292A53.png]간단한 예시 코드를 통하여 This와 Super에 대한 오해를 풀어봅시다.public class Main {    public static void main(String[] args) {        Weapon weapon = new Knife();        weapon.use();    }}public class Weapon {    private int damage = 0;    public void use() {        System.out.println("Use Weapon");        attack();    }    public void attack() {        System.out.println("Weapon : " + damage);    }}public class Sword extends Weapon{    @Override    public void attack() {        attack();    }}public class Knife extends Sword {    private int dagame = 4;    @Override    public void attack() {        System.out.println("knife : " + dagame);    }}]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Enum Class 정리]]></title>
      <url>/dev/2020/05/03/java-enum/</url>
      <content type="text"><![CDATA[  Enum 사용법에 대하여 정리 및 사내 공유를 위해 작성      해당 글의 용어 및 내용은 Java Enum 활용기 - 우아한형제들 기술 블로그를 많이 참고 하였습니다.    Enum이란 ?          Enumeration은 프로그래밍언어에서 상수의 그룹을 나타낼 때 사용한다.Enum은 컴파일 당시 우리가 모든 가능한 값을 알고있는 경우 사용된다. 항상 enum안의 상수는 타입이 정해져 있어야 되는 것은 아니다.Java 1.5버전 부터, enum은 enum 데이터 타입이라고 표시되었다. 자바 enum은 C/C++ enum보다 더 강력한 기능을 제공한다. 자바에서 변수, 메소드 그리고 생성자를 추가할 수 있다. enum의 주된 목적은 우리만의 데이터 타입을 가지기 위해서이다. (Enumberated Data Type)참고 자바의 enum            위 정의를 보더라도 Enum은 상수의 그룹을 나타내기 위하여 사용한다. 라고 선언 되어 있습니다. 과연 상수만을 위하여 Enum을 쓰는것 보다 Enum을 더욱 강력히 사용할 수 없을까? 라는 생각을 가지고 이 글을 보시면 더욱 좋을것 같습니다.    들어가기 앞서 객체는 상태와 행위를 가진다. 라는 개념에 대해 알고 계시는것이 좋을 것 같습니다.Enum - 상수의 집합 ?  사칙연산을 위한 프로그램을 만든다 할때 연산자를 아래와 같은 Enum으로 구분하여 사용할 수 있을것 같습니다.  OperatorType은 사칙연산을 위한 연산자를 가지고 있고 여러 클래스에 선언되어 사용하지 않고 연산자를 Enum으로 관리하여 응집도를 높였다고 볼수 있겠네요.    public enum OperatorType {  PLUS_OPERATOR("+"),  MINUS_OPERATOR("-"),  MULTIPLY_OPERATOR("*"),  DIVIDE_OPERATOR("/");  private String operator;  OperatorType(String operator) {      this.operator = operator;  }  public boolean isEqual(String operator) {      return this.operator.equals(operator);  }}        OperatorType은 과연 상태와 행위를 가지는 객체 인가요 ?          코드를 보시고 상태만 가지고 있다. 라고 생각이 든다면 정답입니다.        과연 행위는 어디에 있을까 ?          어디선가 아래와 같은 코드를 가지고 있는 클래스를 만들어서 사용해야 할것 입니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    if (PLUS_OPERATOR.isEqual(operator)) {        return plus();    }    if (MINUS_OPERATOR.isEqual(operator)) {        return minus();    }    if (MULTIPLY_OPERATOR.isEqual(operator)) {        return multiply();    }    if (DIVIDE_OPERATOR.isEqual(operator)) {        return divide();    }    throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");}  다시 처음 이야기한 객체의 정의에 대해서 생각해봅시다.          객체는 상태와, 행위를 가진다.      OperatorType은 행위를 가지고 있지 않으니 위 코드에 포함된 행위를 OperatorType 으로 옮겨 보겠습니다.        위 코드에서의 문제점은 무엇일까요 ?          곰곰히 생각을 해봅시다 : )      Enum - 상태와 행위를 한곳에  상태와 행위를 한곳에 모아둔 OperatorType을 먼저 보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+") {        @Override        public double calculate(double sum, double nextNumber) {            return sum + nextNumber;        }    },    MINUS_OPERATOR("-") {        @Override        public double calculate(double sum, double nextNumber) {            return sum - nextNumber;        }    },    MULTIPLY_OPERATOR("*") {        @Override        public double calculate(double sum, double nextNumber) {            return sum * nextNumber;        }    },    DIVIDE_OPERATOR("/") {        @Override        public double calculate(double sum, double nextNumber) {            if (nextNumber == 0) {                throw new IllegalArgumentException("0 으로 나눌수 없습니다.");            }            return sum / nextNumber;        }    };    private String operator;    OperatorType(String operator) {        this.operator = operator;    }    public static OperatorType createOperator(String operator) {        if(operator.equals(PLUS_OPERATOR.operator)) {            return PLUS_OPERATOR;        }        if(operator.equals(MINUS_OPERATOR.operator)) {            return MINUS_OPERATOR;        }        if(operator.equals(MULTIPLY_OPERATOR.operator)) {            return MULTIPLY_OPERATOR;        }        if(operator.equals(DIVIDE_OPERATOR.operator)) {            return DIVIDE_OPERATOR;        }        throw new IllegalArgumentException("사칙연산 기호가 아닙니다.");    }    public abstract double calculate(double sum, double nextNumber);}  이제 OperatorType 내부에 선언되어있는 객체들은  calculate라는 행위를 가지게 되었습니다. 이로 인해서 처음에 이야기 했던 객체의 정의를 만족 하게 되었네요 !  이전에 행위를 구현했던 코드는 어떻게 변했을까요 ?          참고Java7 부터 Enum 상수에 추상 메소드를 구현할 수 있습니다.      public double calculate() {    validateOperator();    String operator = findOperator(); // +, -, %, *    OperatorType operatorType = createOperator(operator);    return operatorType.calculate(sum, nextNumber());}  이전엔 Operator 별로 분기를 타며 계산을 하던 메소드가 실제 계산 하라  라는 메시지를 OperatorType에 던지는 단순하고 깔끔한 메소드로 변경 되었습니다.  여기까지만 보더라도 연산자를 가지고 있는 OperatorType은 자신이 가지고 있는 책임인 계산한다 라는것을 완벽하게 이행 함으로서 외부에선 모든 사칙연산에 관한 계산을 OperatorType을 사용할 수 있게 되었습니다.  이전에 상태와 행위를 한곳에서 관리 하지 않은 코드를 생각해보시면, 계산 하라라는 메시지를 누구에게도 던지지 않고 전혀 의미 없는 클래스에서 행위를 구현하여, 다른 클래스에서의 중복이 발생할 가능성이 컸습니다.  아직 남아 있는 문제점.  보시다 시피 Enum 내부 정적 메소드에 파라미터로 전달 받은 Operator에 맞는 상수를 찾아 전달 하고 있습니다. 위와 같은 분기문이 나열되어 있는 것이 좋은 패턴일까요 ?Enum 리팩토링 - 분기문을 없애보자.  분기문을 없애면서 저희는 Java 8 이상을 사용하는 개발자들로  추상메소드를 사용한 방식보다 Lambda를 사용한 OperatorType으로 리팩토링 해보겠습니다.public enum OperatorType {    PLUS_OPERATOR("+", (sum, nextNumber) -&gt; sum + nextNumber),    MINUS_OPERATOR("-", (sum, nextNumber) -&gt; sum - nextNumber),    MULTIPLY_OPERATOR("*", (sum, nextNumber) -&gt; sum * nextNumber),    DIVIDE_OPERATOR("/", (sum, nextNumber) -&gt; {        if (nextNumber == 0) {            throw new IllegalArgumentException("0 으로 나눌수 없습니다.");        }        return sum / nextNumber;    });    private String operator;    private Calculation calculation;    OperatorType(String operator, Calculation calculation) {        this.operator = operator;        this.calculation = calculation;    }    public static OperatorType findOperator(String operator) {        if (Objects.isNull(operator)) {            throw new IllegalArgumentException("연산자는 null 이 될 수 없습니다.");        }        return Arrays.asList(values()).stream()                .filter(operatorType -&gt; operatorType.operator.equals(operator))                .findFirst()                .orElseThrow(() -&gt; new IllegalArgumentException("사칙연산 기호가 아닙니다."));    }    public double calculate(double sum, double nextNumber) {        return calculation.calculate(sum, nextNumber);    }}@FunctionalInterfacepublic interface Calculation {    double calculate(double sum, double nextNumber);}  뭔가 더욱 깔끔하게 리팩토링된것이 느껴진다면 성공입니다 : )  추상메소드를 사용한 방식 대신 Lambda로 calculate를 구현 하였습니다.          Lambda를 사용하기 위하여 @FunctionalInterface를 만들었습니다.                  @FunctionalInterface는 메소드 1개를 가진 인터페이스 입니다.                    Java가 제공하는 함수형 인터페이스도 사용할 수 있습니다.   Function&lt;T, R&gt; 은 매개변수 1개를 지원하고 2개는 BiFunction을 사용하셔도 됩니다.        분기문이 없어진 것을 확인 할 수 있습니다.          Stream 을 사용하여 분기문을 제거하고 코드의 가독성을 높혀 다른 개발자들이 보더라도 어떤 기능을 하는지 쉽게 알수 있게 되었습니다. : )        이처럼 리팩토링을 하게 되어 얻을수 있는 가장 큰 이점은 재사용성과 확장성을 얻을 수 있게 되었다는 것 입니다.      다른 클래스에서 사칙연산을 하기 위해선 OperatorType만 사용하면 될 것이고 새로운 연산자가 추가 되더라도 복잡한 분기문들을 제거 하였기 때문에 상수 정의만 해준다면 어디서든 정상적으로 동작하겠죠 :)    예제를 사칙연산으로 들었지만 Enum을 사용하는 어느 곳이라도 비슷하게 적용할 수 있을것이라 생각하여 공유드렸습니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 5주차 정리]]></title>
      <url>/dev/2020/04/25/tdd-clean-code-5w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 5주차 정리사다리 타기 tdd 구현  Out - in 접근 방식 vs in.- out 접근 방식  TDD 로 구현하기에는 in.- out 방식이 더 적합하다.          가장 작은 단위의.객체부터 기능을 추가하면서 개발한다.      도메인 설계에서 가장 마지막 객체(의존관계가 없는)      가장 작은 단위의 객체가 구현되었으면, 객체를 더 작게 나눌수 없을까 고민      가장 작은 단위의 객체가 새롭게 만들어 졌으면 다시 고민                  위와 같은 사이클을 계속하여 진행                      책임주도설계로 사다리타기 재설계          책임주도설계 == 인터페이스 주도 설계                  사다리 초기화(생성)          사다리 실행          사다리 결과 구하기                    메시지를 먼저 결정하면 내부 상태가 어떻게 도출될지는 자연스럽게 정해진다.      책임 (객체가 해야할 행동, 메시지)를 먼저 정해보는것.        패키지들 간의 의존성은 단방향으로 만들어야 한다.          추후에 큰변화 (분리) 할때 편리하다.      sonarqube와 같은 정적 분석 도구를 활용해 cyclic dependency를 찾아준다.        서비스 로직은 어디에 구현하는것이좋을까 ?          일급 콜렉션을 쓴다.      3개 이상의 인스턴스 변수를 사용하지 않는다.      묻지 말고 시켜라. (데이터를 꺼내지말고 메시지를 던져라)      상태 변경의 주도권은 외부에 있지 않고 도메인이 가지고 있어야 한다.        도메인 설계, 구현 반복          요구사항을 분석후 도메인 설계.      한번에 완벽한 설계를 하겠다는 욕심을 버려라.                  반복적인 설계와 구현을 통해 도메인에 대한 이해도를 높여야 한다.          도메인에 대한 이해도가 높아야 추상화 수준도 높아진다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 4주차 정리]]></title>
      <url>/dev/2020/04/18/tdd-clean-code-4w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 4주차 정리4주차  점진적 리팩토링          기존의 테스트가 깨지지 않는 선에서 리팩토링 하기      컴파일 에러가 발생하면 안된다.        일반적 상황          메소드에 인자가 추가되었다.      인스턴스 변수 타입이 변경되었다.                  -&gt; 컴파일 에러가 발생 , 에러 해결                          위 방식 대로 리팩토링 하면 긍정적인 측면 보다. 부정적인 측면이 생길 수 있다.    우리가 연습해야할 리팩토링은 ?          메소드에 인자가 추가 되는 경우                  메소드를 그대로 복사하여 메소드 이름을 임시로 변경          임시 메소드를 하나씩 실제 사용한 메소드와 변경          더이상 이전 메소드가 존재하지 않으면, 이전 메소드를 제거 후 이름 변경                    인스턴스 변수의 타입이 변경되는 경우                  새로운 인스턴스 변수 추가          String to Integer로 변경 시 일시적으로 두개 타입을 도시에 사용          두개 변수에 동시에 데이터를 넣고 리팩토링                      점진적 리팩토링 - TDD 에 대한 감이 생길때 시작          1단계 - 메소드를 다른 클래스로 이동      2단계 - 메소드에 인자 타입이나, 반환 타입이 변경 시      3단계 - 인스턴스 변수 타입이 변경되는 경우                  데이터의 중복을 만든다. (임시 변수를 만들고, 메소드에 인자가 추가되는 경우와 같이 점차 변경해나간다.)                          리팩토링은 시간 날때마다 진행하는것이다.    객체지향 설계 및 구현 접근 방식은 ?          Bottom Up 설계 및 구현                  구현에 초점을 맞추어 일단 구현 후 지속적 리팩토링을 통해 역할,책임,협력을 찾아 나간다.                    Top Down 구현 및 설계                  책임에 초점을 맞추어 전체적인 설계 후 구현                      책임 주도 설계          책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계                  클래스를 먼저 설계하는것이 아니다.                      책임이란 ?          책임이란 객체가 유지해야할 정보와 수행해야할 행동      즉 객체가 무엇을 알고있는가 와 무엇을 할 수 있는가로 구성된다.        역할을 다른것으로 교체할 수있는 책임의 집합이다.  테스트 하기 쉬운 코드가 유연한 코드는 아니지만 연습하다 보면 유연한 코드가 될 수 있다.  유연한 설계를 지향한다면 컴파일타임 의존성을 런타임 의존성으로 대체한다.          의존성을 주입 한다.        런타임 의존성으로 대체하다보면 테스트하기 쉬운 설계가 가능해진다.      테스트하기 쉬운 설계를 지향하다보면 유연한 설계가 가능해지는 경험을 종종 할 수 있다.    책임 주도 설계가 진정한 대안인가 ?          책임 주도 설계에 익숙해지기 위해선, 부단한 노력과 시간이 필요.      책임 관점에서 사고하기 위해선 부단한 노력과 학습이 필요하다.      빠르게 구현 후 지속적 리팩토링      TDD 사이클을 반복해 설계의 품질을 높힌다.                  리팩토링 시 객체지향 설계 체조원친, 클린코드 설계 원칙을 지키면서..                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 3주차 정리]]></title>
      <url>/dev/2020/04/11/tdd-clean-code-3w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 3주차 정리  tdd 사이클이 익숙해질때 까지 반복적으로 연습해야 한다.          가장 자신있는 언어로 반복 연습하는것을 추천.      힘들고 지칠땐 주제를 바꿔서 해보는것이 좋다.      시작하기  요구사항 분석을 통한 기능 목록 작성      객체설계를 통해 어느 부분 부터 구현할 지 생각하는것이 우선이다.    기능목록          주제에 대해서 가장 일반적인 기능들을 다 적어보자.      점차 작은 단위의 기능들도 정의        TDD로 구현할 기능 찾기          큰 부분을 작게 자르는 연습을 해야한다.        인풋과 아웃풋이 있는 케이스가 테스트 하기 쉽다.      메서드 하나에 모든 로직이 들어가 있으면 객체지향적인 구조보다 절차지향적 구조로 변질되게 된다.    리팩토링, 어디서 부터 시작할까 ?          첫밴쨰는 메소드 분리부터 시작. (Naming Rename도 해야한다.)                  메소드가 한가지 일만 잘하도록 구현한다.                          한가지 일만 하기 위해 메소드 라인을 제약하는것도 좋은 방법이다.                                          Indent를 줄이자.                  Else 예약어를 쓰지 않는다.                    클래스를 분리하자.                  원시값과 문자열을 포장          일급 콜렉션을 사용한다.          3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않기.          메소드 인자수를 제한한다. 2개까지만 허용한다.                          3개는 고민을 많이 하고, 4개는 절대 안된다.              비슷한 속성을 가진 인자수를 클래스로 만들어 보자.                                  속성과 라이프 사이클이 동일하면 쉽게 판단할 수 있다.                                                                          private method를 분리해서 단위테스트 해야하는 것이 아닌가 ? 라는 의구심          private method를 다른 클래스로 만들어 public으로 open하는게 더 나은 구조는 아닐까 생각해보자.            새로운 클래스가 생성될때 테스트부터 만들어 보자.    상속(is-a) 조합(has-a)          일급 collection을 구현할 때 접근 방법으로 상속과 조합 방법으로 구현 가능      객체의 중복(Lotto와 WinningLotto)를 제거 할 때 상속과 조합 방법으로 구현 가능            상속은 의도하지 않은 인터페이스가 외부에 노출될 수 있다.반면 조합을 사용하면 외부에 오픈할 인터페이스를 정의할 수 있다.    상속과 조합 중 어떤것이 좋을까 ?          상속 보단 객체 조합을 사용해라.      코드의 재사용성 측면에선 상속이 유리. 유연성 측면에선 조합이 유리.                  변화에 빠르게 대응하는 것이 점점 더 중요, 현재는 재사용성 보다 유연성이 훨씬 더 중요하다.          확실하게 경험을 하는것이 좋다 !                      생성자 대신 정적 팩토리 메소드 사용.          생성자의 수가 늘어날수록 클래스를 사용하기 위한 유연성은 높아진다.        가변객체보단 불변 객체를 사용해라.  불변 객체 만들기          객체의 상태를 변경하는 메소드를 제공하지 않는다.      클래스를 확장 할 수 없도록 한다. (Public final class)      모든 필드를 final로 선언한다.                  내부에 collection이 있다면 collection도 불변인지 확인해야 한다.                    모든 필드를 private으로 선언한다.        immutable object 가 좋은것은 알겠는데, 인스턴스가 많이 생성되어 성능이 떨어지지 않을까 ?          캐싱을 적용해 인스턴스 생성을 최소화 할 수 있는 방법이 있는지 검토                  캐싱은 일반적으로 Map(key - value) 형식을 가장 많이 사용된다.                    성능외에도유지보수하기 좋은 코드, 읽기 좋은 코드, 유연한 코드, 버그 발생 가능성이 낮은 코드 와 같이 다양한 측면을 고려하면서  프로그래밍 하는습관을 가지자경험해야할 학습 목표 - 사다리 타기* TDD, 객체 지향 프로그래밍 연습* 인터페이스를 추출하여 프로그래밍 하는 연습을 한다.* stream, lambda를 사용해 프로그래밍하는 것을 연습.경험할 객체 지향 생활 체조 원칙  한줄에 점 하나만  찍는다.          Clean Code 가이드의 디미터 법칙을 지키는 것을 의미.        모든 엔티티는 작게  3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.  getter / setter / property를 쓰지 않는다.함수형 프로그래밍      함수형 프로그래밍은 input과 output이 항상 존재 하기 때문에 test하기 쉽다.    클래스 기반 함수를 모으로 메소드 레벨에서 함수형 프로그래밍에 맞게 설계 ?  람다를 쓰는게 중요한게 아니고 변경 가능성이 높은 부분을 인터페이스로 추출 할 수 있는지가 중요하다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 2주차 정리]]></title>
      <url>/dev/2020/04/04/tdd-clean-code-2w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 2주차 정리코드 컨벤션을 지켜라다른 개발자와 협업이나 미래의 나를 위해서라도.공백 라인을 의미있게 사용해라.공백 라인이 메소드의 기능을 나누게 되는 기준이 된다. 추후 리펙토링 시 메소드 기준으로 기능이 나뉜다는것을 알고 공백기준으로 메소드 리펙토링이 가능하다.네이밍객체지향 생활 체조 규칙 5 : 축약하지 말라.적당한 길이의 이름을 찾는데 집중해라.인스턴스 변수의 중복을 줄이고, 개수를 최소화 해라.데이터를 꺼내려고 하지않고 메시지를 던져라비지니스 로직과 ui로직의 분리.테스트 가능한 코드와 불가능한 코드가 섞여 있으면 분리를 해야 한다.어느 부분을 테스트 할 것인가 ?경계값을 기준으로 테스트해야 한다.Test Fixture를 위해서 생성자를 추가하는것이 옳은 일인가 ? 도메인이 DTO역할을 하는 경우라면 생성자를 추가하는것이 허용된다. 해당 경우에는 허용하는 것으로 .. 역할이 여러개이면 클래스 분리.private메소드가 많아지면 테스트를 해야 하는것인가 ? Private 메소드가 중요한 비지니스 역할을 한다면 새로운 클래스로 분리 되어야 한다. 분리 된다면 다른 클래스에서 접근 가능한 메소드가 되기때문에 테스트가 가능하다.TDD이번주 부터는 메소드 분리가 아닌 클래스 분리를 연습 하자모든 원시값과 문자열을 포장한다. 일급 콜렉션을 쓴다.생성자를 중복해 정의할 때는 정적 팩토리 메소드를 사용한다.tdd는 리팩토링이 가장 중요하다.테스트와 production code를 추가할 때 마다 리팩토링을 해야한다.한번에 리팩토링을 하지 않고 테스트 케이스가 추가 될 때 마다 리팩토링을 하는 연습을 해야 한다.todo리스트를 제대로 만드는것이 tdd를 잘하는 방법이다.설게를 안하는것이 아니고 초반에 대략적인 설계가 필요하다.초반 설계시 테스트 가능한 부분과 힘든 부분까지 설계를 한다면 설계를 잘한 것이다.tdd 시작시 인풋과 아웃풋을 결정해야 한다.Getter 를 쓰는순간 없애려고 노력해라 (상태를 가진 데이터를 꺼내는것보다 객체에 메시지를 보내서 일을 시켜라)접근 제어자를 잘 사용해서 클래스 및 메소드의 접근 범위를 한정하는것도 도메인을 지키는 방법이다.   특히 default 접근 제어자는 도메인을 지키는 좋은 방법중 하나이다.토이 프로젝트에선 최대한 조건을 강제해라인덴트 1, 인스턴스 변수 2개 등의 극한의 조건을 걸어라.Q&amp;AVoid method 는 검증하는것만으로도 의미가 존재 하는지 ?-&gt; 존재한다.Void method 내부에서도 인풋과 아웃풋이 있는 부분을 분리할 수 있을것이다. 그부분을 메소드로 분리해서 테스트 가능하다.유효성 검사도메인은 반드시 유효성 검사를 해야 하는것이 맞다. 그렇다고 controller나 다른 레이어에서 유효성검사를 안해도 된다는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Checked Exception과 UnCheckedException의 차이]]></title>
      <url>/dev/2020/04/02/checked-exception-unchecked-exception/</url>
      <content type="text"><![CDATA[  Checked Exception과 UnCheckedException의 차이점 정리 및 실험Checked Exception 과 UnCheckedException의 차이  Checked Exeption          어플리케이션에서 반드시 예외 처리를 해야 한다. 하지 않을시 Runtime Error 가 발생      Transaction Rollback이 되지 않는다.      대표적으로 IO,SQLException이 있다.      try-catch 로 예외를 처리 하거나 상위 메소드로 예외 처리로직을 위임 할 수 있다.        UnCheckedException          어플리케이션에서 예외처리를 강제 하지 않는 에러.      Transaction Rollback 처리      대표적으로 Runtime Exception, NullPointer, IllegalArgumentException 등이 존재 한다.      명시적 예외 처리 로직이 필요하지 않는 에러        두가지 Exception을 나누는 기준은 위 표와 같이 Runtime Exception의 상속 여부 이다.          RuntimeException 을 상속받는 Exception 모두가 Unchecked Exception이라고 할 수 있다.        간단한 예시를 통하여 Unchecked Exception 의 Rollback을 확인해보자.@Transactionalpublic void insertWithUnCheckedException() {    User user = new User("name");    userRepository.save(user);    throw new RuntimeException();}위와 같이 Service 로직에서 데이터를 저장 후 Unchecked Exception 을 던지게 되면 어떤 일이 일어날지 간단한 테스트 실행.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void uncheckedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithUnCheckedException());    }}결과 로그2020-03-24 18:39:02.118  INFO 83948 --- [           main] p6spy                                    : #1585042742118 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdb2020-03-24 18:39:02.134  INFO 83948 --- [           main] p6spy                                    : #1585042742134 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb      위 로그를 보시면 UncheckedException 이 발생하면 rollback 이 정상적으로 일어난 것을 확인 할 수 있습니다.        CheckedException이 발생 하였을때 정말 Rollback이 되지 않을까 ?  마찬가지로 간단한 테스트를 실행해보자.@Transactionalpublic User insertWithCheckedException() {    User user = new User("name");    User save = userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");    }    return save;}User를 저장하고 강제로 Exception을 던져보았습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        User user = userService.insertWithCheckedException();        assertThat(user.getId()).isNotNull();    }}결과 로그2020-03-24 18:41:41.851 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     call next value for hibernate_sequence2020-03-24 18:41:41.861  INFO 83958 --- [           main] p6spy                                    : #1585042901861 | took 4ms | statement | connection 4| url jdbc:h2:mem:testdbcall next value for hibernate_sequencecall next value for hibernate_sequence;2020-03-24 18:41:41.876 ERROR 83958 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:41:41.885 DEBUG 83958 --- [           main] org.hibernate.SQL                        :     /* insert me.study.exceptiontest.domain.User        */ insert         into            user            (name, id)         values            (?, ?)2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [name]2020-03-24 18:41:41.889 TRACE 83958 --- [           main] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [BIGINT] - [1]2020-03-24 18:41:41.890  INFO 83958 --- [           main] p6spy                                    : #1585042901890 | took 0ms | statement | connection 4| url jdbc:h2:mem:testdb/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values (?, ?)/* insert me.study.exceptiontest.domain.User */ insert into user (name, id) values ('name', 1);2020-03-24 18:41:41.893  INFO 83958 --- [           main] p6spy                                    : #1585042901893 | took 0ms | commit | connection 4| url jdbc:h2:mem:testdb;  위 로그를 보시면 정상적으로 CheckedException이 발생 하였지만 m.s.q.exceptiontest.service.UserService  : throw exception  User 데이터가 저장되는것을 확인 할 수 있습니다.  CheckedException 이 발생 될 때 정상적으로 Rollback을 하기 위한 여러가지 방법이 있지만 저는 명시적인 UncheckedExecption을 던져주는 방식으로 Rollback이 되는지 실행 해보겠습니다.@Transactionalpublic void insertWithCheckedException() {    User user = new User("name");    userRepository.save(user);    try {        throw new Exception();    } catch (Exception e) {        log.error("throw exception");        throw new RuntimeException();    }}위 코드와 같이 CheckedException 이 던져질 경우 catch에서 명시적인 예외를 다시 던져주는 방식으로 실행 해 보겠습니다.@SpringBootTest@Commitclass UserServiceTest {    @Autowired    private UserService userService;    @Test    void checkedException() {        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -&gt; userService.insertWithCheckedException());    }}결과 로그2020-03-24 18:48:18.409 ERROR 83989 --- [           main] m.s.q.exceptiontest.service.UserService  : throw exception2020-03-24 18:48:18.409  INFO 83989 --- [           main] p6spy                                    : #1585043298409 | took 0ms | rollback | connection 4| url jdbc:h2:mem:testdb;위 로그와 같이 명시적인 에러를 던져줌으로서 정상적으로 Rollback이 되는것을 확인 할 수 있습니다.  Exception의 종류에 따라 트랜젝션 여부가 다르다는것을 알고 있었지만 실제로 어떻게 처리하는지, 정말 Rollback이 안되는지 등에 대한 실행을 통한 결과 검증 과정을 정리 하였습니다. 지금까지 Exception 처리시 별다른 처리를 하지 않고 단순 로그만 남기는 경우가 많이 있었는데 이번 테스트를 통하여 정확한 예외 처리 방법에 대한 학습을 할 수 있었습니다. :)참고  https://cheese10yun.github.io/checked-exception/  https://1.bp.blogspot.com/]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TDD, CleanCode, Refactoring 1주차 정리]]></title>
      <url>/dev/2020/03/29/tdd-clean-code-1w/</url>
      <content type="text"><![CDATA[  TDD, CleanCode, Refactoring 1주차 정리TDD - 프로그래밍 의사결정과 피드백 사이의 간극을 의식. 제어하는 기술TDD는 분석기술이며 설계 기술이기도 하다.TDD는 분석과 설계를 잘 해야 한다.  TDD = Test First Development + Refactoring  TDD는 테스트를 먼저 개발하는것이 주된 목적이 아니고 리팩토링이 주된 목적이다.  짧고 작은 단위의 설계를 지속하여 개발하는 방법.      한번에 모든걸 만들지 않고 작은 단위를 만들어 간다.    TDD는 한번에 한가지 만 고민하여 기능을 우선 개발한다.  이후 개발된 기능을 바탕으로 refactoring을 진행한다.      이때 테스트 코드나 테스트 케이스는 추가되거나 수정되지 않아야 한다.    큰단위를 작은 단위로 나눠 빠르게 실패.  피드백을 통해 지속적 개선  달성하기 힘들 것으로 생각하는 일에 도전할 수 있는 용기  의식적인 연습이 필요하다.          학습테스트      단위테스트      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> TDD </tag>
        
          <tag> Clean Code </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Clean Code 작성법]]></title>
      <url>/dev/2020/03/27/java-clean-code/</url>
      <content type="text"><![CDATA[  해당 포스트는 DDD 세레나데의 강의를 정리하며 작성하였습니다.Java Code 작성 팁  불변객체(Value Object)를 사용하자.          불변객체란 ?  위키 백과 - 컴퓨터 과학에서 가치 객체는 동일성을 기반으로하지 않는 단순 개체를 나타내는 작은 객체입니다.   즉, 두 객체가 동일한 값을 가질 때 동일하며 반드시 동일한 객체 일 필요는 없습니다. 가치 개체의 예는 금액 또는 날짜 범위를 나타내는 개체입니다.      동일한 값을 가질때 동일한 객체임을 보장해주며 객체의 상태를 변경할 될 수 없는 객체이다.      의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용      시스템이 성숙함에 따라 데이터 값을 객체로 대체      밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.      정말 String으로 우편 번호를 표현할 수 있는가?      항상 equals() 메서드를 오버라이드할 것을 권고한다.                  equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java                      일급 컬렉션을 사용하자.          참고 일급 컬렉션 (First Class Collection)의 소개와 써야할 이유      일급 컬렉션 이란 ?                  콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.필터가 이 새 클래스의 일부가 됨을 알 수 있다.필터는 또한 스스로 함수 객체가 될 수 있다.또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.                    public class LottoNumbers {	  private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public LottoNumbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = numbers;    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || number.size() != LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  항상 방어적 복사를 생각하자.          Java 에서는 값을 참조하는 방법이 크게 두가지가 존재                  Call by Reference          Call by Value                    일반적으로 객체간의 값 복사는 Call by Reference 방식으로 통하여 값이 복사 된다.  이 방식으로 값을 복사 하면 위에서 말한 일급 컬렉션이 불변하지 않게 되는 문제점이 있다. 그래서 항상 방어적 복사(DeepCopy)를 생각하는 방식	을 권장한다.      List&lt;Integer&gt; lottoNumbers = new ArrayList&lt;&gt;();lottoNumbers.add(4);lottoNumbers.add(5);lottoNumbers.add(6);lottoNumbers.add(8);lottoNumbers.add(13);lottoNumbers.add(45);Numbers numbers = new Numbers(lottoNumbers);System.out.println(numbers.totalValue());// 81lottoNumbers.add(2);System.out.println(numbers.totalValue());// 83public class Numbers {    private static final Integer LOTTO_NUMBER_SIZE = 6;    private final List&lt;Integer&gt; numbers;    public Numbers(List&lt;Integer&gt; numbers) {        validNumber(numbers);        this.numbers = new ArrayList&lt;&gt;(numbers);        this.numbers = Collections.unmodifiableList(numbers);    }    private void validNumber(List&lt;Integer&gt; numbers) {        if (Objects.isNull(numbers) || numbers.size() == LOTTO_NUMBER_SIZE) {            throw new IllegalArgumentException();        }    }    public Integer totalValue() {        return numbers.stream()                .mapToInt(Integer::intValue)                .sum();    }}  setter 보다 의미있는 이름의 메소드를 사용해보자.          객체에 getter 메서드와 setter 메서드를 무조건 추가하는 것은 좋지 않은 버릇      특히 setter 메서드는 객체의 핵심 개념이나 의도를 코드에서 사라지게 한다.      setter 메서드의 또 다른 문제는 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.      도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.      changeShippingInfo() vs setShippingInfo()completePayment() vs setOrderState()  주/부 생성자를 활용해보자.          주 생성자                  모든 상태를 가진 완전한 객체를 생성하는 생성자                    부 생성자                  상태가 완전하지 않은 객체를 생성하는 생성자                    객체를 생성할 때 상태가 완전하지 않은 객체를 생성하는 경우가 있다.  이런 객체들을 생성할 때 마다 객체의 상태를 검사하는 로직을 남발하는 경우가 존재한다.   해당 로직들을 주 생성자에 위임하여 항상 동일한 로직을 타도록 설정 할 수 있다.      public class Menu {    private String name;    private BigDecimal price;    private Long menuGroupId;    private List&lt;MenuProduct&gt; menuProducts;    public Menu(String name, BigDecimal price, List&lt;MenuProduct&gt; menuProducts) {        this(name, price, null, menuProducts);    }    public Menu(String name, BigDecimal price, Long menuGroupId, List&lt;MenuProduct&gt; menuProducts) {        validName(name);        validPrice(price);        validMenuProducts(menuProducts);        this.name = name;        this.price = price;        this.menuGroupId = menuGroupId;        this.menuProducts = menuProducts;    }    private void validMenuProducts(List&lt;MenuProduct&gt; menuProducts) {        if (Objects.isNull(menuProducts) || menuProducts.size() == 0) {            throw new IllegalArgumentException();        }    }    private void validPrice(BigDecimal price) {        if (Objects.isNull(price) || price.compareTo(BigDecimal.ZERO) &lt; 0) {            throw new IllegalArgumentException();        }    }    private void validName(String name) {        if(Objects.isNull(name) || StringUtils.isEmptyOrWhitespace(name)) {            throw new IllegalArgumentException();        }    }}  생성자 보다는 정적 팩토리 메소드를 사용하자.          정적 팩토리 메서드(static factory method) - 기계인간 John Grib        Package By Feature, Not Layer          패키지를 생성하는 전략 크게 두가지로 나뉘어 생성이 가능하다.                  Package by Layer                          Spring에서 일반적으로 사용하는 Controller / Service / Repository 등의 패키지를 최상단 패키지로 설정하여 프로젝트를 구성하는 방식                                Package by Feature                          도메인 중심으로 패키지를 생성하는 방식.                                  각 도메인이 최 상단 패키지가 되어 하위에 api / application / infrastructure / domain 등을 가지게 된다.                  정답은 없다.                                                                        프로젝트의 규모가 커질수록 Package By Layer 의 구조는 복잡성이 증가하게 된다.              반면 Feature중심의 패키지 구조로 되어 있으면 연관성이 있는 패키지들이 새롭게 추가 되기 때문에 기존 패키지에 영향을 미치지 않게 되며  필요한 기능들이 군집해 있기 때문에 다른 패키지들간의 영향을 줄일수 있게 된다.            참고 자료를 보시는것이 더욱 좋습니다 : )      http://www.javapractices.com/topic/TopicAction.do?Id=205      https://medium.com/@ssowonny/package-by-feature-in-clean-architecture-projects-e14d25e3905e      #JAVA/Code]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> Java </tag>
        
          <tag> Clean Code </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 5주차 강의 정리]]></title>
      <url>/dev/2020/03/20/ddd-serenade-5w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 5주차4주차 복습  비즈니스 로직 수행은 어느 곳에 하는 것이 좋을까 ?          도메인 레이어에서 기능을 수행하고 다른 응용 및 표현 레이어에서 해당 기능을 사용한다.        응용 서비스          사용자의 요청에 맞는 도메인 모델을 찾아오고 그 모델의 로직을 위임하는 처리를 한다.        도메인 서비스          응용 서비스와 도메인 서비스를 판단 하는 기준                  두개 이상의 애그리거트가 사용될때          다루고 있는 로직이 위키나 지라에 정리를 해야할 필요성이 있는 경우          두가지 조건을 한줄로 요약하면 도메인 지식이 다른곳으로 흘러가는것을 막아주는 역할을 한다.          도메인 서비스는 어플리케이션 레이어와 도메인 레이어 사이에 위치한다.                      응용 서비스의 구현  vo가 dto로 돌아다녀 외부에 노출된다면 캡슐화가 깨지는것이 아닌가 ?          vo가 dto로 돌아다니는 것은 일종의 trade-off이다.      vo의 접근 제어자를 default로 두어 도메인 패키지 내부에서만 사용할수 있도록 만드는것도 하나의 방법이다.        항상 DTO를 만드는것은 실용적이지 않아 DTO를 대신 할 수 있는 VO를 찾는것도 방법이다.  고수준 모듈 저수준 모듈          고수준 모듈이 저수준 모듈에 의존하는것이 아니고 저수준 모듈이 고수준 모듈에 의존하도록 dip를 적용해야 한다.        클린 아키텍처          안에선 밖을 모르고 밖에선 안을 알수 있는 아키텍처      도메인 모델을 외부로 부터 지키는 것이 중요하다.        anticorruption layer          anticorruption layer 하는 역할이 크다면 별도의 레이어로 만들수도 있고 클래스로도 만들 수 있다.      많은 mapper class assemblr pattern이 등장 하더라도 나의 도메인 모델을 지킬 수 있다.        도메인 서비스 구현 방법          응용 서비스에서 도메인 서비스를 주입 받고 응용서비스 내부에서 메시지를 전달한다.      해당 도메인 서비스에서는 도메인들을 가지고 와서 실제 로직을 실행하는 과정을 거친다.      repository는 domain service에 담고 있다.      repository에서 실행하는 save와 같은 데이터 추가는 실제로 DB에 값이 저장되지는 하지만 도메인 입장에서는 add와 같은 기능을 한다고 생각하여 repository가 infra영역이 아닌 domain 영역에 있다고 본다.      Domain layer가 필요 없는 상황 (하나의 도메인만 사용한다면) application layer에서 처리      도메인 모델에서 에러 같은 경우는 try - catch하여 상위 레이어에 노출되지 않도록 막아준다.                  상위 레이어에서 알 수 있는 에러를 핸들링 할수 있도록 하는 것.                      DTO 가이드          dto를 도메인으로 전환하고 도메인을 dto로 전환하는건 application service에서 담당하는것이 맞다.      dto가 데이터를 담아서 전달 할 수 있는 영역은 application service까지 이다.        모놀리식 아키텍처는 다른 패키지의 서비스를 주입 받아서 사용하지만 마이크로 서비스로 분리 되는 경우 변경이 힘들다.  외부 컨텍스트에서 발생한 예외 또한 내부 컨텍스트에서 이해할 수 있는 에러로 감싸주어야 한다.  infrastructure layer가 anti corruption layer 역할을 할 수도 있다.  exception은 domain 패키지에 위치  anticorruptionlayer 도메인 내부 에그리게잇 폴더에 위치  order - buyer 예시에선 order 에그리게잇이 root가 되었다. 내부에 order , order item entity를 가지고 있고 vo 도 가지고 있다.전술적 설계 - Domain Event  이벤트란 도메인 전문가가 관심을 가질 법한 것들 (단순 조회 제외)  강한 결합  이벤트          이벤트는 어떤 상태가 변경되었다는것이다.      도메인 모델에서 이벤트를 관리 하는 주체는 에그리게잇이 될 수 있다.      이벤트 핸들러는 이벤트에 담긴 주체를 가지고 부가적인 행동을 하게 된다.      스프링에선 application event publisher 가 트랜잭션이 종료될때 이벤트를 발행 해 준다.                  테스트 코드에선 이벤트가 발행되었는지 안되었는지만 확인 하면 된다.                    스프링 이벤트는 기본적으로 한 트랜젝션 내부에선 묶여있다.                  하나가 실패하면 롤백되는 구조이다.          TransactionalEventListener 를 사용하면 트랜잭션이 끝난 후 동작하도록 사용할 수 있다.                    스프링 이벤트를 사용하지 않고 이벤트를 발행 하려면 AbstractAggregateRoot 를 상속 받아 registerEvent()으로 이벤트를 발생할 수 있다. 이떄는 save를 강제로 호출 해줘야 한다.      도메인 내부에 이벤트를 가지고 있어야 한다.        이벤트 소싱          도메인 모델에서 발생하는 모든 이벤트를 기록하는 방법        CQRS          상태를 변경하는 명령과 모델의 상태를 조회하는 모델을 분리한 패턴.      커멘트 패키지와 조회 패키지등으로 분리 할 수 있다.      ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[인터페이스와 구현에 대한 정리]]></title>
      <url>/dev/2020/03/18/java-interface-and-implement/</url>
      <content type="text"><![CDATA[  객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 공유 하고자 만든 자료입니다.인터페이스와 구현객체 지향의 사실과 오해, 오브젝트 책을 보고 제가 느낀점들을 공유 하고자 만든 자료입니다.객체란 자기 주도적으로 책임, 협력, 역할을 가지고 있는 상태를 의미한다.여기서 책임이란 어떠한 일을 맡아서 하는 것이다.커피 전문점 도메인을 가지고 인터페이스와 구현에 대해 알아 보자.커피 전문점 도메인은 고객, 바리스타, 커피, 메뉴판등의 객체를 가지고 있다고 가정한다.고객이란 어떤 책임을 가지고 있을까 ?일반적으로 생각 하면 ‘주문’이라는 책임을 가지고 있을 것이다.모든 주문은 고객이 주도적으로 생성하게 될것이고 생성된 주문을 통하여 바리스타는 주문에 해당하는 커피를고객에게 전달하게 된다. 따라서 고객은 주문이라는 책임을 가지고 있는 셈이다.협력이란 ? 고객이 ‘주문’이라는 책임을 가지고 다른 객체에게 주문하라 라는 메시지를 전달 한다.여기서 메시지는 객체간의 의사소통을 하기 위한 방법이다. 여기서 고객은 주문하라 라는 메시지를 통해 바리스타에게 커피를 만들어라고 다시 한번 메시지를 전달하게 될것 이다.결론적으로 커피전문점에서 고객이 커피를 주문하기 위해선 고객과 바리스타간의 협력을 통하여 최종적으로 커피가 주문되게 되니 둘 간의 협력 관계가 형성 되는 것이다.역할이란 ? 역할은 메시지를 책임지는 집합으로 볼 수 있다. 여러 커피전문점을 생각해보자. 어떤 커피전문점에서는 들어오는 커피에 따라서 바리스타의 역할이 세분화 될 수 있다.예를 들면 에스프레소를 책임지는 바리스타, 라떼를 책임지는 바리스타 등으로 바리스타의 역할중 세분화 되어 있는 영역에서 똑같이 커피를 만들어라 라는 책임을 다하고 있는것이다.일반적으로 역할은 추상화 과정에서 나타난다.상위 수준에서의 책임을 쉽고 간단하게 표현하고 설계를 유연하게 만들수 있는 장점이 있다.자율적인 객체객체는 상태와 행동을 함께 가지는 복합적인 존재이며 스스로 판단하고 행동하는 자율적인 존재라는 것이다. 대부분의 프로그래밍 언어는 외부에서 접근을 통제 할 수 있는 접근 제어 메커니즘을 제공한다. 접근 제어를 위해  public, private 와 같은 접근 수정자가 존재한다.객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다. 객체지향의 핵심은 스스로 상태를 관리하고 판단하고 행동하는 자율적인 객체들의 공동제를 구성 하는 것이다.캡슐화와 접근제어는 객체를 두 부분으로 나눌수 있다. 외부에서 접근 가능한 퍼블릭 인터페이스(public interface), 내부에서만 접근 가능한 부분인 구현(implementation)이라고 부른다.캡슐화상태와 행동을 하나의 객체안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위함이다.잘 설계된 캡슐화를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고, 외부에는 상대적으로 안정적인 부분만 공개함으로 변경의 여파를 통제 할 수 있다.변경될 가능성이 높은 부분을 구현이라 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.일반적으로 사용하고 있는 getter / setter를 사용한 캡슐화는 진정한 의미의 캡슐화가 아닌것이 중요하다.간단한 예시를 통하여 인터페이스와 구현에 대해서 알아 보자.public class Customer {    public void order(String menuname, Menu menu, Barista barista) {        MenuItem menuItem = menu.choose(menuname);        Coffee coffee = barista.makeCoffee(menuItem);    }}고객은 order라는 메시지를 통하여 주문이라는 책임을 실행한다.여기서 중요한 점은 order라는 메소드가 public으로 공개 되어 있다는것이다.이로서 다른 누군가는 Customer는 order라는 메시지를 전송할 수 있다라는것을 알 수 있다.내부 구현으로 Menu를 통하여 어떤 커피를 만들어야 하는지 받아 오고 바리스타에게 해당하는 커피를 만들라는 메시지를 전달한다.public class Menu {    private List&lt;MenuItem&gt; menuItems;    public Menu(List&lt;MenuItem&gt; menuItems) {        this.menuItems = menuItems;    }    public MenuItem choose(String menuname) {        return menuItems.stream()                .filter(menuItem -&gt; menuItem.name().equals(menuname))                .findAny()                .orElseThrow(IllegalArgumentException::new);    }}Menu 객체를 살펴보자.여기서 중요하게 봐야할 부분은 choose가 아닌 menuItems를 내부에 상태로 가지고 있다는 것이다. Menu는 MenuItem에 의존하고 있는 상태가 된것이다. 코드를 살펴보면 Menu를 생성할 때 MenuItems를 생성자로 받아 생성하고 있습니다.이렇게 구현한 이유는 MenuItem이 추가 되더라도 다른 객체에서는 추가적인 수정이 필요 없고 오직 MenuItem을 의존하고 있는 Menu 클래스만 수정하여 choose라는 책임을 다하면 되는것 이다.public class MenuItem {    private String menuname;    private BigDecimal price;    private MenuType menuType;    public MenuItem(String menuname, BigDecimal price, MenuType menuType) {        this.menuname = menuname;        this.price = price;        this.menuType = menuType;    }    public String name() {        return menuname;    }    public BigDecimal cost() {        return price;    }    public MenuType menuType () {        return menuType;    }}public enum MenuType {    ESPRESSO, COLDBREW, LATTE}public class Barista {    public Coffee makeCoffee(MenuItem menuItem) {        return make(menuItem);    }    private Coffee make(MenuItem menuItem) {        if(menuItem.menuType().equals(MenuType.ESPRESSO)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.COLDBREW)) {            //Do SomeThing            return new Coffee(menuItem);        } else if(menuItem.menuType().equals(MenuType.LATTE)) {            //Do SomeThing            return new Coffee(menuItem);        }        throw new IllegalArgumentException();    }}이번 내용에서 가장 중요한 바리스타 클래스 입니다. 바리스타 객체는 커피를 만들어라라는 책임을 가지고 있는 클래스 이며 코드를 보시면 makeCoffee라는 메소드가 public 으로 오픈 되어 있습니다. 실제로 커피를 만드는 로직은 private으로 되어 있는 make라는 메소드에서 진행하고 있는데 이렇게 구현한 이유가 캡슐화를 하기 위해서 입니다. 외부에서는 바리스타는 커피를 만들수 있다 라는것을 알고 있지만 커피를 어떻게, 어떤 방식으로 만드는지는 모르도록 내부에 구현 로직을 private 으로 감싸서 숨긴 예시라고 할 수 있습니다.여기서 public 으로 오픈되어 있는 메소드는 인터페이스이며 private 으로 숨겨둔 메소드가 구현이라고 생각 하시면 될 것 같습니다.이러한 방식의 장점은 마찬가지로 커피를 만드는 방법이 추가 되더라도 커피는 바리스타 객체가 자율적으로 만들 수 있기 때문에 다른 클래스의 코드는 수정을 하지 않아도 된다는 것입니다.public abstract class BaristaI {    public Coffee makeCoffee(MenuItem menuItem) {        //doSomeThing        Coffee make = make(menuItem);        //dosomeThing        return make;    }    protected abstract Coffee make(MenuItem menuItem);}바리스타 클래스를 Template Method 패턴으로 구현하여 깔끔한 코드로 확인 할 수 있다.참조Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> 객체지향의 사실과 오해 </tag>
        
          <tag> Java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 4주차 강의 정리]]></title>
      <url>/dev/2020/03/13/ddd-serenade-4w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 4주차3주차 복습  전술적 설계 - ddd lite , building block          특정 디자인 패턴이 필요하다면 building block에 포함되는 것이다.        좋은 객체는 불변한 객체          도메인 주도 설계 빌딩 블록중 불변인 것들을 vo 라고 부른다.      vo는 equals와 hashcode를 재정의 하는것을 권장한다.      생성자 보다는 정적 팩토리 메소드를 사용해라.        Entity          내부에 상태값이 변하는 객체들은 entity로 만들 수 있다.      entity는 식별자를 갖는다.      도메인 모델에 set 메서드 넣지 않기      Aggregate  한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.      공통적으로 사용하는 애그리거트는 baseAggregate과 같이 trade-off할 수 있다.    수많은 aggregate중 root 로 만드는 방법은 외부에서 바라보는지를 확인 하면 된다.  애그리거트 루트는 일관성이 깨지지 않도록 해야한다.          생성자로 엔티티를 만들때 모든 속성을 가지고 있어야 한다.            클라이언트는 애그리거트의 내부 구현이 어떻게 되어 있는지 몰라야 한다.    Aggregate 참조          subentity를 외부에 노출시키면 안된다.              Root entity를 기준으로 repository를 제공해줘야 한다.            두개의 aggregate가 필요하다면 domain service가 도출되어야 한다.      하나의  aggregate에서도 domain service가 발생할 수 있다.        Factory          데이터를 가지고 있는 객체가 일을 하도록 메시지를 던져야 한다.      4주차  계층형 아키텍처          표현영역                  httprequest, response, session을 관리                    응용 서비스                  로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임.          도메인 영역에서 발생시킨 이벤트를 처리.                    도메인 서비스                  로직에 대한 버전 관리를 해야할 필요가 있는 경우 도메인 서비스가 될 수 있다.          두개 이상의 aggregate를 사용하면 반드시 도메인 서비스가 되어야 한다.                          같은 aggregate라도 두개 이상을 사용한다면 도메인 서비스.                                          메서드 파라미터와 값 리턴                  응용 서비스에 데이터로 전달할 파라미터가 두개 이상이면 데이터전달을 위한 별도 클래스를 사용하는것이 편리.          응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법.                    값 검증                  값 검증은 표현영역과 응용 서비스 두 곳에서 모두 수행 할 수 있다.          표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 아이디 중복 여부와 같은 논리적 오류만 검사하면 된다.                    인터페이스는 어느 시점에 생성하는것이 적절한가                  외부와 연동할 가능성이 크거나 연동하고 있는 것은 인터페이스를 만드는 것이 좋다.                      DTO          DTO는 프로세스 간에 데이터를 전달하는 객체가 아니고 구조체 라고 보는것이 맞다.      value object는 dto가 아니다.      value object는 어플리케이션 내부의 요구사항으로 만들어지고 dto는 어플리케이션 외부의 요구사항을 반영한다.      dto에서 entity를 만드는것은 괜찮으나 entity 에서 dto를 만드는것은 불가하다.      domain model everywhere      pure domain model                  항상 dto를 만드는 것은 실용적이지 않다.                          -&gt; vo로 해결 가능한 것은 vo로 해결 해도 된다.              vo는 영역과 관계없이 사용가능하기 때문이다.                                            의존 역전 원칙          고수준 모듈의 의존 문제                  저수준 모듈의 변경에 따라 고수준 모듈의 변경이 불가피 해진다.                    DIP 주의 사항                  추상화 한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치 해야 한다.          실제 구현은 infrastructure에서 구현(저수준)                    육각형, 양파, 클린 아키텍처                  공통된 목적은 내부에 있는 domain layerr를 외부로 부터 숨기고 지키는것이다.          내부는 외부를 모르고 외부는 내부를 몰라야 한다.                      anti corruption layer          외부로부터 내부 도메인 레이어를 지키기 위한 계층        주 생성자 -&gt; 모든 상태를 가지고 있는 생성자  부 생성자 -&gt; 부생성자가 주 생성자를 호출하는 방법  최상단 패키지는 Bounded Context로 나누고 Aggregate은 domain package에서 나누는 방  menu product가 price를 가지도록  infra - product 와 관련된 클래스를 만들고 productservice를 주입 받아 price를 얻는다 ? -&gt; anti corruption layer 만든다]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 3주차 강의 정리]]></title>
      <url>/dev/2020/02/21/ddd-serenade-3w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 3주차2주차 복습  유비쿼터스 언어          유비쿼터스 언어는 회의록, 회의, 코드 등에서 나타난다.      유비쿼터스 언어는 Bounded Context에서만 존재 해야 한다.      코드레벨에서는 유비쿼터스 언어가 검증이 되어야 한다.      검증이 되지 않으면 실패할 가능성이 크다.        용어사전          도메인 주도 설계가 성공하기 위해선 용어 사전을 개발자만 참여하는것이 아닌 프로젝트에 참여하는 모두가 관리 해야 한다.      프로젝트가 커질 시 컨텍스트 별로 용어 사전을 정리 해야 한다. (동일한 용어가 다른 의미를 가질 수 있다.)        모델링          모델링은 소리 내어 읽었을때 어색하지 않아야 한다.        Bounded Context          BC는 서로 다른 관점을 찾는 것이다.      우발적인 중복은 충분한 고민을 해봐야 한다.      하나의 BC는 하나의 팀에서만 관리하는것이 베스트이다.        OOP vs DDD          oop 에서의 상속으로 풀수 있는 문제 라고 하더라도 ddd 에선 context 간 분리가 더 중요하다.     그로 인해 context 내부에 중복이 발생 할 수도 있다.        이벤트 스토밍          단순한 조회 같은 행위는 이벤트가 아닐 수도 있다.      조회를 하여 조회 카운트가 상승했다 와 같은 행위가 이벤트이다.      개발자들은 이벤트 스토밍 도중 기획자나 도메인 전문가 들이 설계를 어렵게 하는 부분에 대해 문제를 제기 할 줄 알아야 한다.        Aggregate          독립된 라이프 사이클을 가지는 무언가        공통된 단어가 나오면 반드시 context를 나눠야 한다.  (최소 context 수)최대 context 개수는 는 aggregate 개수  도메인 주도 설계는 설게 후 구축이 아닌 설계와 구축이 병렬적으로 진행 되어야 한다.전술적 설계 - ENTITY 와 VALUE OBJECT  Entity는 지속적으로 상태를 관찰해야할 필요가 있을때 만든다.  내부적인 상태가 변하더라도 동일한 객체라고 인식을 해야 할 때 식별자를 만들고 Entity로 만든다.  도메인 모델에 setter 가 있으면 해당 도메인 모델은 완전한 상태가 아니게 된다.          버릇처럼 쓰는 setter 는 남발하면 안된다.        모든 객체는 불변 객체가 가장 좋다.          새로운 타입의 객체를 만들어서 유효성 검사 로직을 옮긴다.      객체 끼리의 책임을 나누는 방법.      분리 된 객체는 만들어지거나 실패하거나 원자성을 보장한다.      값 객체 (value object- 불변 객체)는 동일성과 동등성을 보장해야 한다.                  가변 객체는 값이 바뀜에 따라 의미가 달라 질 수 있다.          불변 객체는 값이 바뀜에 따라 새로운 불변 객체를 만들어 내야 한다.          불변 객체는 계속 생성이 되면 메모리 부하가 일어나지 않나 ?                          -&gt; 컴퓨팅 파워와 GC를 믿어야 한다.                                          불변 객체                  포함 되고 있는 모든 값들을 final 로 만든다.          1 + 1 = 2 가 아닌 new int(2)          리스트 같은 멤버 변수는 final을 사용해도 값이 바뀔수 있어서 의식적인 방어적 복사가 필요하다.                    AGGREGATE  엔티티와 ValueObject (관련 객체)가 모여있는 군집.  반장이라는 개념이 있다 (루트 엔티티)  Bounded Context &gt; Context &gt; AGGREATE  동일한라이프 사이클을 가진것을 하나의 AGGREGATE로 묶는다.          ex) 자동차 인스턴스가 사라지면 내부에 속한 핸들 및 바퀴와 같은 인스턴스도 같이 사라져야 한다.        하나의 Aggregate에 속하면 다른 Aggregate에는 속하지 못한다.  정리 하면 많은 엔티티들을 동일한 라이프 사이클로 묶어둔 군집  Aggregate Root          외부에선 해당 aggregate와 대화 하기 위해선 Root에게 요청을 해야 한다.      Aggregate Root 도 하나의 엔티티 이기 때문에 내부에 상태를 가지고 있다.      서로 다른 Aggregate와 대화 하기 위해선 반드시 Aggregate Root를 거쳐야 한다.      내부에 어떤 상태를 가지고 있는지 외부에서는 알지 못한다 (캡슐화)        두개 이상의 엔티티가 하나의 Aggretate에 있으면 어떤걸 Root로 할까 ?          Aggregate Root 가 될 수 있는 기준은 Global 식별자(외부에서 참조 하고 있는 식별자) 를 가지고 있는것. 따라서 Order가 Root      로컬 식별자 를 가지고 있으면 루트가 될 수 없다.        정리 하면 글로벌 식별자를 가지고 있어야 루트 에그리게잇이 될 수 있다.  Aggregate 참조          직접 참조를 허용하면 편리함을 오용한다.      ID를 이용한 간접 참조를 권장한다.                  복잡도를 낮출 수 있다.                    같은 Aggregate 에선 직접 참조 해야 한다.      Repository  Repository 는 구현을 위한 도메인 모델.  Aggregate 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.  리포지토리는 Aggregate(Root)단위로 존재하며 테이블 단위로 존재하는 것이 아니다.          리포지토리는 Aggregate을 위한 컬렉션으로 생각하면 된다.      Service  어플리케이션 서비스와 도메인 서비스는 다르다.  여러 도메인이 가진 로직들을 하나의 서비스에서 처리 하기 위한 레이어.  도메인 서비스라는 것은 엔티티, vo, repository를 만든 상태에서 정책 또는 로직을 특정 애그리게잇의 행위로 지정하기 어려운것들.  객체 지향이 아닌 절차 지향적인 로직들을 도메인 서비스로 분리해서 특별하게 관리 할 수 있다.  도메인 서비스와 어플리케이션 서비스는 상태값을 가지고 있지 않다는것에선 유사하지만 서로 다루는 서비스 영역이 다르다.Factory  연관된 Aggregate에서 생성 해보자.          ex) 좋은 모델링 - LadderGame 이 종료되야 GameResult 생성                  사다리게임이 끝나야 게임 결과를 생성한다 라는것은 게임 결과는 게임을 통해서 알수 있다는 비즈니스 로직을 한눈에 알수 있는것이다.                    ]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DDD 세레나데 2주차 강의 정리]]></title>
      <url>/dev/2020/02/14/ddd-serenade-2w/</url>
      <content type="text"><![CDATA[  DDD 세레나데 2주차전략적 설계유비쿼터스 언어 - 개발자와 도메인 전문가가 공통적으로 이해 할수 있는 영역의 언어.  모든 상황(회의, 코드, 도메인…)에서 사용하는 언어 (언제, 어디에서나)  기획자나 개발자는 모두 동일하게 이해할 수 있는 언어를 사용해야 한다.  용어사전을 정의 하고 항상 유지 해야 한다.          용어 사전은 죽은 문서가 될 가능성이 많다.        유비쿼터스 언어를 가장 잘 검증해주는 곳은 코드레벨 이다.          개발자의 입장에선 코드레벨에 유비쿼터스 언어가 존재하는것은 좋다.      기획자와 디자이너도 볼 수 있도록 용어가 추가 될 시 용어 사전을 업데이트 해야한다.        용어 사전이란 유비쿼터스 언어를 정리 해둔 사전이다.          프로젝트에 참여하는 모두가 알고 관리 해야한다.      효과적인 모델링  RouteService 는 RouteSecification 만족하는 plan을 찾는다.          개발자는 RouteService 에 RouteSecification 전달하면 plan return 이라고 해석이 된다. Ex ) 환불은 환불정책을 통해서 환불금액이 결정된다.      한팀, 한 언어  사업팀도 모델링을 이해하지 못한다면 모델링이 잘못된 것이다.Bounded Context (문맥 경계)  도메인 별로 용어사전이 다르기때문에 동일한 용어를 다른 도메인에서 사용하면 안된다.  모델은 특정한 문장(문맥)에서 완전한 의미를 가지게 된다.  동일한 단어가 발생하면 Bounded Context 나누기 가장 좋은 상태이다  Ex) 피자가게있는 피자, 쓰레기통에 있는 피자          피자라는 언어를 사용하지만 문맥에 따라서 피자의 의미가 다르다.      좋은 Bounded Context  하나의 Bounded Context는 하나의 팀만 관리 해야 한다.          의견 마찰 및 도메인 영역의 마찰을 줄이기 위해.      하나의 팀이 여러 Bounded Context는 관리 할 수 있다.        각각의 Bounded Context는 각각의 개발 환경을 가질 수 있다.          명확히 구분되는 경계를 그엇기 때문이다.      MSA로 가는 기초.      어떻게 경계를 나눌것인지를 먼저 생각 해야 한다.      Context Map  컨텍스트 맵은 상호 교류하는 시스템의 목록 제공 및 의사소통의 촉매 역할을 한다.  Upstream : 데이터 제공. (Api, Event)  DownStream : 데이터 수신.프로젝트와 조직 관계  파트너십 : 두 context가 하나의 트랜잭션으로 묶여있다.  공유 커널 : 상호 의존하는 공유 모델을 관리한다.  고객 - 공급자(costomer - surpplier) : 업스트림(서버 : 공급자) : 다운스트림(클라이언트 : 고객)으로 단방향 의존한다.  순응주의자(Ex_Open API) : 업스트림(서버)가 모든것을 제어한다.  오픈 호스트 서비스 : REST/API, RPC, Socket  분리된 방법 : 의존 없음  큰 진흙공 : 안티 패턴DDD vs OOP  Context 마다 서로 유비쿼터스 언어를 다른 도메인으로 인식한다.  OOP는 상속이나 재활용성을 위해서 공통된 데이터를 공유하는 것을 중요시  DDD는 도메인 분리를 중시DDD가 성공할 수 있는 전제 조건  DDD는 현업의 절대적인 도움이 필요하다.  이해관계자의 스폰서십이 적극 필요.이벤트 스토밍  정의          도메인 전문가와 개발자를 학습 과정에 참여시키기 위한 빠른 설계기술      비즈니스 및 비즈니스 프로세스에 중점을 둔다.                  클래스와 데이터베이스가 아닌 이벤트와 비즈니스 프로세스에 중점을 둔다.                    코드를 없애고 모든 사람을 동일한 수준으로 만드는 시각적 접근      Aggregate  이벤트 스토밍 중 같은 단어가 중복적으로 발생하면 집합으로 만든다.  Aggreate 하나의 하나의 엔티티를 가지는것이 좋지만 항상 지켜야 하는것은 아니다.]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> DDD </tag>
        
          <tag> NEXTSTEP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring JPA DB Master / Slave 적용시 주의할 점]]></title>
      <url>/dev/2020/01/24/jpa-replication-issue/</url>
      <content type="text"><![CDATA[스프링 JPA를 사용하면서 데이터 베이스 이중화를 하는 경우에 크게 두가지 방법으로 구현한다. 첫번째는 AOP 를 이용하여 쿼리 타이밍에 특정한 Datasource를 불러오는 방법. 두번째는 Transaction의 Readonly 속성을 감지하여 이중화. 지금 진행중인 프로젝트에서 두번째 방법으로 데이터베이스 이중화를 설정하였지만 생각하지 못한 문제점이 발생. 원인파악 및 최소한의 해결 방법을 정리.  문제점          DataSource를 여러개를 사용하기 때문에 일반적으로 스프링 JPA 설정으로 데이터소스를 만들수 없다. 커스텀한 데이터 소스들을 서버가 실행될때 등록하여 실행한다.      위 방법을 사용시 스프링에서 제공해주는 기본 설정을 사용하지 못하여 @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) 와 같이 기본설정을 제거 하는 코드가 필요.      기본설정을 제거 하여 Entity Manager룰 새롭게 등록 해주어야 했다.      LocalContainerEntityManagerFactoryBean 를 사용하여 EntityManager를 등록 하니 아무런 설정들이 없는상태.      스프링 JPA를 사용하면 hibernate naming 전략이 snake case로 설정된다. 하지만 자동설정을 못하니 naming 전략이 camel case로 설정 되어 실행되고 있었다.      문제점을 해결하기 위해 property에 naming 전략을 정의 해봤지만 정상적으로 실행되지 않았다. 구글링 결과 아래 코드를 사용하여 해결할 수 있었다.            entityManagerFactoryBean.setDataSource(dataSource());    entityManagerFactoryBean.setPackagesToScan("com.my.pakage");    entityManagerFactoryBean.setJpaVendorAdapter(vendorAdapter);    HashMap&lt;String, Object&gt; properties = new HashMap&lt;&gt;();    properties.put("hibernate.physical_naming_strategy", "org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy");    entityManagerFactoryBean.setJpaPropertyMap(properties);                      남은 문제          스프링 자동 설정이 정확히 어떤것들을 설정해 주는지 모르니 기본적으로 사용하던 설정들중 어떤것들이 빠져 있는지 확인이 필요하다.      가능하다면 스프링에서 제동해주는 자동설정을 그대로 사용하고 싶기 때문에 방법을 조금더 찾아 볼 예정.        문제 해결 추가.          스프링 자동 설정중 테이블 네이밍 설정이 빠져 있는것을 확인. hibernate.implicit_naming_strategy / org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy 추가.      스프링에서 제공하는 자동 설정이 어떤것들이 있는지 라이브러리에서 확인. org.springframework.boot.autoconfigure.orm.jpa 해당 패키지 아래 jpa, hibernate autoconfiguration을 확인할 수 있다.      개발환경  스프링 부트 2.2.2  스프링 데이터 JPA 2.2.2]]></content>
      <categories>
        
          <category> dev </category>
        
      </categories>
      <tags>
        
          <tag> JPA </tag>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
